% \iffalse meta-comment
%
%% File: pdfresources.dtx
%
% Copyright (C) 2019 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "pdfresources bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver>
\documentclass{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%    \begin{macrocode}
\RequirePackage{expl3}
\ProvidesExplPackage {pdfresources} {2019-03-17} {0.1}
  {experimental pdf-resource management}
%    \end{macrocode}
%
% \title{\pkg{pdfresources}}
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2019-03-04}
%
% \maketitle
% \section{Existing resource usage}
%
% \subsection{\pkg{hyperref}}
%
% \subsection{\pkg{pgf}}
%
% In \pkg{pgf}, resource management is set up in the file |pgfutil-common.tex|.
% This then provides three functions for adding to the resources, all of which
% are objects:
% \begin{itemize}
%   \item \cs{pgfutil@addpdfresource@extgs}: Extended graphics state
%   \item \cs{pgfutil@addpdfresource@colorspaces}: Color spaces
%   \item \cs{pgfutil@addpdfresource@patterns}: Patterns
% \end{itemize}
%
% These resource dictionaries are used by adding entries in a cumulative sense;
% the macro layer deals with ensuring that each entry is only given once. Note
% that the objects themselves must be given only once for each page.
%
% To support these functions, there are a series of set-up macros which install
% these resources. That has to take place for every page: the exact route
% therefore depends on the driver.
%
% \subsection{\pkg{media9}}
%
% \section{New driver Code}
% \subsection{already revisited }
%
%    \begin{macrocode}
%<*drivers>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=driver>
%    \end{macrocode}
%
% \subsubsection{\texttt{pdfmode} driver}
%
%    \begin{macrocode}
%<*pdfmode>

%    \end{macrocode}
%
%
%
%    \begin{macrocode}
%</pdfmode>
%    \end{macrocode}
%
% \subsubsection{\texttt{(x)dvipdfmx} driver}
%
%    \begin{macrocode}
%<*dvipdfmx|dvixpdfmx>
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</dvipdfmx|dvixpdfmx>
%    \end{macrocode}
%
%    \begin{macrocode}
%</drivers>
%    \end{macrocode}
%
%
% \subsection{driver commands / experimental}
% Notes: pdftex and luatex the startlink commands can use different \enquote{action spec}
% \texttt{user}, \texttt{goto} and \texttt{thread}. To be able to translate this to
% other drivers, startlink variants are defined.
% Variants which allow also to set the rule spec are perhaps needed too.
% Currently only pdftex, luatex and xetex are setup. Some commands can probably not be
% implemented in all drivers.
%    \begin{macrocode}
%<*package>
\sys_if_engine_pdftex:T
{

 \cs_new_protected:Nn \driver_pdf_catalog:n
 {
  \pdfcatalog { #1 }
 }

 \cs_new_protected:Nn \driver_pdf_info:n
 {
  \pdfinfo { #1 }
 }

\cs_new_protected:Nn \driver_pdf_dest_name:nn %#1 name, #2 dest type (e.g. fitbh)
 {
  \pdfdest~{#1}#2\scan_stop:
 }

% this needs refinement, probably is should create named objects and add
% them to the properties, see discussion
%
\cs_new_protected:Npx \driver_pdf_bdc:nn #1 #2
  {
    \cs_if_exist:NTF \tex_pdfextension:D
      { \tex_pdfextension:D literal~page~{#1~#2~BDC} }
      { \tex_pdfliteral:D~page~{#1~#2~BDC}  }
  }


\cs_new_protected:Npx \driver_pdf_emc:
  {
    \cs_if_exist:NTF \tex_pdfextension:D
      { \tex_pdfextension:D literal~page~{EMC} }
      { \tex_pdfliteral:D~page~{EMC}  }
  }

\input{l3pdfmode-pdf.def}
}

\sys_if_engine_luatex:T
{
 %allow version 2.0 in luatex. Needs sorting out later.
 \@namedef{Hy@pdfversion@2.0}{10}%
 \cs_new_protected:Nn \driver_pdf_catalog:n
 {
  \pdfextension catalog { #1 }
 }

 \cs_new_protected:Nn \driver_pdf_info:n
 {
  \pdfextension info { #1 }
 }

\cs_new_protected:Nn \driver_pdf_dest_name:nn %#1 name, #2 dest type (e.g. fitbh)
 {
  \pdfextension~dest~name~{#1}#2 \scan_stop:
 }

\cs_new_protected:Npx \driver_pdf_bdc:nn #1 #2
  {
    \cs_if_exist:NTF \tex_pdfextension:D
      { \tex_pdfextension:D literal~page~{#1~#2~BDC} }
      { \tex_pdfliteral:D~page~{#1~#2~BDC}  }
  }


\cs_new_protected:Npx \driver_pdf_emc:
  {
    \cs_if_exist:NTF \tex_pdfextension:D
      { \tex_pdfextension:D literal~page~{EMC} }
      { \tex_pdfliteral:D~page~{EMC}  }
  }


\input{l3pdfmode-pdf.def}
}

\sys_if_engine_xetex:T
{
 %% need to be checked if resources are ok!!!!
 \cs_new_protected:Npn \driver_pdf_bmc:n #1
  {
    \special{pdf:code~#1~BMC}
    %\special{pdf:content~#1~BMC}%
  }

\cs_new_protected:Npn \driver_pdf_bdc:nn #1 #2
  {
    \special{pdf:code~#1~#2~BDC}
    %\special{pdf:content~#1~#2~BDC}%accsupp
  }

\cs_new_protected:Npn \driver_pdf_emc:
  {
    \special{pdf:code~EMC}
    %\special{pdf:content EMC}%accsupp
  }

 %% \cs_new_protected:Nn \driver_pdf_catalog:n ????
 \input{l3dvipdfmx-pdf.def}
}
%</package>
%    \end{macrocode}
% \section{Management code / pdf Module}
%<@@=pdf>
% \subsection{Setting / comparing pdf versions}
% The code assumes that the versions are two integers separated by a period.
%
% \begin{macro}{\pdf_version_gset:n, \pdf_version_min_gset:n}
% \begin{macro}{\@@_version_gset:w}
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdf_version_gset:n #1
 {
  \__pdf_version_gset:w  #1 . . \q_stop
 }

\cs_new_protected:Npn \pdf_version_min_gset:n #1
 {
  \pdf_version_compare:NnT < {#1}
   {
    \@@_version_gset:w  #1 . . \q_stop
   }
 }

\cs_new_protected:Npn \@@_version_gset:w  #1 .#2 . #3\q_stop
 {
  \driver_pdf_version_major_gset:n {#1}
  \driver_pdf_version_minor_gset:n {#2}
 }
%</package>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\pdf_version_compare:Nn}
%    \begin{macrocode}
%<*package>
\cs_new:cpn { @@_version_compare_=:w } #1 .#2 . #3\q_stop
 {
   \bool_if:nTF
    {
     \int_compare_p:n { \driver_pdf_version_major: = #1  }
     &&
     \int_compare_p:n { \driver_pdf_version_minor: = #2}
    }
    { \prg_return_true: }
    { \prg_return_false: }
 }

\cs_new:cpn { @@_version_compare_<:w } #1 .#2 . #3\q_stop
 {
   \bool_if:nTF
    {
     \int_compare_p:n  { \driver_pdf_version_major: < #1}
     ||
     (
      \int_compare_p:n { \driver_pdf_version_major: = #1 }
      &&
      \int_compare_p:n { \driver_pdf_version_minor: < #2 }
     )
    }
    { \prg_return_true: }
    { \prg_return_false: }
 }

\cs_new:cpn { @@_version_compare_>:w } #1 .#2 . #3\q_stop
 {
   \bool_if:nTF
    {
     \int_compare_p:n  { \driver_pdf_version_major: > #1}
     ||
     (
      \int_compare_p:n { \driver_pdf_version_major: = #1}
      &&
      \int_compare_p:n { \driver_pdf_version_minor: > #2 }
     )
    }
    { \prg_return_true: }
    { \prg_return_false: }
 }

\prg_new_conditional:Npnn \pdf_version_compare:Nn #1 #2
 {
  p,T,F,TF
 }
 {
  \use:c {@@_version_compare_#1:w} #2 . . \q_stop
 }
%</package>
%    \end{macrocode}
% \end{macro}
% \subsection{Higher-level link management}
% \subsubsection{Startlink}
% packages like ocgx2 and tagpdf wants to add code to links/annotation created by hyperref.
% So we need a generic command to start a pdflink which allows packages to add
% their code to the \texttt{attr} argument through hooks.
%    \begin{macrocode}
%<*package>
\cs_new:Nn \__pdf_get_key_value:nn { #1~#2~ } %name?????
%</package>
%    \end{macrocode}
% Attributes are stored in a property list. Packages can add attributes through
% dedicated command. We assume that there will be different link types
% (url, file, run, link, is a cite type needed??\ldots)
% and that they should have their own attribute list.
% Probably we will need some commands to fill more than one prop ...
%
%    \begin{macrocode}
%<*package>
\prop_new:N\l__pdf_hook_link_begin_url_attr_prop  %\hyper@linkurl
\prop_new:N\l__pdf_hook_link_begin_file_attr_prop %\hyper@linkfile
\prop_new:N\l__pdf_hook_link_begin_run_attr_prop  %\@hyper@launch run
\prop_new:N\l__pdf_hook_link_begin_link_attr_prop %\hyper@link, \find@pdflink
\prop_new:N\l__pdf_hook_link_begin_menu_attr_prop %\Acrobatmenu
%</package>
%    \end{macrocode}
%
% High-level startlink commands that uses the stored attributes:
% At first one with the \texttt{user} argument:
% A link command that grabs the content as argument and inserts both
% startlink and endlink directly (driver command is already in l3driver).
%    \begin{macrocode}
%<*package>
\cs_new_protected:Nn \pdf_link_user:nnn %#1 type (url, file etc, #2 action spec, #3 link text
 {
   \seq_if_exist:cT { l__pdf_hook_link_begin_#1_seq }
   {
    \seq_use:cn { l__pdf_hook_link_begin_#1_seq }{}
   }
   \mode_leave_vertical:
   %\driver_pdf_link_user:nnn
   \driver_pdf_link_begin_user:nnw
    {
     \prop_if_exist:cT { l__pdf_hook_link_begin_#1_attr_prop }
     {
      \prop_map_function:cN
       { l__pdf_hook_link_begin_#1_attr_prop }
       \__pdf_get_key_value:nn
      }
    }
    {
      #2
    }
    #3
   \driver_pdf_link_end:
   \seq_use:cn { l__pdf_hook_link_end_#1_seq }{}
 }
%</package>
%    \end{macrocode}
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdf_link_begin_user:nnw #1 #2 %#1 type, #2 action spec
{
 \seq_if_exist:cT { l__pdf_hook_link_begin_#1_seq }
   {
    \seq_use:cn { l__pdf_hook_link_begin_#1_seq }{}
   }
 \driver_pdf_link_begin_user:nnw
  {
   \prop_if_exist:cT { l__pdf_hook_link_begin_#1_attr_prop }
    {
     \prop_map_function:cN
      { l__pdf_hook_link_begin_#1_attr_prop }
      \__pdf_get_key_value:nn
     }
  }
  { #2 }
}

% At second one with the \texttt{goto name} argument:
\cs_new_protected:Npn \pdf_link_begin_goto:nnw #1 #2 %#1 type, #2 destination
{
 \seq_if_exist:cT { l__pdf_hook_link_begin_#1_seq }
   {
    \seq_use:cn { l__pdf_hook_link_begin_#1_seq }{}
   }
 \driver_pdf_link_begin_goto:nnw
  {
   \prop_if_exist:cT { l__pdf_hook_link_begin_#1_attr_prop }
     {
      \prop_map_function:cN
      { l__pdf_hook_link_begin_#1_attr_prop }
      \__pdf_get_key_value:nn
     }
  }
  { #2 }
}
%</package>
%    \end{macrocode}
%
% \subsubsection{Endlink}
% tagpdf needs to execute code at the end of the link to store the object reference etc.
% So we need a hook. For now the hook is a seq: This will perhaps allows a system to
% add and remove hooks by index. The hook depends on the type.
%    \begin{macrocode}
%<*package>
\seq_new:N \l__pdf_hook_link_end_url_seq
\seq_new:N \l__pdf_hook_link_end_run_seq
\seq_new:N \l__pdf_hook_link_end_file_seq
\seq_new:N \l__pdf_hook_link_end_link_seq
\seq_new:N \l__pdf_hook_link_end_menu_seq

\cs_new_protected:Nn \pdf_link_end:n %#1 type, e.g. url
 {
  \driver_pdf_link_end:
  \seq_if_exist:cT {l__pdf_hook_link_end_#1_seq}
   {
    \seq_use:cn { l__pdf_hook_link_end_#1_seq }{}
   }
 }

%</package>
%    \end{macrocode}
% \subsection{Before the links}
% Both hyperref and tagpdf wants to insert code before the \cs{pdfstartlink} so lets
% setup hooks for this too:
%    \begin{macrocode}
%<*package>
\seq_new:N \l__pdf_hook_link_begin_url_seq
\seq_new:N \l__pdf_hook_link_begin_run_seq
\seq_new:N \l__pdf_hook_link_begin_file_seq
\seq_new:N \l__pdf_hook_link_begin_link_seq
%</package>
%    \end{macrocode}
%
% \section{Hook management}
% hooks are commands that allow users and other packages to inject code.
%
% \subsection{hooks with token lists}
%  Hook code can be stored in a simple token list variable (tl). An example is e.g.
% \cs{@begindocumenthook}. In this case possible operations are
% \begin{itemize}
% \item \emph{appending} to the hook
% \item \emph{prepending} to the hook
% \item and perhaps some more or less complicated \emph{patching} to remove/replace parts
% \end{itemize}
%
% Such a hook can be \emph{used} by using the variable.
%
% \subsection{hooks with sequences}
% Hook code can also be stored in a sequence (seq). In this data structure every user adding
% something to the hook can get an index back.
% In this case possible operations are
% \begin{itemize}
% \item \emph{appending} to the hook (\cs{seq_put_right}),
% \item \emph{prepending} to the hook (need to keep track of the \enquote{zero pointer} if the user
% should get an index back)
% \item \emph{changing} (e.g emptying) a hook item through the index. But as this
% involves mapping through the sequence to find the right item, it is perhaps too slow.
% \end{itemize}
%
% Such a hook can be \emph{used} by mapping over the sequence. It is possible to filter or
% exclude items. It is also possible to insert code while processing the individual items.
% It is not quite clear if the additional features of such sequence hooks are really needed
% but the overhead is not so large, so it should be ok to use is. Probably if the type
% is used at all, it would be sensible to drop the tl-type so that one doesn't have to define
% \cs{hook_put_right_tl:nnn} and \cs{hook_put_right_seq:nnn} functions.
%
% \subsection{hooks with properties}
% Hook code can also be stored in a property (prop). Here possible operations are
% \begin{itemize}
% \item \emph{adding} a new key and its value. It is possible to write the interface so
% that only a specific set of keys are allowed.
% \item \emph{changing} the value of an existing key, either by overwriting the
% current value or by appending more code to the value -- the second could e.g. be used
% to extend the /ExtGState or /ColorSpace values.
% \item \emph{removing} a key
% \end{itemize}
%
% A hook stored like this can be used by mapping over the properties, but selective
% use and filtering is possible too.
%
% Such a hook is useful if -- like in the case of dictionary values in a pdf -- various
% packages need to be able to manipulate the same key.
%
% \subsection{Naming hooks and access functions}
% hooks are module specific. So set functions should probably do be something like
%
% \cs{hook_put_right:nnn}\verb+{<module>}{<hook-name>}{value}+ (seq- or tl-type)
% or in the case of  properties
% \cs{hook_put:nnnn} {<module>}{<hook-name>}{<key>}{<value>}
%
% hooks should be manipulated only through such access functions. So their
% name should be an internal command of the module. E.g.
% \cs{l__<module>_hook_<hook-name>_prop}
%
%    \begin{macrocode}
%<*package>
\cs_new:Nn \hook_put_right:nnn
 {
  \seq_put_right:cn { l__#1_hook_#2_seq } { #3 }
 }

\cs_new:Nn \hook_put_left:nnn
 {
  \seq_put_left:cn { l__#1_hook_#2_seq } { #3 }
 }

\cs_new:Nn \hook_put:nnnn
 {
  \prop_put:cnn { l__#1_hook_#2_prop } { #3 }{ #4 }
 }

\cs_new:Nn \hook_gput:nnnn
 {
  \prop_gput:cnn { g__#1_hook_#2_prop } { #3 }{ #4 }
 }

\cs_new:Nn \hook_remove:nnn
 {
  \prop_remove:cn { l__#1_hook_#2_prop } { #3 }
 }

\cs_new:Nn \hook_gremove:nnn
 {
  \prop_gremove:cn { g__#1_hook_#2_prop } { #3 }
 }
%</package>
%    \end{macrocode}
%
%
% \PrintIndex
