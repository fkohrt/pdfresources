% \iffalse meta-comment
%
%% File: pdfresources.dtx
%
% Copyright (C) 2019 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "pdfresources bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver>
\documentclass{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%    \begin{macrocode}
%<@@=pdf>
%<*package>
\RequirePackage{xparse}
\RequirePackage{tmpl3shipout}
\ProvidesExplPackage {pdfresources} {2019-03-17} {0.1}
  {experimental pdf-resource management}
\DeclareOption { debug }{\msg_redirect_module:nnn {pdf}{warning}{error}}
\bool_new:N\g_@@_patches_bool
\DeclareOption { patches }{\bool_gset_true:N\g_@@_patches_bool}
\ProcessOptions\relax
%</package>
%    \end{macrocode}
%
% \title{\pkg{pdfresources}}
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2019-03-04}
%
% \maketitle
% \section{Existing resource usage}
%
% \subsection{\pkg{hyperref}}
%
% \subsection{\pkg{pgf}}
%
% In \pkg{pgf}, resource management is set up in the file |pgfutil-common.tex|.
% This then provides three functions for adding to the resources, all of which
% are objects:
% \begin{itemize}
%   \item \cs{pgfutil@addpdfresource@extgs}: Extended graphics state
%   \item \cs{pgfutil@addpdfresource@colorspaces}: Color spaces
%   \item \cs{pgfutil@addpdfresource@patterns}: Patterns
% \end{itemize}
%
% These resource dictionaries are used by adding entries in a cumulative sense;
% the macro layer deals with ensuring that each entry is only given once. Note
% that the objects themselves must be given only once for each page.
%
% To support these functions, there are a series of set-up macros which install
% these resources. That has to take place for every page: the exact route
% therefore depends on the driver.
%
% \subsection{\pkg{media9}}
%
% \section{New driver Code}
% \subsection{already revisited }
%
%    \begin{macrocode}
%<*drivers>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=driver>
%    \end{macrocode}
%
% \subsubsection{\texttt{pdfmode} driver}
%
%    \begin{macrocode}
%<*pdfmode>

%    \end{macrocode}
%
%
%
%    \begin{macrocode}
%</pdfmode>
%    \end{macrocode}
%
% \subsubsection{\texttt{(x)dvipdfmx} driver}
%
%    \begin{macrocode}
%<*dvipdfmx|dvixpdfmx>
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</dvipdfmx|dvixpdfmx>
%    \end{macrocode}
%
%    \begin{macrocode}
%</drivers>
%    \end{macrocode}
%
%
% \subsection{driver commands / experimental}
% Notes: pdftex and luatex the startlink commands can use different \enquote{action spec}
% \texttt{user}, \texttt{goto} and \texttt{thread}. To be able to translate this to
% other drivers, startlink variants are defined.
% Variants which allow also to set the rule spec are perhaps needed too.
% Currently only pdftex, luatex and xetex are setup. Some commands can probably not be
% implemented in all drivers.
% % still needed:
% % \pdf@strcmp??
% % \pdf@escapestring?? \pdfescapestring
%    \begin{macrocode}
%<*package>
%some variants
% helper command to output a key + value of a prop as needed in a dict.
% name? explicit spaces?
% not internal as perhaps needed also by users?
\cs_new:Npn \driver_pdf_dict_item:nn #1 #2 {/#1~#2~}
%</package>
%    \end{macrocode}
%\subsubsection{pdfxform}
% as in dvi mode the xform is immediate, let's do it for pdftex/luatex too. If needed
% a delayed version can be added later.
%    \begin{macrocode}
%<*package>
\prop_new:N \g__driver_pdf_xform_prop
\bool_if:nT {\sys_if_engine_pdftex_p: && \sys_if_output_pdf_p: }
{
 \cs_new_protected:Npn \driver_pdf_xform_new:nnnN #1 #2 #3 #4 %name, attr, resources, box
 {
  \tex_immediate:D \tex_pdfxform:D~attr { #2 }~resources {#3} #4
  \int_const:cn
   { c__driver_pdf_xform_ \tl_to_str:n {#1} _int }
   { \tex_pdflastxform:D }
  \prop_gput:Nnx \g__driver_pdf_xform_prop {#1}
   {
    \tex_pdfxformname:D \int_use:c {c__driver_pdf_xform_ \tl_to_str:n {#1} _int}
   }
 }

\cs_new:Npn \driver_pdf_xform_use:n #1
 {
  \tex_pdfrefxform:D \int_use:c { c__driver_pdf_xform_ \tl_to_str:n {#1} _int } \scan_stop:
 }

% should there be a test if the name exists???
\cs_new:Npn \driver_pdf_xform_ref:n #1
  { \int_use:c { c__driver_pdf_xform_ \tl_to_str:n {#1} _int } ~ 0 ~ R }

\cs_new:Npn \driver_pdf_xform_name_ref:n #1
  { /Fm\prop_item:Nn \g__driver_pdf_xform_prop {#1} }
}

%nearly identical but not completly ...
\sys_if_engine_luatex:T
{
 \cs_new_protected:Npn \driver_pdf_xform_new:nnnN #1 #2 #3 #4 %name, attr, resources, box
 {
  \tex_immediate:D \tex_pdfxform:D~attr { #2 }~resources {#3} #4
  \int_const:cn
   { c__driver_pdf_xform_ \tl_to_str:n {#1} _int }
   { \tex_pdflastxform:D }
  \prop_gput:Nnx \g__driver_pdf_xform_prop {#1}
   {
    \tex_pdffeedback:D~xformname  \int_use:c {c__driver_pdf_xform_ \tl_to_str:n {#1} _int}
   }
 }

\cs_new:Npn \driver_pdf_xform_use:n #1
 {
  \tex_pdfrefxform:D \int_use:c { c__driver_pdf_xform_ \tl_to_str:n {#1} _int } \scan_stop:
 }
\cs_new:Npn \driver_pdf_xform_ref:n #1
  { \int_use:c { c__driver_pdf_xform_ \tl_to_str:n {#1} _int } ~ 0 ~ R }

\cs_new:Npn \driver_pdf_xform_name_ref:n #1
  { /Fm\prop_item:Nn \g__driver_pdf_xform_prop {#1} }
}

%</package>
%    \end{macrocode}
% \subsubsection{driver / pdfpagesattr}
% pdfpagesattr is a single token register which is output at the end of the compilation.
% It is normally used only a few times in a document, so it is okay to update the
% register at every change. This also allows to test for unwanted changes.
% throught uses of the primitives. We issue the push code also at the end of
% the document, so that it wins.
%
%    \begin{macrocode}
%<*package>
\prop_new:N \g_@@_pdf_pagesattr_prop
% setter:
\cs_new_protected:Npn \driver_pdf_pagesattr_gput:nn #1 #2
  {
   \prop_gput:Nnn \g_@@_pdf_pagesattr_prop { #1 }{ #2}
   \@@_pdf_pagesattr_gpush:
  }

% getter from the prop:
\cs_new_protected:Npn \driver_pdf_pagesattr_get:nN #1 #2
  {
   \prop_get:NnN \g_@@_pdf_pagesattr_prop { #1 } #2
  }

% remove:
\cs_new_protected:Npn \driver_pdf_pagesattr_gremove:n #1
  {
   \prop_gremove:Nn \g_@@_pdf_pagesattr_prop { #1 }
   \@@_pdf_pagesattr_gpush:
  }

% push to the register
\cs_new_protected:Npn \@@_pdf_pagesattr_gpush:
  {
    \exp_args:NNx \tex_global:D \@@_pdf_pagesattr:n
    {
     \prop_map_function:NN \g_@@_pdf_pagesattr_prop \driver_pdf_dict_item:nn
    }
  }


\bool_if:nT {\sys_if_engine_pdftex_p: && \sys_if_output_pdf_p: }
{
 %definition works also for luatex
 \cs_new_protected:Npx \@@_pdf_pagesattr:n #1
  {
    \exp_not:N \tex_global:D
    \cs_if_exist:NTF \tex_pdfpagesattr:D
      { \tex_pdfpagesattr:D }
      { \tex_pdfvariable:D pagesattr }
      {#1}
  }

 \cs_new_protected:Npn \driver_pdf_pagesattr_get:N #1
 {
   \tl_set:Nx #1 {\tex_the:D \tex_pdfpagesattr:D}
 }
 \AtEndDocument{\@@_pdf_pagesattr_gpush:}
}

\sys_if_engine_luatex:T
{
  \cs_new_protected:Npx \@@_pdf_pagesattr:n #1
  {
    \exp_not:N \tex_global:D
    \cs_if_exist:NTF \tex_pdfpagesattr:D
      { \tex_pdfpagesattr:D }
      { \tex_pdfvariable:D pagesattr }
      {#1}
  }
  \cs_new_protected:Npn \driver_pdf_pagesattr_get:N #1
  {
   \tl_set:Nx #1 {\tex_the:D \tex_pdfvariable:D pagesattr}
  }

  \AtEndDocument{\@@_pdf_pagesattr_gpush:}
}
%</package>
%    \end{macrocode}
% \subsubsection{driver / pdfpageattr}
% pdfpageattr is a single token register which is output at the shipout for every page.
% It is normally used only a few times in a document, so it is okay to update the
% register at every change. This also allows to test for unwanted changes.
% through uses of the primitives.
% Open is the question if one need more shipout hooks to set e.g. Rotate on specific
% pages.
% See also https://tex.stackexchange.com/questions/479812/extension-of-rotating-package-to-set-pdf-rotation
%
%    \begin{macrocode}
%<*package>
\prop_new:N \g_@@_pdf_pageattr_prop
% setter:
\cs_new_protected:Npn \driver_pdf_pageattr_gput:nn #1 #2
  {
   \prop_gput:Nnn \g_@@_pdf_pageattr_prop { #1 }{ #2}
   \@@_pdf_pageattr_gpush:
  }

% getter from the prop:
\cs_new_protected:Npn \driver_pdf_pageattr_get:nN #1 #2
  {
   \prop_get:NnN \g_@@_pdf_pageattr_prop { #1 } #2
  }

% remove:
\cs_new_protected:Npn \driver_pdf_pageattr_gremove:n #1
  {
   \prop_gremove:Nn \g_@@_pdf_pageattr_prop { #1 }
   \@@_pdf_pageattr_gpush:
  }

% push to the register
\cs_new_protected:Npn \@@_pdf_pageattr_gpush:
  {
    \exp_args:NNx \tex_global:D \@@_pdf_pageattr:n
    {
     \prop_map_function:NN \g_@@_pdf_pageattr_prop \driver_pdf_dict_item:nn
    }
  }


\bool_if:nT {\sys_if_engine_pdftex_p: && \sys_if_output_pdf_p: }
{
 %definition works also for luatex
 \cs_new_protected:Npx \@@_pdf_pageattr:n #1
  {
    \exp_not:N \tex_global:D
    \cs_if_exist:NTF \tex_pdfpageattr:D
      { \tex_pdfpageattr:D }
      { \tex_pdfvariable:D pageattr }
      {#1}
  }

 \cs_new_protected:Npn \driver_pdf_pageattr_get:N #1
 {
   \tl_set:Nx #1 {\tex_the:D \tex_pdfpageattr:D}
 }
}

\sys_if_engine_luatex:T
{
  \cs_new_protected:Npx \@@_pdf_pageattr:n #1
  {
    \exp_not:N \tex_global:D
    \cs_if_exist:NTF \tex_pdfpageattr:D
      { \tex_pdfpageattr:D }
      { \tex_pdfvariable:D pageattr }
      {#1}
  }
  \cs_new_protected:Npn \driver_pdf_pageattr_get:N #1
  {
   \tl_set:Nx #1 {\tex_the:D \tex_pdfvariable:D pageattr}
  }
}

%</package>
%    \end{macrocode}
% \subsection{pdfpageresources}
% We need code for ExtGState, ColorSpace, Pattern, Shading and Properties.
% All are dictionaries which can receive entries from more than one source.
% For at least ColorSpace (colorspace) and Properties (ocgx/tagpdf) there is also a need for page related
% resources, so we have to check on every page if a local resource list for this page
% exists. A global dictionary can be empty but as this is known only at the end of the document
% it would require a two-pass compilation to test it and the overhead is small so we ignore this.
% Example for ColorSpace:
%% Global resources are stored in g_@@_pdf_pageresources_ColorSpace_prop
%% An object {g_@@_pdf_pageresources_ColorSpace_obj} is reserved
%% At the end of the document the obj is written to the pdf with the content of the prop:
%% \driver_pdf_object_write:nn { g_@@_pdf_pageresources_ColorSpace_obj }
%%           {
%%             \prop_map_function:cN { g_@@_pdf_pageresources_#1_prop} \driver_pdf_dict_item:nn
%%           }
%% local resources for page N are stored in g_@@_pdf_pageresources_N_ColorSpace_prop
%% An object {g_@@_pdf_pageresources_N_ColorSpace_obj} is reserved
%% At the end of the document first the global then the local property is
%% added to a temporary prop:
%% \prop_set_eq:Nc \g_tmpa_prop { g_@@_pdf_pageresource_ColorSpace_prop}
%% \prop_map_inline:cn { g_@@_pdf_pageresource_N_ColorSpace_prop}
%% {\prop_gput:Nnn \g_tmpa_prop {#1}{#2}}
%%
%% then obj is written to the pdf with the combined content of the global and the
%% local prop:
%% \driver_pdf_object_write:nn { g_@@_pdf_pageresources_N_ColorSpace_obj }
%%           {
%%             \prop_map_function:cN \g_tmpa_prop \driver_pdf_dict_item:nn
%%           }
%% This means that local entries can overwrite global entries, it is up to the user to avoid this
%% with sensible names spaces.
%% At every shipout we check if g_@@_pdf_pageresource_N_ColorSpace_prop exists.
%% (That's probably more effective than trying to keep a list of pages with local settings.)
%% If yes we put "ColorSpace = objnum  of g_@@_pdf_pageresources_N_ColorSpace_obj" into
%% \g_@@_pdf_pageresources_prop and push this into pdfpageresources
%% If not we put "ColorSpace = objnum of g_@@_pdf_pageresources_ColorSpace_obj" into
%% \g_@@_pdf_pageresources_prop and push this into pdfpageresources


%    \begin{macrocode}
%<*package>
%message
\msg_new:nnnn{driver}{pageresources-changed}
 {
   The~content~of~pageresources~has~changed~on~the~absolute~page~#1.~
   Check~if~it~is~correct.
 }
 {
  This~is~probably~due~to~some~package~or~command~using~the~
  primitive~\token_to_str:N\pdfresources\c_space_tl or~an~equivalent~command~
  instead~of~the~expl3~interface.
 }
% lowlevel stuff
% to be able to test if someone tampered with the resources a command to retrieve the content:
\bool_if:nT {\sys_if_engine_pdftex_p: && \sys_if_output_pdf_p: }
{
  \cs_new_protected:Npn \driver_pdf_pageresources_gget:N #1
  {
   \tl_gset:Nx #1 {\tex_the:D \tex_pdfpageresources:D}
  }
}

\sys_if_engine_luatex:T
{
  \cs_new_protected:Npn \driver_pdf_pageresources_gget:N #1
  {
   \tl_gset:Nx #1 {\tex_the:D \tex_pdfvariable:D pageresources}
  }
}
\tl_new:N\g_@@_pdf_pageresources_tl
\tl_new:N\g_@@_pdf_pageresources_tmp_tl
\driver_pdf_pageresources_gget:N \g_@@_pdf_pageresources_tl
% the command to fill the register
\bool_if:nT { \sys_if_engine_pdftex_p: || \sys_if_engine_luatex_p: }
{
 \cs_new_protected:Npx \@@_pdf_pageresources:n #1
  {
    \exp_not:N \tex_global:D
    \cs_if_exist:NTF \tex_pdfpageresources:D
      { \tex_pdfpageresources:D }
      { \tex_pdfvariable:D pageresources }
      {#1}
  }
}

% push a prop to the register:
\cs_new_protected:Npn \@@_pdf_pageresources_gpush:N #1
  {
    \exp_args:NNx \tex_global:D \@@_pdf_pageresources:n
    {
     \prop_map_function:NN #1 \driver_pdf_dict_item:nn
    }
  }
%

% management code
% the list of standard resources which are handle with objects
 \clist_const:Nn \c_@@_pdf_pageresources_clist
  {
   ExtGState,
   ColorSpace,
   Pattern,
   Shading,
   Properties
  }

\prop_new:N \g_@@_pdf_pageresources_prop

% the global objects
 \clist_map_inline:Nn \c_@@_pdf_pageresources_clist
  {
   \prop_new:c {g_@@_pdf_pageresources_#1_prop}
   \driver_pdf_object_new:nn {g_@@_pdf_pageresources_#1_obj}{dict}
  }

% setter:  #1 is the name of the resource
\cs_new_protected:Npn \driver_pdf_pageresources_gput:nnn #1 #2 #3
  {
   \prop_gput:cnn { g_@@_pdf_pageresources_#1_prop} { #2 }{ #3 }
  }

% local resources
% a general bool if local resources as been used at all:
% saves use to map through the five resources if not

\bool_new:N \g_@@_pdf_pageresources_local_bool

% setter for page wise settings:
% #1 is the absolute page number, #2 the resource name, #3 the key, #4 the content
\cs_new_protected:Npn \driver_pdf_pageresources_gput:nnnn #1 #2 #3 #4
  {
   \prop_if_exist:cF { g_@@_pdf_pageresources_#1_#2_prop }
    {
     \prop_new:c { g_@@_pdf_pageresources_#1_#2_prop }
     \driver_pdf_object_new:nn {g_@@_pdf_pageresources_#1_#2_obj}{dict}
    }
   \prop_gput:cnn { g_@@_pdf_pageresources_#1_#2_prop} { #3 }{ #4 }
   \bool_gset_true:N \g_@@_pdf_pageresources_local_bool
  }
%
% The shipout code:
%

\cs_new_protected:Npn \@@_pdf_pageresources_shipout:n #1 %#1 the page number
 {
  \driver_pdf_pageresources_gget:N \g_@@_pdf_pageresources_tmp_tl
  \tl_if_eq:NNF \g_@@_pdf_pageresources_tmp_tl \g_@@_pdf_pageresources_tl
   {
    \msg_warning:nnn{driver}{pageresources-changed}{#1} %hm global/local ??
   }
  \clist_map_inline:Nn \c_@@_pdf_pageresources_clist
  {
   \prop_if_exist:cTF { g_@@_pdf_pageresources_#1_##1_prop }
   {
    \prop_gput:Nnx { \g_@@_pdf_pageresources_prop } {##1}
    {
      \driver_pdf_object_ref:n { g_@@_pdf_pageresources_#1_##1_obj }
    }
   }
   {
    \prop_gput:Nnx { \g_@@_pdf_pageresources_prop } {##1}
    {
      \driver_pdf_object_ref:n { g_@@_pdf_pageresources_##1_obj }
    }
   }
  }
  \@@_pdf_pageresources_gpush:N \g_@@_pdf_pageresources_prop
  \driver_pdf_pageresources_gget:N \g_@@_pdf_pageresources_tl
 }


\hook_post_push:nn {shipout}
{
 \shipout_page_add:nn { fg }
  {
   \exp_args:Nx  \@@_pdf_pageresources_shipout:n {\int_eval:n { \g_shipout_page_int }}
  }
}

% doesn't work: ocg layer of float gets lost ...
%\AtEndDocument % must perhaps be even later??
%
\RequirePackage{etoolbox}
\AfterEndDocument %works better
% Alternative?
%\RequirePackage{atenddvi}
%\AtEndDvi
 {
   % write the global objects:
  \clist_map_inline:Nn \c_@@_pdf_pageresources_clist
  {
   \exp_args:Nnx
     \driver_pdf_object_write:nn { g_@@_pdf_pageresources_#1_obj }
     {
      \prop_map_function:cN { g_@@_pdf_pageresources_#1_prop} \driver_pdf_dict_item:nn
     }
    }
   % write the local objects
  \bool_if:NT \g_@@_pdf_pageresources_local_bool
  {
   \clist_map_inline:Nn \c_@@_pdf_pageresources_clist
   {
    \int_step_inline:nn {\g_shipout_page_int} %<---- isn't the lastpage number with \AtEndDocument when floats are involved
    {%\tl_set:Nn\l_tmpa_tl{##1}\tl_show:N\l_tmpa_tl
     \prop_if_exist:cT { g_@@_pdf_pageresources_##1_#1_prop }
     {
      \prop_set_eq:Nc \g_tmpa_prop { g_@@_pdf_pageresources_#1_prop}
      \prop_map_inline:cn { g_@@_pdf_pageresources_##1_#1_prop}
      {
       \prop_gput:Nnn \g_tmpa_prop {####1}{####2}
      }
      \exp_args:Nnx
       \driver_pdf_object_write:nn { g_@@_pdf_pageresources_##1_#1_obj }
       {
        \prop_map_function:NN \g_tmpa_prop \driver_pdf_dict_item:nn
       }
     }
    }
   }
  }
 }


%</package>
%    \end{macrocode}
% \subsubsection{other stuff}
%    \begin{macrocode}
%<*package>
% version for link_last which gives an int. try to get rid of the necessity if possible
\bool_if:nT {\sys_if_engine_pdftex_p: && \sys_if_output_pdf_p: }
{
 %Push the pages attr prop to the token register:
 %should it be an internal command?

 \cs_new:Npx \driver_pdf_link_last_int:
  {
    \cs_if_exist:NTF \tex_pdffeedback:D
      { \tex_numexpr:D \exp_not:N \tex_pdffeedback:D lastlink \scan_stop: }
      { \exp_not:N \tex_pdflastlink:D }
  }


 \cs_new_protected:Nn \driver_pdf_docview:nn %#1 page number, #2 e.g. /FitH
 {
  \pdfcatalog {  } openaction~goto~page #1 {#2}
 }


% this needs refinement, probably is should create named objects and add
% them to the properties, see discussion
% https://chat.stackexchange.com/transcript/message/49970158#49970158
\cs_new_protected:Npx \driver_pdf_bdc:nn #1 #2
  {
    \cs_if_exist:NTF \tex_pdfextension:D
      { \tex_pdfextension:D literal~page~{#1~#2~BDC} }
      { \tex_pdfliteral:D~page~{#1~#2~BDC}  }
  }


\cs_new_protected:Npx \driver_pdf_emc:
  {
    \cs_if_exist:NTF \tex_pdfextension:D
      { \tex_pdfextension:D literal~page~{EMC} }
      { \tex_pdfliteral:D~page~{EMC}  }
  }

\input{l3pdfmode-pdf.def}
}

\sys_if_engine_luatex:T
{
 %allow version 2.0 in luatex. Needs sorting out later.
 \@namedef{Hy@pdfversion@2.0}{10}%
 \cs_new_protected:Nn \driver_pdf_docview:nn %#1 page number, #2 e.g. /FitH
 {
  \pdfextension catalog {  } openaction~goto~page #1 {#2}
 }
 % version for link_last which gives an int. try to get rid of the necessity if possible
 \cs_new:Npx \driver_pdf_link_last_int:
  {
    \cs_if_exist:NTF \tex_pdffeedback:D
      { \tex_numexpr:D \exp_not:N \tex_pdffeedback:D lastlink \scan_stop: }
      { \exp_not:N \tex_pdflastlink:D }
  }


\cs_new_protected:Npn \driver_pdf_catalog:n #1 %content, currently needed as hyperref has \Hy@PutCatalog
 {
  \pdfextension catalog {#1}
 }

\cs_new_protected:Npx \driver_pdf_bdc:nn #1 #2
  {
    \cs_if_exist:NTF \tex_pdfextension:D
      { \tex_pdfextension:D literal~page~{#1~#2~BDC} }
      { \tex_pdfliteral:D~page~{#1~#2~BDC}  }
  }


\cs_new_protected:Npx \driver_pdf_emc:
  {
    \cs_if_exist:NTF \tex_pdfextension:D
      { \tex_pdfextension:D literal~page~{EMC} }
      { \tex_pdfliteral:D~page~{EMC}  }
  }


\input{l3pdfmode-pdf.def}
}

\sys_if_engine_xetex:T
{
 %% need to be checked if resources are ok!!!!
 \cs_new_protected:Npn \driver_pdf_bmc:n #1
  {
    \special{pdf:code~#1~BMC}
    %\special{pdf:content~#1~BMC}%
  }

\cs_new_protected:Npn \driver_pdf_bdc:nn #1 #2
  {
    \special{pdf:code~#1~#2~BDC}
    %\special{pdf:content~#1~#2~BDC}%accsupp
  }

\cs_new_protected:Npn \driver_pdf_emc:
  {
    \special{pdf:code~EMC}
    %\special{pdf:content EMC}%accsupp
  }

 %% \cs_new_protected:Nn \driver_pdf_catalog:n ????
 \input{l3dvipdfmx-pdf.def}
}
%</package>
%    \end{macrocode}
% \section{Management code / pdf Module}
%<@@=pdf>
%% messages
%    \begin{macrocode}
%<*package>
\msg_new:nnn {pdf}{patches}{loading~patch~code}
\msg_new:nnnn { pdf }{ pagesattr-changed }
 {
   The~content~of~pagesattr ~has~changed.~
   Check~if~it~is~correct.
 }
 {
  This~is~probably~due~to~some~package~or~command~using~the~
  primitive~\token_to_str:N\pdfpagesattr\c_space_tl or~an~equivalent~command~
  instead~of~the~expl3~interface.
 }
\msg_new:nnnn { pdf }{ pageattr-changed }
 {
   The~content~of~pageattr ~has~changed.~
   Check~if~it~is~correct.
 }
 {
  This~is~probably~due~to~some~package~or~command~using~the~
  primitive~\token_to_str:N\pdfpageattr\c_space_tl or~an~equivalent~command~
  instead~of~the~expl3~interface.
 }
\msg_new:nnn
  {pdf}
  {setup-after-documentclass}
  { \token_to_str:N \documentsetup\c_space_tl should~be~used~only~before~\token_to_str:N\documentclass}
\msg_new:nnn { pdf } {object-compression-disabled}
             {object~compression~is~not~supported~in~pdf~version~#1}
\msg_new:nnn { pdf } {catalog-special}
             {values~to~the~catalog~entry~#1~should~be~added~with~\token_to_str:N\pdf_catalog_ #1_gput:nn}

%</package>
%    \end{macrocode}
% \subsection{the pdfcatalog}
% The catalog dictionary is filled by e.g. \cs{pdfcatalog}. Multiple appearances of
% \cs{pdfcatalog} are concatenated, so one could end with multiple entries.
% We is better to avoid this. We therefore setup a
% property which is filled and executed in one at a sensible (not yet found) place.
% \cs{pdfcatalog} has an option \texttt{openaction} to set the start view options.
% This is ignored here but set in a separate command (to be in sync with other drivers).
% The entries in the catalog have varying requirements regarding the
% pdf management. Some entries (like /Lang) are simple values where the last setting can
% simply win, other like /OutputIntents are dictionaries which can be filled from more than
% one source. /AF is even an array of dictionaries.
% There is probably no way to test what has already been added to the catalog,
% so doublettes can only be avoided with ``don't do it''.
% \subsubsection{Simple values}
% Simple values can be added with \cs{pdf_catalog_gput:nn}. This will add the value to
% a prop. The prop is then pushed to the catalog at the end of the document.
% Entries which can be added like this are
% \begin{description}
% \item[Version]  a version as name, e.g. \texttt{/1.7}
% \item[PageMode] (name: /UseNone, /UseOutlines, /UseThumbs, /FullScreen, /UseOC (PDF 1.5),
%   /UseAttachments (PDF 1.6)
% \item[MarkInfo] a dictionary with up to three entries, whose values are booleans (\texttt{true}
% or \texttt{false}). The default values of all always \texttt{false}. The dictionary should be set
% in one go by whatever package is handling tagging. Example\\
%  \verb+<</Marked true /UserProperties true /Suspects true>>+
%  \item[PageLayout] (name: one of /SinglePage, /OneColumn,
%  /TwoColumnLeft, /TwoColumnRight, /TwoPageLeft (PDF 1.5), /TwoPageRight (PDF 1.5)
%  \item[Outlines] a indirect reference (x 0 R) to an object.
%  \item[OpenAction] array (e.g. \verb+[page /Fit]+ or dictionary \verb+<</Type /Action /S /GoTo /D /somedest>>)
%  \item[URI] dict, e.g. \verb+<</S/URI /URI (someurl)>>+
%  \item[StructTreeRoot] a dict (normally an indirect reference to a dict),
%   the package doing the tagging should create this.
%  \item[Lang] (string, e.g. (de-DE))
%  \item[NeedsRendering] (boolean, pdf 1.7)
% \end{description}
%    \begin{macrocode}
%<*package>
\prop_new:N \g_@@_catalog_prop
\cs_new_protected:Npn \pdf_catalog_gput:nn #1 #2 %#1 name, #2 value
 {
  % Add later: test for the names that should be handled specially
  \prop_gput:Nnn \g_@@_catalog_prop {#1}{#2}
 }
%</package>
%    \end{macrocode}
%%% open: Collection, OCProperties, AcroForm, Metadata, ViewerPreferences, OutputIntents, PageLabels, Names,
%% Dests, AF (array of dictionaries, pdf 2.0, associated files, important for accessibility),
%% Threads, AA (dict, additional-actions),
%% open not so important:SpiderInfo (dict), PieceInfo (dict), (dict, pdf 1.5, permissions), Legal (dict, pdf 1.5)
%% Requirements (array, pdf 1.7), Extensions (dict, pdf 2.0), DSS (dict, pdf 2.0),
%% DPartRoot, (dict, pdf 2.0)
% \subsubsection{catalog, special cases}
%
% \subsubsection{catalog, output}
%    \begin{macrocode}
%<*package>
\AtBeginDocument %need to be decided ...
 {
  \prop_map_function:NN  \g_@@_catalog_prop \driver_pdf_catalog_gput:nn
 }
%</package>
%    \end{macrocode}
%
% \subsubsection{Doc View}
% This commands set Doc View options. This is rather crude /needs review. For now we
% assume that only the equivalent of \verb+openaction~goto~page\@pdfstartpage{\@pdfstartview}+ in
% hyperref is needed. The format of the second argument is quite unclear (slash, casing).
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdf_docview:nn #1 #2
 {
  \driver_pdf_docview:nn {#1}{#2}
 }
%</package>
%    \end{macrocode}
% \subsection{pdfpagesattr}
% A token register that is added to the root pages object when the pdf is finished.
% The following command copy more or less the driver commands but add a few tests
% and warning if other packages or users have used the primitive commands.
%    \begin{macrocode}
%<*package>
\tl_new:N \g_@@_pagesattr_tl

\cs_new_protected:Npn \pdf_pagesattr_gput:nn #1 #2
 {
  \driver_pdf_pagesattr_get:N \l_tmpa_tl
  \tl_if_eq:NNF \l_tmpa_tl \g_@@_pagesattr_tl
   {
    \msg_warning:nn { pdf }{ pagesattr-changed }
   }
  \driver_pdf_pagesattr_gput:nn { #1 } { #2 }
  \driver_pdf_pagesattr_get:N \l_tmpa_tl
  \tl_gset_eq:NN \g_@@_pagesattr_tl \l_tmpa_tl
 }

%</package>
%    \end{macrocode}
%
% \subsection{pdfpageattr}
%
% A token register that is added to the page object when the page is shipped out.
% The following command copy more or less the driver commands but add a few tests
% and warning if other packages or users have used the primitive commands.
%    \begin{macrocode}
%<*package>
\tl_new:N \g_@@_pageattr_tl

\cs_new_protected:Npn \pdf_pageattr_gput:nn #1 #2
 {
  \driver_pdf_pageattr_get:N \l_tmpa_tl
  \tl_if_eq:NNF \l_tmpa_tl \g_@@_pageattr_tl
   {
    \msg_warning:nn { pdf }{ pageattr-changed }
   }
  \driver_pdf_pageattr_gput:nn { #1 } { #2 }
  \driver_pdf_pageattr_get:N \l_tmpa_tl
  \tl_gset_eq:NN \g_@@_pageattr_tl \l_tmpa_tl
 }

\cs_new_protected:Npn \pdf_pageattr_gremove:n #1
 {
  \driver_pdf_pageattr_get:N \l_tmpa_tl
  \tl_if_eq:NNF \l_tmpa_tl \g_@@_pageattr_tl
   {
    \msg_warning:nn { pdf }{ pageattr-changed }
   }
  \driver_pdf_pageattr_gremove:n { #1 }
  \driver_pdf_pageattr_get:N \l_tmpa_tl
  \tl_gset_eq:NN \g_@@_pageattr_tl \l_tmpa_tl
 }
%</package>
%    \end{macrocode}
% \subsection{page resources}
% This mostly makes the driver commands available under the pdf module name.
%    \begin{macrocode}
%<*package>
\cs_set_eq:NN \pdf_pageresources_gput:nnn \driver_pdf_pageresources_gput:nnn
\cs_set_eq:NN \pdf_pageresources_gput:nnnn \driver_pdf_pageresources_gput:nnnn
\cs_generate_variant:Nn \pdf_pageresources_gput:nnnn {nnnx}
\cs_generate_variant:Nn \pdf_pageresources_gput:nnn {nnx}
%</package>
%    \end{macrocode}
% \subsection{The info dictionary}
% The info dictionary is filled by e.g. \cs{pdfinfo}. Multiple appearances of
% \cs{pdfinfo} are concatenated, so one could end with multiple /Title or /Author entries.
% It is then viewer dependant which one is showed, so it is better to avoid this.
% We therefore setup a property which is filled and written to the info
% directory in one go. According to hyperref a few odd drivers (hvtex, dvipsone, dviwind)
% don't support arbitrary keys, but this should be handle elsewhere. Most entries are
% strings so there is a special command for this, as entries with empty content
% should be ommited we add a test. The string command should perhaps escape the argument,
% but for now we are assuming that the argument is pdf safe.
% hyperref writes to the info dictionary at the shipout of the first page --
% probably to catch the  case that \cs{title} is issued after the begin of the document.
% We are outputting at begin document, so all info keys should be set before.
%    \begin{macrocode}
%<*package>
%% should this be driver commands??
\prop_new:N \g_@@_info_prop
\cs_new_protected:Npn \pdf_info_gput:nn #1 #2 %#1 key without /, #2 content
  {
   \prop_gput:Nnn\g_@@_info_prop { #1 } { #2 }
  }

\cs_generate_variant:Nn \pdf_info_gput:nn {no}

%  should #2 be inside a some escaping command?
%  hyperref passes them through
%  \HyXeTeX@CheckUnicode
%  \HyPsd@XeTeXBigCharstrue
%  \HyPsd@PrerenderUnicode{#1}%
%  \pdfstringdef\@pdftitle{#1}%
\cs_new_protected:Npn \pdf_info_string_gput:nn #1 #2 %#1 key without /, #2 content
  {
   \tl_if_empty:nF { #2 }
    {
     \prop_gput:Nnn\g_@@_info_prop { #1 } { (#2) }
    }
  }

\cs_generate_variant:Nn \pdf_info_string_gput:nn {no,oo,on}


\cs_new_protected:Npn \@@_info_push: %internal, to ensure that it is used only once
 {
  \prop_map_function:NN  \g_@@_info_prop \driver_pdf_info_gput:nn
  \prop_gclear:N \g_@@_info_prop
 }

\AtBeginDocument{\@@_info_push:}


%</package>
%    \end{macrocode}

% \subsection{pdfpagesattr}
%
%
% \subsection{Setting / comparing pdf versions}
% The code assumes that the versions are two integers separated by a period.
% The pdf version should be set rather early, before any object has been written.
% So we define a \cs{documentsetup} commmand which should go before \cs{documentclass}
% \begin{macro}{\documentsetup}
%    \begin{macrocode}
%<*package>

\NewDocumentCommand\documentsetup { m }
 {
  \cs_if_eq:NNTF \documentclass \@twoclasseserror
   {\msg_error:nn {pdf}{setup-after-documentclass }}
   {\keys_set:nn { pdf / setup } { #1 }}
 }

\keys_define:nn { pdf / setup }
 {
  pdfversion .code:n =
   {
    \pdf_version_gset:n { #1 }
    \@@_version_checks:
   }
 }
%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pdf_version_gset:n, \pdf_version_min_gset:n}
% \begin{macro}{\@@_version_gset:w}
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdf_version_gset:n #1
 {
  \@@_version_gset:w  #1 . . \q_stop
 }

\cs_new_protected:Npn \pdf_version_min_gset:n #1
 {
  \pdf_version_compare:NnT < {#1}
   {
    \@@_version_gset:w  #1 . . \q_stop
   }
 }

\cs_new_protected:Npn \@@_version_gset:w  #1 .#2 . #3\q_stop
 {
  \driver_pdf_version_major_gset:n {#1}
  \driver_pdf_version_minor_gset:n {#2}
 }

\cs_new_protected:Npn \@@_version_checks:
 {
  \pdf_version_compare:NnT < { 1.5 }
   {
    \driver_pdf_compress_objects:n {0}
    \msg_info:nnx {pdf}{object-compression-disabled}
    { \driver_pdf_version_major:.\driver_pdf_version_minor:}
   }
 }

%</package>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\pdf_version_compare:Nn}
%    \begin{macrocode}
%<*package>
\cs_new:cpn { @@_version_compare_=:w } #1 .#2 . #3\q_stop
 {
   \bool_if:nTF
    {
     \int_compare_p:n { \driver_pdf_version_major: = #1  }
     &&
     \int_compare_p:n { \driver_pdf_version_minor: = #2}
    }
    { \prg_return_true: }
    { \prg_return_false: }
 }

\cs_new:cpn { @@_version_compare_<:w } #1 .#2 . #3\q_stop
 {
   \bool_if:nTF
    {
     \int_compare_p:n  { \driver_pdf_version_major: < #1}
     ||
     (
      \int_compare_p:n { \driver_pdf_version_major: = #1 }
      &&
      \int_compare_p:n { \driver_pdf_version_minor: < #2 }
     )
    }
    { \prg_return_true: }
    { \prg_return_false: }
 }

\cs_new:cpn { @@_version_compare_>:w } #1 .#2 . #3\q_stop
 {
   \bool_if:nTF
    {
     \int_compare_p:n  { \driver_pdf_version_major: > #1}
     ||
     (
      \int_compare_p:n { \driver_pdf_version_major: = #1}
      &&
      \int_compare_p:n { \driver_pdf_version_minor: > #2 }
     )
    }
    { \prg_return_true: }
    { \prg_return_false: }
 }

\prg_new_conditional:Npnn \pdf_version_compare:Nn #1 #2
 {
  p,T,F,TF
 }
 {
  \use:c {@@_version_compare_#1:w} #2 . . \q_stop
 }
%</package>
%    \end{macrocode}
% \end{macro}
% \subsection{Higher-level link management}
% \subsubsection{Startlink}
% packages like ocgx2 and tagpdf wants to add code to links/annotation created by hyperref.
% So we need a generic command to start a pdflink which allows packages to add
% their code to the \texttt{attr} argument through hooks.
%    \begin{macrocode}
%<*package>
\cs_new:Nn \@@_get_key_value:nn { #1~#2~ } %name?????
%</package>
%    \end{macrocode}
% Attributes are stored in a property list. Packages can add attributes through
% dedicated command. We assume that there will be different link types
% (url, file, run, link, is a cite type needed??\ldots)
% and that they should have their own attribute list.
% Probably we will need some commands to fill more than one prop ...
%
%    \begin{macrocode}
%<*package>
\prop_new:N\l_@@_hook_link_begin_url_attr_prop  %\hyper@linkurl
\prop_new:N\l_@@_hook_link_begin_file_attr_prop %\hyper@linkfile
\prop_new:N\l_@@_hook_link_begin_run_attr_prop  %\@hyper@launch run
\prop_new:N\l_@@_hook_link_begin_link_attr_prop %\hyper@link, \find@pdflink
\prop_new:N\l_@@_hook_link_begin_menu_attr_prop %\Acrobatmenu
%</package>
%    \end{macrocode}
%
% High-level startlink commands that uses the stored attributes:
% At first one with the \texttt{user} argument:
% A link command that grabs the content as argument and inserts both
% startlink and endlink directly (driver command is already in l3driver).
%    \begin{macrocode}
%<*package>
\cs_new_protected:Nn \pdf_link_user:nnn %#1 type (url, file etc, #2 action spec, #3 link text
 {
   \seq_if_exist:cT { l_@@_hook_link_begin_#1_seq }
   {
    \seq_use:cn { l_@@_hook_link_begin_#1_seq }{}
   }
   \mode_leave_vertical:
   %\driver_pdf_link_user:nnn
   \driver_pdf_link_begin_user:nnw
    {
     \prop_if_exist:cT { l_@@_hook_link_begin_#1_attr_prop }
     {
      \prop_map_function:cN
       { l_@@_hook_link_begin_#1_attr_prop }
       \@@_get_key_value:nn
      }
    }
    {
      #2
    }
    #3
   \driver_pdf_link_end:
   \seq_if_exist:cT { l_@@_hook_link_end_#1_seq }
    {
     \seq_use:cn { l_@@_hook_link_end_#1_seq }{}
    }
 }
%</package>
%    \end{macrocode}
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdf_link_begin_user:nnw #1 #2 %#1 type, #2 action spec
{
 \seq_if_exist:cT { l_@@_hook_link_begin_#1_seq }
   {
    \seq_use:cn { l_@@_hook_link_begin_#1_seq }{}
   }
 \driver_pdf_link_begin_user:nnw
  {
   \prop_if_exist:cT { l_@@_hook_link_begin_#1_attr_prop }
    {
     \prop_map_function:cN
      { l_@@_hook_link_begin_#1_attr_prop }
      \@@_get_key_value:nn
     }
  }
  { #2 }
}

% At second one with the \texttt{goto name} argument:
\cs_new_protected:Npn \pdf_link_begin_goto:nnw #1 #2 %#1 type, #2 destination
{
 \seq_if_exist:cT { l_@@_hook_link_begin_#1_seq }
   {
    \seq_use:cn { l_@@_hook_link_begin_#1_seq }{}
   }
 \driver_pdf_link_begin_goto:nnw
  {
   \prop_if_exist:cT { l_@@_hook_link_begin_#1_attr_prop }
     {
      \prop_map_function:cN
      { l_@@_hook_link_begin_#1_attr_prop }
      \@@_get_key_value:nn
     }
  }
  { #2 }
}
%</package>
%    \end{macrocode}
% \subsection{Destinations}
% The command expects a lower case argument, it is up to the package to
% ensure this.
%
%    \begin{macrocode}
%<*package>
% perhaps some manipulation of the argument will be needed to map the current
% hyperref syntax
% unclear currently if is this is useful for anything.
\prop_new:N \l_@@_views_map_prop
\prop_put:Nnn \l_@@_views_map_prop {XYZ} { xyz }
\prop_put:Nnn \l_@@_views_map_prop {xyz} { xyz }
\prop_put:Nnn \l_@@_views_map_prop {Fit} { fit }
\prop_put:Nnn \l_@@_views_map_prop {fit} { fit }
\prop_put:Nnn \l_@@_views_map_prop {FitB} { fitb }
\prop_put:Nnn \l_@@_views_map_prop {fitb} { fitb }
\prop_put:Nnn \l_@@_views_map_prop {FitBH} { fitbh }
\prop_put:Nnn \l_@@_views_map_prop {fitbh} { fitbh }
\prop_put:Nnn \l_@@_views_map_prop {FitBv} { fitbv }
\prop_put:Nnn \l_@@_views_map_prop {fitbv} { fitbv }
\prop_put:Nnn \l_@@_views_map_prop {FitH} { fith }
\prop_put:Nnn \l_@@_views_map_prop {fith} { fith }
\prop_put:Nnn \l_@@_views_map_prop {FitV} { fitv }
\prop_put:Nnn \l_@@_views_map_prop {fitv} { fitv }

\cs_new_protected:Npn \pdf_destination:nn #1 #2
 {
  \prop_if_in:NnTF \l_@@_views_map_prop { #2 }
   {
    \driver_pdf_destination:nn { #1 } {  #2  }
   }
   {
    % should we assume that it is a zoom value then??
    % or should there be a third argument for this case and for other coordinates?
   }
 }
\cs_generate_variant:Nn\pdf_destination:nn {no,nf}
%</package>
%    \end{macrocode}
% \subsubsection{Endlink}
% tagpdf needs to execute code at the end of the link to store the object reference etc.
% So we need a hook. For now the hook is a seq: This will perhaps allows a system to
% add and remove hooks by index. The hook depends on the type.
%    \begin{macrocode}
%<*package>
\seq_new:N \l_@@_hook_link_end_url_seq
\seq_new:N \l_@@_hook_link_end_run_seq
\seq_new:N \l_@@_hook_link_end_file_seq
\seq_new:N \l_@@_hook_link_end_link_seq
\seq_new:N \l_@@_hook_link_end_menu_seq

\cs_new_protected:Nn \pdf_link_end:n %#1 type, e.g. url
 {
  \driver_pdf_link_end:
  \seq_if_exist:cT {l_@@_hook_link_end_#1_seq}
   {
    \seq_use:cn { l_@@_hook_link_end_#1_seq }{}
   }
 }

%</package>
%    \end{macrocode}
% \subsection{Before the links}
% Both hyperref and tagpdf wants to insert code before the \cs{pdfstartlink} so lets
% setup hooks for this too:
%    \begin{macrocode}
%<*package>
\seq_new:N \l_@@_hook_link_begin_url_seq
\seq_new:N \l_@@_hook_link_begin_run_seq
\seq_new:N \l_@@_hook_link_begin_file_seq
\seq_new:N \l_@@_hook_link_begin_link_seq
%</package>
%    \end{macrocode}
%
% \section{Hook management}
% hooks are commands that allow users and other packages to inject code.
%
% \subsection{hooks with token lists}
%  Hook code can be stored in a simple token list variable (tl). An example is e.g.
% \cs{@begindocumenthook}. In this case possible operations are
% \begin{itemize}
% \item \emph{appending} to the hook
% \item \emph{prepending} to the hook
% \item and perhaps some more or less complicated \emph{patching} to remove/replace parts
% \end{itemize}
%
% Such a hook can be \emph{used} by using the variable.
%
% \subsection{hooks with sequences}
% Hook code can also be stored in a sequence (seq). In this data structure every user adding
% something to the hook can get an index back.
% In this case possible operations are
% \begin{itemize}
% \item \emph{appending} to the hook (\cs{seq_put_right}),
% \item \emph{prepending} to the hook (need to keep track of the \enquote{zero pointer} if the user
% should get an index back)
% \item \emph{changing} (e.g emptying) a hook item through the index. But as this
% involves mapping through the sequence to find the right item, it is perhaps too slow.
% \end{itemize}
%
% Such a hook can be \emph{used} by mapping over the sequence. It is possible to filter or
% exclude items. It is also possible to insert code while processing the individual items.
% It is not quite clear if the additional features of such sequence hooks are really needed
% but the overhead is not so large, so it should be ok to use is. Probably if the type
% is used at all, it would be sensible to drop the tl-type so that one doesn't have to define
% \cs{hook_put_right_tl:nnn} and \cs{hook_put_right_seq:nnn} functions.
%
% \subsection{hooks with properties}
% Hook code can also be stored in a property (prop). Here possible operations are
% \begin{itemize}
% \item \emph{adding} a new key and its value. It is possible to write the interface so
% that only a specific set of keys are allowed.
% \item \emph{changing} the value of an existing key, either by overwriting the
% current value or by appending more code to the value -- the second could e.g. be used
% to extend the /ExtGState or /ColorSpace values.
% \item \emph{removing} a key
% \end{itemize}
%
% A hook stored like this can be used by mapping over the properties, but selective
% use and filtering is possible too.
%
% Such a hook is useful if -- like in the case of dictionary values in a pdf -- various
% packages need to be able to manipulate the same key.
%
% \subsection{Naming hooks and access functions}
% hooks are module specific. So set functions should probably do be something like
%
% \cs{hook_put_right:nnn}\verb+{<module>}{<hook-name>}{value}+ (seq- or tl-type)
% or in the case of  properties
% \cs{hook_put:nnnn} {<module>}{<hook-name>}{<key>}{<value>}
%
% hooks should be manipulated only through such access functions. So their
% name should be an internal command of the module. E.g.
% \cs{l__<module>_hook_<hook-name>_prop}
%
%    \begin{macrocode}
%<*package>
\cs_new:Nn \hook_put_right:nnn
 {
  \seq_put_right:cn { l__#1_hook_#2_seq } { #3 }
 }

\cs_new:Nn \hook_put_left:nnn
 {
  \seq_put_left:cn { l__#1_hook_#2_seq } { #3 }
 }

\cs_new:Nn \hook_put:nnnn
 {
  \prop_put:cnn { l__#1_hook_#2_prop } { #3 }{ #4 }
 }

\cs_new:Nn \hook_gput:nnnn
 {
  \prop_gput:cnn { g__#1_hook_#2_prop } { #3 }{ #4 }
 }

\cs_new:Nn \hook_remove:nnn
 {
  \prop_remove:cn { l__#1_hook_#2_prop } { #3 }
 }

\cs_new:Nn \hook_gremove:nnn
 {
  \prop_gremove:cn { g__#1_hook_#2_prop } { #3 }
 }
%</package>
%    \end{macrocode}
% \subsection{Passing external information to hooks}
% hooks sometimes wants to know something about the arguments of the surrounding command.
% E.g. a hook in \cs{@startsection} perhaps needs the current section level or
% if it is a run-in or display sectioning. Using \#-arguments in the hook is possible
% but rather fragile. It is probably better if the surrounding command offers a
% documentated interface through e.g. tl-variables. It should be also clear which
% variables are read-only and which can be changed by the hook code.
%
%
% \section{Patches}
% This code is temporary! It tries to patch commands of other packages which
% fills pdfresources too, to remove clashes and test if everything works as expected.
% This code should disappear when packages adapt to the central interfaces.
% \subsection{pgf}
% For the pageresources we need to avoid that pgf interferes in ExtGState,
% ColorSpace and Pattern (Shadings are added to the xform resources and so probably
% unproblematic for now).
%    \begin{macrocode}
%<*package>
\bool_if:nT { !\g__pdf_patches_bool || \sys_if_output_dvi_p:  }
 {
  \file_input_stop:
 }
\msg_info:nn{pdf}{patches}
\RequirePackage{etoolbox}
% code to add to the resources existing stuff in the format "/name value":
\cs_new:Npn \__pdf_split_dict_entry_aux:NNw #1 #2 /#3~#4\q_stop
 {
  \tl_set:Nn #1 {#3}
  \tl_set:Nn #2 {#4}
 }
\tl_new:N \l__pdf_name_tmp_tl
\tl_new:N \l__pdf_value_tmp_tl
\cs_generate_variant:Nn \pdf_pageresources_gput:nnnn {nnoo}
\cs_new_protected:Npn \pdf_pageresources_split_gput:nnn  #1 #2 #3 %#1 page, #2 resources
 {
   \__pdf_split_dict_entry_aux:NNw \l__pdf_name_tmp_tl \l__pdf_value_tmp_tl #3 \q_stop
   \pdf_pageresources_gput:nnoo {#1}{#2}{\l__pdf_name_tmp_tl}{\l__pdf_value_tmp_tl}
 }

\cs_generate_variant:Nn \pdf_pageresources_gput:nnn {noo}
\cs_new_protected:Npn \pdf_pageresources_split_gput:nn  #1 #2  %#1  resources
 {
   \__pdf_split_dict_entry_aux:NNw \l__pdf_name_tmp_tl \l__pdf_value_tmp_tl #2 \q_stop
   \pdf_pageresources_gput:noo {#1}{#2}{\l__pdf_name_tmp_tl}{\l__pdf_value_tmp_tl}
 }


  %Trying to patch pgf ..
\AtBeginDocument
 {
  % extgstate
  \cs_new:Npn \__pdf_patch_pgfextgs:w  #1/#2<<#3>>#4\q_stop
   {
    \driver_pdf_pageresources_gput:nnn {ExtGState}{#2}{<<#3>>}
   }

  \def\pgf@sys@addpdfresource@extgs@plain#1
   {
    \exp_after:wN %for transparent which passes a command
    \__pdf_patch_pgfextgs:w #1\q_stop
   }

  % patterns
  \cs_new:Npn \__pdf_patch_pgfpatterns:w  #1/#2\space#3\q_stop
   {
    \exp_args:Nnnx \driver_pdf_pageresources_gput:nnn {Pattern}{#2}{#3}
   }
  \def\pgf@sys@addpdfresource@patterns@plain#1
   {
    \__pdf_patch_pgfpatterns:w #1\q_stop
   }

  %colorspace is already set when tikz is loaded:
  \cs_new:Npn \__pdf_patch_pgfcolorspace:w  #1/#2[#3]#4\q_stop
   {
    \driver_pdf_pageresources_gput:nnn {ColorSpace}{#2}{[#3]}
   }
  \tl_if_exist:NT \pgf@sys@pgf@resource@list@colorspaces
  {
   \exp_last_unbraced:NV
    \__pdf_patch_pgfcolorspace:w  \pgf@sys@pgf@resource@list@colorspaces\q_stop
   \pgfutil@everybye{}
  }
 }
% transparent, we assume that pdfresource is loaded first.

\AtEndPreamble
 {
  \def\TRP@addresource
   {
    \driver_pdf_pageresources_gput:nnn{ExtGState}{TRP1}{<</ca~1/CA~1>>}
   }
  \def\transparent@use#1
  {
   \tl_if_exist:cF{TRP#1}
    {
     \driver_pdf_pageresources_gput:nnn{ExtGState}{TRP#1}{<</ca~#1/CA~#1>>}
     \tl_const:cn{TRP#1}{/TRP#1~gs}
    }
  }
 }

%colorspace.sty
% rather difficult as no real places to inject patches
% at first a try to avoid that it's ExtGState is missing:
% it can not be avoided to recreate the objects (and so to get duplicates)
% as colorspace uses temporary macros whose contents is lost.
\AtEndPreamble
{
 \tl_if_exist:NT \spc@op
 {
  \driver_pdf_object_new:nn  {__spc_extgstate_op_false}{dict}
  \driver_pdf_object_write:nn
   {__spc_extgstate_op_false}
   {/Type /ExtGState~/op~false~/OP~false}
  \pdf_pageresources_gput:nnn
   {ExtGState}
   {SPCko}
   {\driver_pdf_object_ref:n {__spc_extgstate_op_false}}
  \driver_pdf_object_new:nn  {__spc_extgstate_op_true0}{dict}
  \driver_pdf_object_write:nn{__spc_extgstate_op_true0}
   {/Type /ExtGState~/op~true~/OP~true~/OPM~0}%
  \pdf_pageresources_gput:nnn
   {ExtGState}
   {SPCmz}
   {\driver_pdf_object_ref:n {__spc_extgstate_op_true0}}
  \driver_pdf_object_new:nn  {__spc_extgstate_op_true1}{dict}
  \driver_pdf_object_write:nn{__spc_extgstate_op_true1}
   {/Type /ExtGState~/op~true~/OP~true~/OPM~1}%
  \pdf_pageresources_gput:nnn
   {ExtGState}
   {SPCop}
   {\driver_pdf_object_ref:n {__spc_extgstate_op_true1}}
 \def\spc@Pageresources#1{}
 }
}

%</package>
%    \end{macrocode}
% \PrintIndex
