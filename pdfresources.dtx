% \iffalse meta-comment
%
%% File: pdfresources.dtx
%
% Copyright (C) 2019-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "pdfresources bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/pdfresources
%
% for those people who are interested.
%
%<*driver>
\documentclass{l3doc}
\usepackage{tabularx,array,booktabs}
\newcommand\potentialclash{\noindent\llap{\dbend\ }}
\raggedbottom
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%    \begin{macrocode}
%<@@=pdf>
%<*package>
\ExplSyntaxOn
\sys_load_backend:n {}
\ExplSyntaxOff
\RequirePackage{xparse,l3pdf}
%\RequirePackage{tmpl3shipout}
\RequirePackage{lthooks,zref-lastpage,bitset}
\ProvidesExplPackage {pdfresources} {2020-04-08} {0.5}
  {experimental pdf-resource management}
\DeclareOption { debug }
  {
    %\msg_redirect_module:nnn { pdf } { warning }{ error }
    \msg_redirect_module:nnn { pdf } { none } { warning }
  }
\bool_new:N\g_@@_patches_bool
\DeclareOption { patches }{\bool_gset_true:N\g_@@_patches_bool}
\ProcessOptions\relax
%    \end{macrocode}
%
% \title{\pkg{pdfresources}}
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released 2020-XX-XX}
%
% \maketitle
% \section{Introduction}
% When creating a pdf a number of objects, dictionaries and entries to
% dictionaries must be created. The \LaTeX{} format currently contains no
% support for theses tasks. It either relies on the binaries to do the job,
% or on external packages using the primitives of the binaries. These
% approach is problematic for two reasons: packages trying to set the same resources
% can clash, and as the primitives differ between the various binaries and backend with
% which \LaTeX{} is used all packages have to write and maintain \enquote{driver} files
% for the various backends.
%
% The project here tries to resolve this situation by providing interfaces to
% the various resources and objects in a backend independent way.
%
% The supported backends are pdflatex, lualatex, (x)dvipdfmx (latex, xelatex)
% and dvips with ps2pdf (not completely yet). dvips with distiller could work too
% but is untested.
%
% That the interfaces are backend independent doesn't mean that the results and even
% the compilation behavior is identical. The backends are too different to allow
% this. Some backends expand arguments e.g. in a \cs{special} while other don't.
% Some backends can insert a resource at the first compilation, while another uses
% the aux-file and a label and so needs at least two.
%
% \section{messages}
%    \begin{macrocode}
\msg_new:nnn  { pdf } { patches }
              { loading~patch~code }
\msg_new:nnn  { pdf } { pgf-too-late }
              { pgf~is~already~loaded.~Patching~not~possible.}
\msg_new:nnn  { pdf } { empty-value }
              { The~value~for~#1~is~empty~and~will~be~ignored }
\msg_new:nnn  { pdf } { wrong-path }
              { This~resource~path~#1~doesn't~exist~--~perhaps~a~typo? }

\msg_new:nnnn { pdf } { pagesattr-changed }
              {
                The~content~of~pagesattr ~has~changed.~
                Check~if~it~is~correct.
              }
              {
                This~is~probably~due~to~some~package~or~command~using~the~
                primitive~\token_to_str:N\pdfpagesattr\c_space_tl
                or~an~equivalent~command~instead~of~the~expl3~interface.
              }
\msg_new:nnnn { pdf }{ pageattr-changed }
              {
                The~content~of~pageattr ~has~changed.~
                Check~if~it~is~correct.
              }
              {
                This~is~probably~due~to~some~package~or~command~using~the~
                primitive~\token_to_str:N\pdfpageattr\c_space_tl
                or~an~equivalent~command~instead~of~the~expl3~interface.
              }
\msg_new:nnn  { pdf } { setup-after-documentclass }
              { \token_to_str:N \DeclareDocumentMetaData \c_space_tl
                should~be~used~only~before~\token_to_str:N\documentclass
              }
\msg_new:nnn  { pdf } { object-compression-disabled }
              { object~compression~is~not~supported~in~pdf~version~#1 }
\msg_new:nnn  { pdf } { catalog-special }
              {
                values~to~the~catalog~entry~#1~should~be~added~with~
                \token_to_str:N\pdfdict_gput:nnn
              }
\msg_new:nnn  { pdf } { catalog-unknown }
              {
                inserting~unknown~/#1~into~the~catalog
              }
% pdfdict module
\msg_new:nnn  { pdfdict } { show-dict }
  {
    The~\tl_if_empty:cTF {c_@@_dict_/#1_g_tl}{local}{global}~dictionary~'#1'~
    \tl_if_empty:nTF {#2}
      { is~empty \\>~ . }
      { contains~the~pairs~(without~outer~braces): #2 . }
  }
\msg_new:nnn  { pdfdict } { unknown-dict }
  {
    The~dictionary~'#1'~is~not~declared.
  }
\msg_new:nnn  { pdfdict } { wrong-or-unknown-dict }
  {
    The~dictionary~'#1'~is~either~not~a~#2~dictionary\\
    or~is~not~declared.
  }
\msg_new:nnn  { pdfdict } { dict-already-defined  }
  {
    The~dictionary~'#1'~is~already~defined.
  }
\msg_new:nnn  { pdfdict } { empty-value }
              { The~value~for~#1~is~empty~and~will~be~ignored }

\msg_new:nnn  { pdfdict } { no-removal }
              { It~is~not~possible~to~remove~values~from~dictionary~'#1'.}

\msg_new:nnn  { pdfdict } { no-show }
              { It~is~not~possible~to~show~the~dictionary~'#1'.}

%    \end{macrocode}
% \section{Preparation/helper Code}
%^^A still needed:
%^^A \pdf@strcmp??
%^^A \pdf@escapestring?? \pdfescapestring
% \begin{variable}{\l_@@_tmpa_prop, \l_@@_tmpa_tl }
% Some scratch variables
%    \begin{macrocode}
\prop_new:N \l_@@_tmpa_prop
\prop_new:N \g_@@_tmpa_prop
\tl_new:N   \l_@@_tmpa_tl
\box_new:N  \l_@@_tmpa_box
\box_new:N  \l_@@_tmpb_box
%    \end{macrocode}
% \end{variable}
%</package>
% \subsection{some zref code, needs to be replaced later}
%<*drivers>
% \begin{variable}
%  {\g_@@_backend_resourceid_int, \g_@@_backend_name_int, \g_@@_backend_page_int}
%  a counter to create labels for the resources, a counter
%  to number properties in bdc marks, a counter for the \cs{pdfpageref} implementation.
%    \begin{macrocode}
\int_new:N \g_@@_backend_resourceid_int
\int_new:N \g_@@_backend_name_int
\int_new:N \g_@@_backend_page_int
%    \end{macrocode}
% \end{variable}
%</drivers>
%<*package>
% a reference for the absolute page counter
%    \begin{macrocode}
\zref@newlist  { l3pdf }
\zref@newprop* { pdf@abspage } [0] { \int_use:N \g_shipout_readonly_int }
\zref@addprop  { l3pdf } { pdf@abspage }
%    \end{macrocode}
%</package>
% \subsection{luacode}
%<*pdfmode>
% Load the lua code.
%    \begin{macrocode}
\sys_if_engine_luatex:T
  {
    \directlua { require("pdfresources.lua") }
  }
%    \end{macrocode}
%</pdfmode>
% \subsection{shipout and end of run code}
% \begin{NOTE}{UF}
% the \enquote{end-of-run} command is temporary until the shipout/atendshipout hooks
% are ready. For now -- until a expl3/kernel interface exists -- code is
% added with atbegshi. The code depends currently also on zref.
% For dvips/dvipdfmx \cs{AtEndDvi} should be checked.
% The naming is not really correct, so we keep this in one place
% and reflect uses uppercase until better names are found.
% \end{NOTE}
%
% \begin{macro}{\@@_BACKEND_end_run:, \@@_BACKEND_end_run_gput:n}
% \cs{@@_BACKEND_end_run:} runs the code stored in
% \cs{g_@@_BACKEND_end_run_code_tl} at the end of the compilation.
% \cs{@@_BACKEND_end_run_gput:n} adds its argument to
% \cs{g_@@_BACKEND_end_run_code_tl}
% With pdflatex/lualatex |AtEndDocument{\clearpage|\meta{code}|}| is used,
% so the code is executed at the first compilation.
% To avoid that specials are lost the code is added to
% \cs{@@_BACKEND_lastpage_shipout_code_tl} with dvips/dvipdfmx and so needs a
% second compilation.
% The code shouldn't contain typesetting content and shouldn't rely on some
% specific grouping.
%<*drivers>
%    \begin{macrocode}
%  for all:
\tl_new:N\g_@@_BACKEND_end_run_tl
\tl_new:N\g_@@_BACKEND_lastpage_shipout_tl
\tl_new:N\g_@@_BACKEND_thispage_shipout_tl

\cs_new_protected:Npn \@@_BACKEND_end_run_gput:n #1
  {
    \tl_gput_right:Nn \g_@@_BACKEND_end_run_tl { #1 }
  }
%</drivers>
%<*pdfmode>
% pdftex,luatex
\cs_new_protected:Npn \@@_BACKEND_end_run:
  {
    \hook_gput_code:nnn {enddocument/afterlastpage}
      {pdf}
      {
        \g_@@_BACKEND_end_run_tl
      }
  }
%</pdfmode>
%<*xdvipdfmx>
%xetex check ...
\cs_new_protected:Npn \@@_BACKEND_end_run:
 {
   \tl_gput_right:Nn \g_@@_BACKEND_lastpage_shipout_tl
     {
       \g_@@_BACKEND_end_run_tl
     }
 }
%</xdvipdfmx>
%<*dvips>
%dvips check ...
\cs_new_protected:Npn \@@_BACKEND_end_run:
 {
   \tl_gput_right:Nn \g_@@_BACKEND_lastpage_shipout_tl
     {
       \g_@@_BACKEND_end_run_tl
     }
 }
%</dvips>
%<*drivers>
\@@_BACKEND_end_run:
%</drivers>
%    \end{macrocode}
% \end{macro}
%<*drivers>
% \begin{macro}{
%    \@@_BACKEND_shipout_code:,
%    \@@_BACKEND_lastpage_shipout_gput:n,
%    \@@_BACKEND_thispage_shipout_gput:n }
%  \cs{@@_BACKEND_shipout_code:} contains the code that is executed at every shipout.
%  It use two hooks: \cs{g_@@_BACKEND_thispage_shipout_tl} and
%  \cs{g_@@_BACKEND_lastpage_shipout_tl}
%  The lastpage code relies on a label and so needs at least two compilations.
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_BACKEND_lastpage_shipout_gput:n #1
  {
    \tl_gput_right:Nn \g_@@_BACKEND_lastpage_shipout_tl { #1 }
  }

\cs_new_protected:Npn \@@_BACKEND_thispage_shipout_gput:n #1
  {
    \tl_gput_right:Nn \g_@@_BACKEND_thispage_shipout_tl { #1 }
  }

%box needed??
\hook_gput_code:nnn{shipout/background}{pdf}{\@@_BACKEND_shipout_code:}
%\AtBeginShipout
%  {
%    \AtBeginShipoutAddToBox
%      {
%        \@@_BACKEND_shipout_code:
%      }
%  }

\cs_new_protected:Npn \@@_BACKEND_shipout_code:
  {
    \g_@@_BACKEND_thispage_shipout_tl
    \int_compare:nNnT
      { \g_shipout_readonly_int }
      =
      { \zref@extractdefault{LastPage}{abspage}{0} }
      {
        \g_@@_BACKEND_lastpage_shipout_tl
      }
  }

\@@_BACKEND_thispage_shipout_gput:n
  {
    \exp_args:NV \@@_backend_ThisPage_gpush:n           { \g_shipout_readonly_int }
    \exp_args:NV \@@_backend_PageResources_gpush:n { \g_shipout_readonly_int }
  }

%!!!!! check if pdftex/luatex can run some of them in the immediate end-of-run
\@@_BACKEND_lastpage_shipout_gput:n
  {
   % \@@_dict_Pages_gpush:            %pagesattr
   % \@@_dict_Info_gpush:             %pdfinfo
    \@@_PageResources_gpush:   %ExtGState etc
  }

\@@_BACKEND_end_run_gput:n
  {
    \@@_dict_Pages_gpush:            %pagesattr
    \@@_dict_Info_gpush:             %pdfinfo
    \@@_dict_Catalog_gpush:
   % \@@_PageResources_gpush:   %ExtGState etc
  }
%    \end{macrocode}
% \end{macro}
%</drivers>
%<*package>
% \subsection{references to page objects}
% \begin{NOTE}{UF}
% a reference to the current page would be useful, but difficult to
% abstract in a sensible way. With xetex it is simply @thispage, but the other
% engines are unclear.
% \end{NOTE}
% \begin{function}[EXP, added = 2019-08-18]
%   {\pdf_pageobject_ref:n}
%   \begin{syntax}
%     \cs{pdf_pageobject_ref:n} \Arg{number}
%   \end{syntax}
%   This returns the object reference of a page object. The \Arg{number} is
%   the absolute page number. The count starts with one.
% \end{function}
% \begin{macro}{ \pdf_pageobject_ref:n }
%    \begin{macrocode}
\cs_new:Npn \pdf_pageobject_ref:n #1 { \@@_backend_pageobject_ref:n { #1 }}
%    \end{macrocode}
% \end{macro}
%</package>
%<*package>
% \subsection{Internal dictionary Code}
%  Many code parts are quite similar: property lists for dictionaries are filled and output.
%  So we define some generic commands to ensure systematic
%  internal names. The names are based on paths separated by slashed.
%  The first slash is not used in the names.
%
%  Currently the following names are used: ^^A!!!!! check, compare with g_@@_dict_gnames_seq
%  \begin{verbatim}
%  /Info                      %   -> pdfdict (\pdfinfo)
%  /Catalog                   %   -> pdfdict (\pdfcatalog)
%  /Catalog/AA                %
%  /Catalog/AcroForm
%  /Catalog/OCProperties
%  /Catalog/OutputIntents
%  /Catalog/AcroForm/DR
%  /Catalog/AcroForm/DR/Font
%  /Catalog/MarkInfo
%  /Catalog/ViewerPreferences
%  /Pages           %w,  \pagesattr ->pdfdict
%  /Page
%  /ThisPage
%  /backend_PageN/Resources/Properties %
%  /Page/Resources/ExtGState
%  /Page/Resources/ColorSpace
%  /Page/Resources/Pattern
%  /Page/Resources/Shading
%  /Page/Resources/Properties
%  /xform/Resources/Properties
%  \end{verbatim}
% \begin{macro}{\@@_dict_item:nn,\@@_dict_objref_item:nn}
% Commands to output dict entries: The arguments are \meta{name}\meta{value} and
% \meta{name}\meta{object name}, \meta{name} should be a valid pdf name without
% the slash.
% The commands don't check if the arguments are empty or valid. This should be done
% in the pdf layer at the input.
%    \begin{macrocode}
\cs_new:Npn \@@_dict_item:nn #1 #2 { /#1~#2~ } %name, value
\cs_generate_variant:Nn \@@_dict_item:nn {ne}

\cs_new:Npn \@@_dict_objref_item:nn #1 #2      %name, object name
  {
    /#1~\@@_backend_object_ref:n { #2 }
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%    \@@_dict_get_g:n,
%    \@@_dict_gname:n,
%    \@@_dict_name:n,
%    \@@_dict_gnew:n,
%    \@@_dict_new:n,
%    \g_@@_dict_gnames_seq,
%    \g_@@_dict_names_seq
%   }
%   \cs{@@_dict_get_g:n} gives back a \enquote{g} if the dictionary is global.
%    \begin{macrocode}
\seq_new:N \g_@@_dict_gnames_seq
\seq_new:N \g_@@_dict_names_seq

\tl_const:Nn \c_@@_dict_globalprefix_tl {g}
\tl_const:Nn \c_@@_dict_localprefix_tl  {}

% to retried global status from pathes
\cs_new:Npn \@@_dict_get_g:n #1 % path name without the leading /
  {
   \tl_if_exist:cT {c_@@_dict_/#1_g_tl}
     {
      \tl_use:c {c_@@_dict_/#1_g_tl}
     }
  }

%global
\cs_new:Npn \@@_dict_gname:n #1 % path name without the leading /
  {
    g_@@_dict_/#1_prop
  }

%local
\cs_new:Npn \@@_dict_name:n #1 % path name without the leading /
  {
    l_@@_dict_/#1_prop
  }


%  hm, a bit unclear, can this work? How is expansion?
%  it falls back to prop_name if the path doesn't exist.
%  Can this lead to confusion?
%
\cs_new:Npn \@@_dict_Xname:n #1 % path name without the leading /
  {
    \use:c { @@_dict_\@@_dict_get_g:n{#1}name:n } { #1 }
  }

%global
\cs_new_protected:Npn \@@_dict_gnew:n #1
  {
    \@@_dict_if_exist:nTF { #1 }
      {
        \msg_error:nnx
          { pdfdict }
          { dict-already-defined }
          { #1}
       }
      {
        \tl_const:cn { c_@@_dict_/#1_g_tl } { g }
        \prop_new:c  { \@@_dict_gname:n { #1 } }
        \seq_gput_right:Nn \g_@@_dict_gnames_seq { #1 }
      }
  }

%local
\cs_new_protected:Npn \@@_dict_new:n #1
  {
    \@@_dict_if_exist:nTF { #1 }
      {
        \msg_error:nnx
          { pdfdict }
          { dict-already-defined }
          { #1}
       }
      {
        \tl_const:cn { c_@@_dict_/#1_g_tl } {  }
        \prop_new:c  { \@@_dict_name:n { #1 } }
        \seq_gput_right:Nn \g_@@_dict_names_seq { #1 }
      }
  }

% test existence
\prg_new_conditional:Npnn \@@_dict_if_exist:n #1 { p , T , F , TF }
  {
    \tl_if_exist:cTF
      { c_@@_dict_/#1_g_tl }
      { \prg_return_true: }
      { \prg_return_false: }
  }
% test if global, non existing dicts return false
\prg_new_conditional:Npnn \@@_dict_if_global:n #1 { p , T , F , TF }
   {
     \tl_if_eq:NcTF
        \c_@@_dict_globalprefix_tl
        { c_@@_dict_/#1_g_tl }
        { \prg_return_true: }
        { \prg_return_false: }
   }
% test if local, non existing dicts return false
\prg_new_conditional:Npnn \@@_dict_if_local:n #1 { p , T , F , TF }
   {
     \tl_if_eq:NcTF
        \c_@@_dict_localprefix_tl
        { c_@@_dict_/#1_g_tl }
        { \prg_return_true: }
        { \prg_return_false: }
   }

\prg_new_conditional:Npnn \@@_dict_if_empty:n #1 { p , T , F , TF }
  {
    \prop_if_empty:cTF
      { \@@_dict_Xname:n { #1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{
%                \@@_dict_clear,
%                \@@_dict_reset,
%                \@@_dict_handler_put:nnn,
%                \@@_dict_get:nnN,
%                \@@_dict_remove:nn,
%                \@@_dict_show:n
%                }
%  \cs{@@_dict_handler_put:nnn} is the main command to fill the dictionaries.
%  In simple cases it directly fill the property list, but if a handler exists
%  this is called. It is important to use it only in places where this make sense.
%  \cs{@@_dict_put:nnn} is a simpler variant which only fills the property list.
%
%    \begin{macrocode}

%we allow only for local dictionaries a clear command
\cs_new_protected:Npn \@@_dict_clear:n #1
  {
    \@@_dict_if_local:nT { #1 }
      {
        \prop_clear:c  { \@@_dict_name:n { #1 } }
      }
  }

%reset clears and then fills with the default
\cs_new_protected:Npn \@@_dict_reset:n #1
  {
    \@@_dict_if_local:nT { #1 }
      {
        \prop_clear:c  { \@@_dict_name:n { #1 } }
        \use:c { @@_dict_#1_reset: }
      }
  }


%local + global
\cs_new_protected:Npn \@@_dict_handler_put:nnn #1 #2 #3  %#1 path, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfdict }{ empty-value }{ /#1/#2 }
      }
      {
        \@@_dict_if_exist:nTF { #1 }
          {
            \cs_if_exist:cTF
              { @@_dict_handler/#1/?_\@@_dict_get_g:n{#1}put:nn } %general, name independant handler
              { \use:c {@@_dict_handler/#1/?_\@@_dict_get_g:n{#1}put:nn} {#2} {#3} }
              {
                \cs_if_exist:cTF
                  { @@_dict_handler/#1/#2_\@@_dict_get_g:n{#1}put:n }
                  { \use:c {@@_dict_handler/#1/#2_\@@_dict_get_g:n{#1}put:n} {#3} } %special handler
                  {
                    \use:c { prop_\@@_dict_get_g:n{#1}put:cnn }
                      { \@@_dict_Xname:n { #1 } }{ #2 } { #3 }
                  }
              }
          }
          {
            \msg_error:nnn { pdfdict } { unknown-dict } { /#1 }
          }
      }
  }


\cs_generate_variant:Nn \@@_dict_handler_put:nnn {nxx}

\cs_new_protected:Npn \@@_dict_put:nnn #1 #2 #3  %#1 path, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfdict }{ empty-value }{ /#1/#2 }
      }
      {
       \@@_dict_if_exist:nTF { #1 }
         {
           \use:c { prop_\@@_dict_get_g:n{#1}put:cnn }
             { \@@_dict_Xname:n { #1 } }{ #2 } { #3 }
         }
         {
           \msg_error:nnn { pdfdict } { unknown-dict } { /#1 }
         }
      }
  }

%local + global

\cs_new_protected:Npn \@@_dict_get:nnN  #1 #2 #3 %path,key,macro
  {
    \prop_get:cnN
      { \use:c{ @@_dict_\tl_use:c{c_@@_dict_/#1_g_tl}name:n } { #1 } }
      { #2 } #3
  }

% local / global
\cs_new_protected:Npn \@@_dict_handler_remove:nn #1 #2 %path,key
  {
    \@@_dict_if_exist:nTF { #1 }
          {
            \cs_if_exist:cTF
              { @@_dict_handler/#1/?_\@@_dict_get_g:n{#1}remove:n } %general, name independant handler
              { \use:c {@@_dict_handler/#1/?_\@@_dict_get_g:n{#1}remove:n} {#2} }
              {
                \cs_if_exist:cTF
                  { @@_dict_handler/#1/#2_\@@_dict_get_g:n{#1}remove: }
                  { \use:c {@@_dict_handler/#1/#2_\@@_dict_get_g:n{#1}remove:} } %special handler
                  {
                    \use:c { prop_\@@_dict_get_g:n{#1}remove:cn }
                      { \@@_dict_Xname:n { #1 } }{ #2 }
                  }
              }
          }
          {
            \msg_error:nnn { pdfdict } { unknown-dict } { /#1 }
          }
  }

\cs_new_protected:Npn \@@_dict_remove:nn #1 #2 %path,key
  {
    \@@_dict_if_exist:nTF { #1 }
          {
            \use:c { prop_\@@_dict_get_g:n{#1}remove:cn }
              { \@@_dict_Xname:n { #1 } }{ #2 }
          }
          {
            \msg_error:nnn { pdfdict } { unknown-dict } { /#1 }
          }
  }


\cs_new_protected:Npn \@@_dict_show:Nn #1#2
  {
    \cs_if_exist:cTF
      { @@_dict_handler/#2/?_show: } %general, name independant handler
      { \use:c {@@_dict_handler/#2/?_show:} }
      {
        \prop_if_exist:cTF { \@@_dict_Xname:n { #2 } }
          {
             #1
               { pdfdict } { show-dict }
               { \tl_to_str:n {#2} }
               { \prop_map_function:cN {\@@_dict_Xname:n { #2 }} \msg_show_item:nn }
               { } { }
          }
          {
            #1 { pdfdict } { unknown-dict } {#2}{}{}{}
          }
       }
  }
\cs_new_protected:Npn \@@_dict_show:n #1  %path
  {
    \prop_show:c { \use:c{ @@_dict_\@@_dict_get_g:n{#1}name:n } { #1 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_dict_map:n }
% \cs{@@_dict_map:n} outputs a prop as needed in a dictionary:
%  as a list of /\meta{key} \meta{value} pairs.
%    \begin{macrocode}
%local + global
%!! Xname must be replaced later!
% !! is xexpansion the right thing?
\cs_new:Npn \@@_dict_map:n #1 %path
  {
    \prop_map_function:cN { \@@_dict_Xname:n { #1 } } \@@_dict_item:ne
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_dict_gmerge:nnN }
% \cs{@@_dict_gmerge:nnN} merges at first the property \meta{name_1}
%  then optionally \meta{name_2} into property |#3|.
%    \begin{macrocode}
% only used globally imho so leaving the global version only for now
\cs_new_protected:Npn \@@_dict_gmerge:nnN #1 #2 #3
  {
    \prop_gset_eq:Nc #3 { \@@_dict_gname:n  { #1 } }
    \prop_if_exist:cT  { \@@_dict_gname:n  { #2 } }
      {
        \prop_map_inline:cn { \@@_dict_gname:n  { #2 } }
          {
            \prop_gput:Nnn #3 { ##1 }{ ##2 }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{User Commands}
% \begin{NOTE}{UF}
% How to differentiate between global and local dicts?
% global: upper case: Catalog, Pages.
% local:  lower case: annot/link/URI.
% \end{NOTE}
% \begin{function}[added = 2020-04-21]
%   {\pdfdict_new:n}
%   \begin{syntax}
%     \cs{pdfdict_new:n} \Arg{local dictionary name}
%   \end{syntax}
% This function create a new local dictionary.
%    \begin{macrocode}
\cs_new_protected:Npn \pdfdict_new:n #1
  {
    \@@_dict_new:n {#1}
  }
%    \end{macrocode}
% \end{function}
% \begin{function}[added = 2020-04-06]
%   {\pdfdict_put:nnn, \pdfdict_gput:nnn}
%   \begin{syntax}
%     \cs{pdfdict_gput:nnn} \Arg{global dictionary} \Arg{name} \Arg{value}\\
%     \cs{pdfdict_put:nnn} \Arg{local dictionary} \Arg{name} \Arg{value}
%   \end{syntax}
% This function puts \Arg{name} \Arg{value} either globally or locally in internal
% property lists.
%
% \Arg{dictionary} is a symbolic name for a concrete PDF dictionary to which the
% content of these property lists will be written by the PDF resource management code.
%
% \Arg{name} should be a valid PDF Name without
% the starting slash.
%
% \Arg{value} should be a valid PDF value for this Name in the
% target dictionary.
%
% The PDF resource management code predefines a large number of
% symbolic names for important dictionaries and will write the stored values
% at the right time to the PDF. The predefined symbolic names are described below.
% By convention, dictionaries starting with an uppercase letter are always stored
% globally (e.g. \texttt{Catalog} or \texttt{Info}, lowercase letters indicates
% dictionaries that respect \TeX-groups -- this is e.g. used for dictionaries used in
% local objects like links.
%
% The code works with all major engines but not necessarily
% in the same way. Most importantly
% \begin{itemize}
% \item The expansion behaviour of the backends can differ. Some backends expand a
% value always fully when writing to the PDF, with other backends command names
% could end as strings in the PDF. So one should neither rely on \Arg{name}
% \Arg{value} to be expanded nor not expanded by the backend commands.
% \item The number of compilations needed can differ between the engines and backends.
% Some engines has to use labels and the aux-file to setup the dictionaries and so need
% at least two compilations to put everything in place.
% \end{itemize}
% \end{function}
%    \begin{macrocode}

\cs_new_protected:Npn \pdfdict_put:nnn #1 #2 #3
  {
    \@@_dict_if_local:nTF { #1 }
      {
        \@@_dict_handler_put:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \msg_error:nnnn{pdfdict}{wrong-or-unknown-dict}{#1}{local}
      }
  }

\cs_new_protected:Npn \pdfdict_gput:nnn #1 #2 #3
  {
    \@@_dict_if_global:nTF { #1 }
      {
        \@@_dict_handler_put:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \msg_error:nnnn{pdfdict}{wrong-or-unknown-dict}{#1}{global}
      }
  }

\cs_generate_variant:Nn \pdfdict_put:nnn {nnx,nno}
\cs_generate_variant:Nn \pdfdict_gput:nnn {nnx}
%    \end{macrocode}
% \begin{function}[EXP,added = 2020-04-21]
%   {\pdfdict_map:n }
%   \begin{syntax}
%     \cs{pdfdict_map:n}  \Arg{dictionary}
%   \end{syntax}
%   This outputs the property list of the dictionary as a list of
%   \texttt{/key value} pairs.
%   This is suitable for simple, local dictionaries which can be written directly
%   to the PDF.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \pdfdict_map:n #1
  {
    \@@_dict_map:n { #1 }
  }
%    \end{macrocode}
%
% \begin{function}[added = 2020-04-25]
%   {\pdfdict_reset:n }
%   \begin{syntax}
%     \cs{pdfdict_reset:n}  \Arg{(local) dictionary}
%   \end{syntax}
% This resets a dictionary: it clears the entries and then adds eventually
% default values (normally at least the Type entry).
%  \end{function}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfdict_reset:n #1
  {
    \@@_dict_reset:n { #1 }
  }
%    \end{macrocode}
% \begin{function}[added = 2020-04-08]
%   {\pdfdict_show:n }
%   \begin{syntax}
%     \cs{pdfdict_show:n}  \Arg{dictionary}
%   \end{syntax}
%   This shows the content of \Arg{dictionary} in the log and on the terminal.
%   It also shows if  \Arg{dictionary} is a local or a global dictionary.
%   It doesn't show the special catalog dictionaries with arrays as values
%   as these are filled only at
%   the end of the document.
%\end{function}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfdict_show:n
  {
    \@@_dict_show:Nn \msg_show:nnxxxx
  }
%    \end{macrocode}
% \begin{function}[EXP, pTF,added = 2020-04-08]
%   {\pdfdict_if_exist:n }
%   \begin{syntax}
%     \cs{pdfdict_if_exist:n}  \Arg{dictionary}
%   \end{syntax}
%   This tests if the dictionary exists.
%\end{function}
%    \begin{macrocode}
\prg_new_eq_conditional:NNn \pdfdict_if_exist:n \@@_dict_if_exist:n
  { TF , T , F , p }

%    \end{macrocode}
% \begin{function}[EXP, pTF,added = 2020-04-08]
%   {\pdfdict_if_empty:n }
%   \begin{syntax}
%     \cs{pdfdict_if_empty:n}  \Arg{dictionary}
%   \end{syntax}
%   This tests if the dictionary is empty. The result is false if the
%   dictionary doesn't exist.
%\end{function}
%    \begin{macrocode}
\prg_new_eq_conditional:NNn \pdfdict_if_empty:n \@@_dict_if_empty:n
  { TF , T , F , p }
%    \end{macrocode}
%
% \begin{function}[added = 2020-04-07]
%   {\pdfdict_get:nn }
%   \begin{syntax}
%     \cs{pdfdict_get:nnN}  \Arg{dictionary} \Arg{name} \meta{tl var}
%   \end{syntax}
%   Recovers the \meta{value} stored by \cs{pdfdict_put:nnn} or \cs{pdfdict_gput:nnn}
%   for \meta{name} and places this in the \meta{token list
%   variable}. If \meta{name} is not found
%   then the \meta{token list variable} is set
%   to the special marker \cs{q_no_value}. The \meta{token list
%   variable} is set within the current \TeX{} group.
%\end{function}
%    \begin{macrocode}

\cs_new_protected:Npn \pdfdict_get:nnN #1 #2 #3
  {
    \@@_dict_get:nnN {#1}{ #2 } #3
  }

%    \end{macrocode}
% \begin{function}[added = 2020-04-07]
%   {
%     \pdfdict_remove:nn,
%   }
%   \begin{syntax}
%     \cs{pdfdict_remove:nn} \Arg{local dictionary} \Arg{name}\\
%     \cs{pdfdict_gremove:nn} \Arg{global dictionary} \Arg{name}
%   \end{syntax}
%   Removes  |/|\meta{name} and its associated \meta{value} from the \Arg{dictionary}
%   The removal is local for local dictionaries, and global
%   for global dictionaries.
%   If \meta{name} is not found no change occurs,
%   \emph{i.e}~there is no need to test for the existence of a name before
%   trying to remove it.
%   Values from the special Catalog entries with arrays as values can not be
%   removed.
% \end{function}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfdict_remove:nn #1 #2
  {
    \@@_dict_if_local:nTF { #1 }
      {
        \@@_dict_handler_remove:nn { #1 }{ #2 }
      }
      {
        \msg_error:nnnn{pdfdict}{wrong-or-unknown-dict}{#1}{local}
      }
  }

\cs_new_protected:Npn \pdfdict_gremove:nn #1 #2
  {
    \@@_dict_if_global:nTF { #1 }
      {
        \@@_dict_handler_remove:nn { #1 }{ #2 }
      }
      {
        \msg_error:nnnn{pdfdict}{wrong-or-unknown-dict}{#1}{global}
      }
  }
%    \end{macrocode}
% \subsection{Convenience local dictionaries}
% A number of predefined small, local dictionaries, that are perhaps needed.
% \subsubsection{page/Trans}
% This is a template for a Trans dictionary that can be used in a page dictionary.
%    \begin{macrocode}
\pdfdict_new:n {page/Trans}
\pdfdict_put:nnn {page/Trans}{Type}{/Trans}
 %keys: /S (name), /D integer, /Dm (name), /M (name), /SS number /B boolean.
 %decribes transition *to* the page.
%    \end{macrocode}
% \subsubsection{annot/Link}
% The dictionaries \texttt{annot/Link/URI}, \texttt{annot/Link/GoToR},
% \texttt{annot/Link/Launch}, \texttt{annot/Link/GoTo}, \texttt{annot/Link/Named}
% are created in the pdfannot section \ref{pdf:annot:widget}
% \subsubsection{annot/Widget}
% \texttt{annot/Widget} see section \ref{sec:links}.
%
% \subsection{The \enquote{Info} dictionary (pdfinfo)}
% \begin{NOTE}{UF}
% path: Info
% The info dictionary is filled by e.g. \cs{pdfinfo}. Multiple appearances of
% \cs{pdfinfo} are concatenated, so one could end with multiple /Title or /Author entries.
% It is then viewer dependent which one is showed, so it is better to avoid this.
% We therefore setup a property which is filled and written to the info
% directory in one go. According to hyperref a few odd drivers (hvtex, dvipsone, dviwind)
% don't support arbitrary keys, but this should be handle elsewhere. Most entries are
% strings so there is a special command for this. As entries with empty content
% should be omitted we add a test. The string command should perhaps escape the argument,
% but for now we are assuming that the argument is pdf safe.
% hyperref writes to the info dictionary at the shipout of the first page --
% probably to catch the  case that \cs{title} is issued after the begin of the document.
% We are outputting at the last page -- this needs a second compilation but
% this is needed anyway.
% \end{NOTE}
%
% \subsubsection{\enquote{Info}/backend}
% The backend code is already in expl3.
% \cs{@@_backend_info_gput:nn} inserts one name/value pair.
%
% \subsubsection{\enquote{Info}/management}
% \potentialclash If the primitive commands are used additionally there will
% be double entries in the pdf with the backend pdftex and luatex.
% How pdf viewer handles this is unpredictable.
%
%  \begin{function}
%   {
%     pdfdict: Info (global)
%   }
%   \begin{syntax}
%     \cs{pdfdict_gput:nnn} \{Info\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Adds |/|\meta{name} and the \meta{value} to the Info dictionary.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value. Any escaping or (re)encoding must be
%   done explicitly.
%   If a \meta{name} is used twice, only the last \meta{value}
%   set will be used. The info dictionary is written at the end of the compilation,
%   so values can be set at any time.
%   The info dictionary expects utf8 in the strings, so a conversion like this is
%   normally sensible:
%   \begin{verbatim}
%   \str_set_convert:Nnnn \l_tmpa_str { Grüße }{ utf8 } {utf8/string}
%   \pdfdict_gput:nnx {Info} {Title}{(\l_tmpa_str)}
%   \end{verbatim}
% \end{function}
%    \begin{macrocode}
\@@_dict_gnew:n {Info}
%    \end{macrocode}
%
% \begin{macro}{\@@_dict_Info_gpush:}
% \cs{@@_dict_Info_gpush:} is the command that outputs the info dictionary (currently
% in the end-of-run hooks).
%    \begin{macrocode}
% push to the register command / issue the special
\cs_new_protected:Npn \@@_dict_Info_gpush:
  {
    \prop_map_function:cN  { \@@_dict_gname:n {Info} } \@@_backend_info_gput:nn
    \prop_gclear:c { \@@_dict_gname:n {Info} }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{The \enquote{Pages} dictionary (pdfpagesattr)}
% The content of the property list associated with this dictionary name is written to the
% /Pages object. This replaces \cs{pdfpagesattr}. This dictionary is global.
% \subsubsection{\enquote{Pages} / backend}
% \begin{NOTE}{UF}
%  path: Pages
%  pdfpagesattr is a single token register which is used at the end of the compilation.
%  dvips syntax: \verb+\special{ps: [/ABC /CDE /EFG /FGH /Rotate 90 /PAGES pdfmark}+
%  dvipdfmx syntax: \verb+\special{pdf:put @pages <</ABC /WEZ /EFG /XYZ /Rotate 0>>}+
%  both remove duplicate entries automatically, so there is no need to be careful.
% \end{NOTE}
% \begin{macro}{\@@_backend_Pages_primitive:n}
% This is the primitive command to add something to the /Pages dictionary.
% It works differently for the backends: pdftex and luatex overwrite existing
% content, dvips and dvipdfmx are additive. luatex sets it in lua.
% The higher level code has to take this into account.
%    \begin{macrocode}
%pdftex
\bool_if:nT {\sys_if_engine_pdftex_p: && \sys_if_output_pdf_p:}
  {
    \cs_new_protected:Npn \@@_backend_Pages_primitive:n #1
      {
        \tex_global:D \tex_pdfpagesattr:D { #1 }
      }
  }
%luatex: does it in lua
\sys_if_engine_luatex:T
  {
    \cs_new_protected:Npn \@@_backend_Pages_primitive:n #1
      {
        \tex_directlua:D
          {
            pdf.setpagesattributes( \@@_backend_luastring:n { #1 } )
          }
      }
  }
%dvips
\bool_if:nT {\sys_if_engine_pdftex_p: && !\sys_if_output_pdf_p: }
  {
    \cs_new_protected:Npx \@@_backend_Pages_primitive:n #1
      {
        \tex_special:D{ps:~[#1~/PAGES~pdfmark} %]
      }
  }

%xetex
\sys_if_engine_xetex:T
  {
    \cs_new_protected:Npn \@@_backend_Pages_primitive:n #1
      {
        \@@_backend:n{put~@pages~<<#1>>}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\enquote{Pages} / management}
% \begin{NOTE}{UF}
% The register is normally used only a few times in a document, so it would be
% okay to update the register/add the special at every change,
% but with dvips/dvipdfmx this would disable removing entries.
% So we issue the push code only at the end of the document.
% \end{NOTE}
% \begin{function}{pdfdict: Pages (global)}
%   \begin{syntax}
%     \cs{pdfdict_gput:nnn} \{Pages\} \Arg{name} \Arg{value}
%   \end{syntax}
%
%   Adds |/|\meta{name} \meta{value} to the |/Pages| dictionary.
%   It is always stored globally. The content is written to the pdf
%   at the end of the compilation, so values can be added, changed or
%   removed until then.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value. Any escaping or (re)encoding must
%   be done explicitly. Some backends expand the value but this should not be
%   relied on. If a \meta{name} is used twice, only the last \meta{value}
%   set will be used.
%
%   \potentialclash As the content is written at the end it will
%   in pdftex and luatex overwrite values added with the primitive commands.
%   Package authors should use the management commands instead.
% \end{function}
%    \begin{macrocode}
\@@_dict_gnew:n {Pages}
%    \end{macrocode}
%
% \begin{macro}{\@@_dict_Pages_gpush:}
% This is the command that outputs the Pages dictionary. It is used
% at the end of the document in \cs{g_@@_BACKEND_end_run_tl}
%    \begin{macrocode}
% push to the register command / issue the special
\cs_new_protected:Npn \@@_dict_Pages_gpush:
  {
    \exp_args:Nx \@@_backend_Pages_primitive:n
      {
        \@@_dict_map:n {Pages}
      }
  }

%    \end{macrocode}
% \end{macro}
%
% \subsection{\enquote{Page} and \enquote{ThisPage} (pdfpageattr)}
% \subsubsection{\enquote{Page} and \enquote{ThisPage} /backend}
% \begin{NOTE}{UF}
%  path: Page
%  The engines differ a lot here: pdflatex and lualatex uses a register while with
%  dvips/dvipdfmx a one-shot-special is used. So for pdflatex and lualatex code
%  to assemble the content of the register is needed. Specials are used at shipout,
%  the registers is set directly. With lualatex one can use
%  \cs{latelua} to delay the setting, with pdflatex one has to use a shipout hook.
%  To get the code on the correct page one has to use the aux with pdflatex.
%  In sum this means that quite a lot backend commands are needed to handle
%  this differences. Simply variants of \cs{pdfpageattr} are not enough ...%
%  dvips syntax: \special{ps: [{ThisPage}<</Rotate 90>> /PUT pdfmark}%
%  There seem to be an in-built management code: multiple uses don't lead to
%  multiple entries (/Rotate is special: there is always a /Rotate 0 in the dict, but seems
%  not to do harm).
%  dvipdfmx syntax: \special{pdf: put @thispage << /Rotate 90 >>}, like dvips has an in-built
%  management code.
%  Both change only the current page, so to get the pdftex behavior (which sets
%  also the following pages) one need to repeat it on every shipout.
% \end{NOTE}
% \begin{macro}{\@@_backend_Page_primitive:n,
%               \@@_backend_Page_gput:nn,
%               \@@_backend_Page_gremove:n,
%               \@@_backend_ThisPage_gput:nn,
%               \@@_backend_ThisPage_gpush:n }
% \cs{@@_backend_Page_primitive:n} is the primitive command to add
% something to the /Page dictionary.
% It works differently for the backends: pdftex and luatex overwrite existing
% content, dvips and dvipdfmx are additive. luatex sets it in lua.
% The higher level code has to take this into account.
% \cs{@@_backend_Page_gput:nn} stores default values.
% \cs{@@_backend_Page_gremove:n} allows to remove a value.
% \cs{@@_backend_ThisPage_gput:nn} adds a value to the current page.
% \cs{@@_backend_ThisPage_gpush:n} merges the default and the page value and
% adds it to the dictionary of the current page in
% \cs{g_@@_BACKEND_thispage_shipout_tl}.
%    \begin{macrocode}
%  backend commands

%pdflatex
\bool_if:nT {\sys_if_engine_pdftex_p: && \sys_if_output_pdf_p: }
  {
  %the primitive
    \cs_new_protected:Npn \@@_backend_Page_primitive:n #1
      {
        \tex_global:D \tex_pdfpageattr:D { #1 }
      }
  % the command to store default values.
  % Uses a prop with pdflatex + dvi,
  % sets a lua table with lualatex
  \cs_new_protected:Npn \@@_backend_Page_gput:nn #1 #2 %key,value
    {
      \@@_dict_put:nnn {Page}{ #1 }{ #2 }
    }
  % the command to remove a default value.
  % Uses a prop with pdflatex + dvi,
  % changes a lua table with lualatex
  \cs_new_protected:Npn \@@_backend_Page_gremove:n #1
    {
      \@@_dict_remove:nn  {Page}{ #1 }
    }
 % the command used in the document.
 % direct call of the primitive special with dvips/dvipdfmx
 % \latelua: fill a page related table with lualatex, merge it with the page
 % table and push it directly
 % write to aux and store in prop with pdflatex
  \cs_new_protected:Npn \@@_backend_ThisPage_gput:nn #1 #2
    {
      \int_gincr:N\g_@@_backend_resourceid_int
      \zref@labelbylist {l3pdf\int_use:N\g_@@_backend_resourceid_int} {l3pdf}
      \tl_set:Nx \l_@@_tmpa_tl
        {
          \zref@extractdefault
            {l3pdf\int_use:N\g_@@_backend_resourceid_int}
            {pdf@abspage}
            {0}
        }
      \@@_dict_if_exist:nF {backend_Page\l_@@_tmpa_tl}
        {
          \@@_dict_gnew:n          {backend_Page\l_@@_tmpa_tl}
        }
      \@@_dict_handler_put:nnn {backend_Page\l_@@_tmpa_tl}{ #1 }{ #2 }
    }
  %the code to push the values, used in shipout
  %merges the two props and then fills the register in pdflatex
  %merges the two tables and then fills (in lua) in luatex
  %issues the values stored in the global prop with dvi
  \cs_new_protected:Npn \@@_backend_ThisPage_gpush:n #1
    {
      \@@_dict_gmerge:nnN {Page}{backend_Page#1}\g_@@_tmpa_prop
      \exp_args:Nx \@@_backend_Page_primitive:n
        {
          \prop_map_function:NN \g_@@_tmpa_prop \@@_dict_item:ne
        }
    }
  }

\sys_if_engine_luatex:T
  {% do we need to use some escaping for the values?????
    \cs_new:Npn \@@_backend_luastring:n #1
      {
        "\tex_luaescapestring:D { \tex_unexpanded:D { #1 } }"
      }
 %not used, only there for consistency
    \cs_new_protected:Npn \@@_backend_Page_primitive:n #1
      {
        \tex_latelua:D
          {
            pdf.setpageattributes(\@@_backend_luastring:n { #1 })
          }
      }
  % the command to store default values.
  % Uses a prop with pdflatex + dvi,
  % sets a lua table with lualatex
    \cs_new_protected:Npn \@@_backend_Page_gput:nn #1 #2
      {
        \tex_directlua:D
          {
            l3kernel.@@.backend_Page_gput
              (
                \@@_backend_luastring:n { #1 },
                \@@_backend_luastring:n { #2 }
              )
          }
      }
  % the command to remove a default value.
  % Uses a prop with pdflatex + dvi,
  % changes a lua table with lualatex
  \cs_new_protected:Npn \@@_backend_Page_gremove:n #1
    {
      \tex_directlua:D
        {
          l3kernel.@@.backend_Page_gremove (\@@_backend_luastring:n { #1 })
        }
    }
 % the command used in the document.
 % direct call of the primitive special with dvips/dvipdfmx
 % \latelua: fill a page related table with lualatex, merge it with the page
 % table and push it directly
 % write to aux and store in prop with pdflatex
  \cs_new_protected:Npn \@@_backend_ThisPage_gput:nn #1 #2
    {
      \tex_latelua:D
        {
          l3kernel.@@.backend_ThisPage_gput
            (
              tex.count["g_shipout_readonly_int"],
              \@@_backend_luastring:n { #1 },
              \@@_backend_luastring:n { #2 }
            )
          l3kernel.@@.backend_ThisPage_gpush (tex.count["g_shipout_readonly_int"])
        }
    }
  %the code to push the values, used in shipout
  %merges the two props and then fills the register in pdflatex
  %merges the two tables (the one is probably still empty) and then fills (in lua) in luatex
  %issues the values stored in the global prop with dvi
  \cs_new_protected:Npn \@@_backend_ThisPage_gpush:n #1
    {
      \tex_latelua:D
        {
          l3kernel.@@.backend_ThisPage_gpush (tex.count["g_shipout_readonly_int"])
        }
    }
  }

\sys_if_engine_xetex:T
  {
  %the primitive
    \cs_new_protected:Npn \@@_backend_Page_primitive:n #1
      {
        \tex_special:D{pdf:~put~@thispage~<<#1>>}
      }
  % the command to store default values.
  % Uses a prop with pdflatex + dvi,
  % sets a lua table with lualatex
    \cs_new_protected:Npn \@@_backend_Page_gput:nn #1 #2
      {
        \@@_dict_put:nnn {Page}{ #1 }{ #2 }
      }
  % the command to remove a default value.
  % Uses a prop with pdflatex + dvi,
  % changes a lua table with lualatex
    \cs_new_protected:Npn \@@_backend_Page_gremove:n #1
      {
        \@@_dict_remove:nn  {Page}{ #1 }
      }
  % the command used in the document.
  % direct call of the primitive special with dvips/dvipdfmx
  % \latelua: fill a page related table with lualatex, merge it with the page
  % table and push it directly
  % write to aux and store in prop with pdflatex
    \cs_new_protected:Npn \@@_backend_ThisPage_gput:nn #1 #2
      {
        \@@_backend_Page_primitive:n { /#1~#2 }
      }
  %the code to push the values, used in shipout
  %merges the two props and then fills the register in pdflatex
  %merges the two tables (the one is probably still empty)
  % and then fills (in lua) in luatex
  %issues the values stored in the global prop with dvi
    \cs_new_protected:Npn \@@_backend_ThisPage_gpush:n #1
      {
        \exp_args:Nx \@@_backend_Page_primitive:n
          { \@@_dict_map:n {Page} }
      }
  }
%dvips
\bool_if:nT {\sys_if_engine_pdftex_p: && !\sys_if_output_pdf_p: }
  {
    \cs_new_protected:Npn \@@_backend_Page_primitive:n #1
      {
        \tex_special:D{ps:~[{ThisPage}<<#1>>~/PUT~pdfmark} %]
      }
  % the command to store default values.
  % Uses a prop with pdflatex + dvi,
  % sets a lua table with lualatex
    \cs_new_protected:Npn \@@_backend_Page_gput:nn #1 #2
      {
        \@@_dict_put:nnn {Page}{ #1 }{ #2 }
      }
  % the command to remove a default value.
  % Uses a prop with pdflatex + dvi,
  % changes a lua table with lualatex
    \cs_new_protected:Npn \@@_backend_Page_gremove:n #1
      {
        \@@_dict_remove:nn  {Page}{ #1 }
      }
  % the command used in the document.
  % direct call of the primitive special with dvips/dvipdfmx
  % \latelua: fill a page related table with lualatex, merge it with the page
  % table and push it directly
  % write to aux and store in prop with pdflatex
    \cs_new_protected:Npn \@@_backend_ThisPage_gput:nn #1 #2
      {
        \@@_backend_Page_primitive:n { /#1~#2 }
      }
  %the code to push the values, used in shipout
  %merges the two props and then fills the register in pdflatex
  %merges the two tables (the one is probably still empty)
  %and then fills (in lua) in luatex
  %issues the values stored in the global prop with dvi
    \cs_new_protected:Npn \@@_backend_ThisPage_gpush:n #1
      {
        \exp_args:Nx \@@_backend_Page_primitive:n
          { \@@_dict_map:n {Page} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\enquote{Page} and \enquote{ThisPage} / management}
% \begin{NOTE}{UF}
% Open is the question if one need a command to set attribute on a page by page number.
% Open is the setter for /AF (and perhaps /OutputIntents).
% See also https://tex.stackexchange.com/questions/479812/extension-of-rotating-package-to-set-pdf-rotation
% (should work now)
% \end{NOTE}
% \begin{function}[added = 2020-04-12]
%   {pdfdict: Page}
%   \begin{syntax}
%     \cs{pdfdict_gput:nnn} \{Page\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Values added to the dictionary \texttt{Page} are added to the page dictionary
%   of the current page and the following pages. The current page means the page
%   on which the command is executed. \meta{name} should be a valid pdf name
%   without the leading slash. Typical names used here are e.g.
%   \texttt{Rotate} and \texttt{CropBox}.
%   \meta{value} should be a valid pdf value.
%   Any escaping or (re)encoding must be done explicitly. Some backends expand the
%   value but this should not be relied on.
%   To avoid problems with the asynchronous page breaking
%   the command should be used after \cs{newpage}, or in the header,
%   and better not in a float.
%   The value is assigned directly and is always stored globally.
%   If a \meta{name} is used twice, only the last \meta{value}
%   set will be used. Names set with \cs{pdfdict_put:nnn}|{ThisPage}| will overwrite
%   names set with \cs{pdfdict_put:nnn}|{Page}| if there is a clash.
%   Values can be removed again with \cs{pdfdict_remove:nn}
% \end{function}
% \begin{function}[added = 2020-04-12]
%   { pdfdict: ThisPage}
%   \begin{syntax}
%     \cs{pdfdict_gput:nnn} \{ThisPage\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Adds |/|\meta{name} \meta{value} at shipout to the page dictionary of the
%   current page. Current page means here the shipout page.
%   It is always stored globally.
%   If \Arg{name} has already a value set in the \texttt{Page}
%   dictionary it will be overwritte for this page.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value. Any escaping or (re)encoding must be
%   done explicitly. If a \meta{name} is used twice, only the last \meta{value}
%   set will be used.
%   With the engine pdflatex (at least) a second compilation is needed.
%   Values added to \texttt{ThisPage} can not be removed. It is not possible to
%   show the content of this dictionary with \cs{pdfdict_show:n}.
% \end{function}
%    \begin{macrocode}
% setter.
%^^A documentated
\@@_dict_gnew:n { Page }
\@@_dict_gnew:n { ThisPage }

%handler for pdfdict
\cs_new_protected:cpn { @@_dict_handler/Page/?_gput:nn } #1 #2
  {
    %\prop_gput:cnn  { \@@_dict_gname:n { Page } }{ #1 } { #2 }
    \@@_backend_Page_gput:nn { #1 }{ #2 }
  }
% remove:
\cs_new_protected:cpn { @@_dict_handler/Page/?_gremove:n } #1
  {
    %\prop_gremove:cn  { \@@_dict_gname:n { Page } }{ #1 }
    \@@_backend_Page_gremove:n { #1 }
  }

% handler for pdfdict
\cs_new_protected:cpn { @@_dict_handler/ThisPage/?_gput:nn } #1 #2
  {
    \prop_gput:cnn  { \@@_dict_gname:n { ThisPage } }{ #1 } { #2 }
    \@@_backend_ThisPage_gput:nn { #1 }{ #2 }
  }

\cs_new_protected:cpn { @@_dict_handler/ThisPage/?_gremove:n } #1
  {
    \msg_warning:nnn { pdfdict } { no-removal }{ThisPage}
  }

\cs_new_protected:cpn { @@_dict_handler/ThisPage/?_show: }
  {
    \msg_warning:nnn { pdfdict } { no-show }{ThisPage}
  }

%    \end{macrocode}
%
%
% \subsection{\enquote{Page/Resources}: ExtGState, ColorSpace, Shading, Pattern }
% \begin{NOTE}{UF}
% Only for pdf/luatex and xdvipdfmx backend- and pdf-code is needed to add values
% to these resources.
% With dvips the resources are added through high-level code (e.g. transparency), so the
% backend/pdf commands are no-ops.
% For every resources there is only one object. References to these objects are added to
% all pages starting from the page where the first time something has been added to the
% resource and to all XObjects. For luatex and pdftex it must be done together
% with the /Properties, see above.
% I don't see a need to set e.g. /ColorSpace page wise: preflight handles this
% fine, see experiment colorspace-resources.
% As pgf does the same, there is a need to patch it for now. Ditto for package colorspace.
% \end{NOTE}
% \subsubsection{\enquote{Page/Resources}: ExtGState, ColorSpace, Shading, Pattern / backend}
% Path: Page/Resources/ExtGState etc. The actual output of the resources is handled
% together with the bdc/Properties. Here is only special code.
% \begin{macro}{\@@_backend_PageResources_gput:nnn}
% stores values for the page resources.
% \begin{arguments}
% \item name of the resource (ExtGState, ColorSpace, Shading, Pattern)
% \item a pdf name without slash
% \item value
% \end{arguments}
% \begin{macro}{\@@_PageResources_gpush:}
% This pushes out the objects. It is a no-op with xdvipdfmx and dvips.
%    \begin{macrocode}
% backend commands the command to fill the register
% and to push the values.
%
%quite often needed
%</package>
%<*drivers>
\clist_const:Nn \c_@@_backend_PageResources_clist
  {
    ExtGState,
    ColorSpace,
    Pattern,
    Shading,
  }

\clist_map_inline:Nn \c_@@_backend_PageResources_clist
      {
        \@@_dict_gnew:n {Page/Resources/#1}
      }
%</drivers>
% pdftex and luatex
%<*pdfmode>
 %create the backend objects:
  \clist_map_inline:Nn \c_@@_backend_PageResources_clist
    {
      \@@_backend_object_new:nn {Page/Resources/#1} {dict}
      \cs_if_exist:NT \tex_directlua:D
        {
          \tex_directlua:D
            {
              l3kernel.@@.object["Page/Resources/#1"]
              =
              "\@@_backend_object_ref:n{Page/Resources/#1}"
            }
        }
     }
 %values are only stored in a prop and will be output at end document.
  \sys_if_engine_luatex:TF
    {
      \cs_new_protected:Npn \@@_backend_PageResources_gput:nnn #1 #2 #3
        {
          \@@_dict_put:nnn {Page/Resources/#1} { #2 }{ #3 }
          % luatex must also trigger the lua side
          \tex_latelua:D{l3kernel.@@.Page.Resources.#1=true}
          \tex_latelua:D
            {
              l3kernel.pdf.Page_Resources_gpush(tex.count["g_shipout_readonly_int"])
            }
        }
    }
    { %pdftex
      \cs_new_protected:Npn \@@_backend_PageResources_gput:nnn #1 #2 #3
        {
          \@@_dict_put:nnn {Page/Resources/#1} { #2 }{ #3 }
        }
    }

 %code for end of document code
 \cs_new_protected:Npn \@@_PageResources_gpush:
   {
     \clist_map_inline:Nn \c_@@_backend_PageResources_clist
       {
         \prop_if_empty:cF
           { \@@_dict_gname:n {Page/Resources/##1} }
           {
             \@@_backend_object_write:nx
               { Page/Resources/##1 }
               { \@@_dict_map:n {Page/Resources/##1} }
           }
      }
   }
%</pdfmode>
% xdvipdfmx
% \special{pdf:pageresources<<#1>>} doesn't work correctly with object names ...
% https://tug.org/pipermail/dvipdfmx/2019-August/000021.html,
% so we use \special{pdf:put @resources}
% this must be issued on every page!
%<*xdvipdfmx>
  %objects should not only be created but also "initialized"
    \clist_map_inline:Nn \c_@@_backend_PageResources_clist
      {
        \@@_backend_object_new:nn   { Page/Resources/#1 } { dict }
        \@@_backend_object_write:nn { Page/Resources/#1 } {}
      }

    \cs_new_protected:Npn \@@_backend_PageResources:n #1
      {
        \@@_backend:n {put~@resources~<<#1>>}
      }
    \cs_new_protected:Npn \@@_backend_PageResources_gput:nnn #1 #2 #3
      {
       % this is not used for output, but there is a test if the resource is empty
       \prop_gput:cnn { \@@_dict_gname:n {Page/Resources/#1} } { #2 }{ #3 }
       %objects are not filled with \pdf_object_write as this is not additive!
        \@@_backend:x
          {
            put~\@@_backend_object_ref:n {Page/Resources/#1}<</#2~#3>>
          }
      }

    \cs_new_protected:Npn \@@_PageResources_gpush: {}
%</xdvipdfmx>
%<*dvips>
% dvips unneeded, or no-op
    \cs_new_protected:Npn \@@_backend_PageResources:n #1 {}
    \cs_new_protected:Npn \@@_backend_PageResources_gput:nnn #1 #2 #3
      { %only for the show command TEST!!
        \@@_dict_put:nnn {Page/Resources/#1} { #2 }{ #3 }
      }
    \cs_new_protected:Npn \@@_PageResources_gpush: {}
%</dvips>
%<*package>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% !!!!! check path names (backend or not ...)
%
% \subsubsection{\enquote{Page/Resources}: ExtGState, ColorSpace, Shading, Pattern / management}
% \begin{function}[updated = 2020-04-10]
%   {
%    pdfdict: Page/Resources/ExtGState,
%    pdfdict: Page/Resources/ColorSpace,
%    pdfdict: Page/Resources/Shading,
%    pdfdict: Page/Resources/Pattern,
%   }
%   \begin{syntax}
%     \cs{pdfdict_gput:nnn} \{Page/Resources/\meta{resource}\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Adds |/|\meta{name} \meta{value} to the page resource \meta{resource}.
%   \meta{resource} can be |ExtGState|, |ColorSpace|, |Pattern| oder |Shading|.
%   The values are always stored globally. The content is written to the pdf
%   at the end of the compilation, so values can be added until then.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value for the resource.
%   Any escaping or (re)encoding must be done explicitly. If a \meta{name} is
%   used twice, only the last \meta{value} set will be used.
%
%   With the dvips backend the command does nothing: resources are managed by
%   ghostscript or the distiller if e.\,g. transparency is used.
%
%   The resources are added to all pages starting with the first where something has
%   been added to a resources. That means that for example
%   all ExtGState resources are combined in one
%   dictionary object and every page with a ExtGState resource refer to this object.
%
%   \potentialclash The primitive commands to set the resources should not be used
%   together with this code as the calls will overwrite each other and values
%   will be lost. This means that currently there are clashes with the packages tikz,
%   transparent and colorspace.
% \end{function}
%    \begin{macrocode}
%
% setter:  #1 is the name of the resource

\cs_new_protected:cpn { @@_dict_handler/Page/Resources/ExtGState/?_gput:nn } #1 #2
  {
    \@@_backend_PageResources_gput:nnn {ExtGState} { #1 }{ #2 }
  }

\cs_new_protected:cpn { @@_dict_handler/Page/Resources/ColorSpace/?_gput:nn } #1 #2
  {
    \@@_backend_PageResources_gput:nnn {ColorSpace} { #1 }{ #2 }
  }

\cs_new_protected:cpn { @@_dict_handler/Page/Resources/Shading/?_gput:nn } #1 #2
  {
    \@@_backend_PageResources_gput:nnn {Shading} { #1 }{ #2 }
  }

\cs_new_protected:cpn { @@_dict_handler/Page/Resources/Pattern/?_gput:nn } #1 #2
  {
    \@@_backend_PageResources_gput:nnn {Pattern} { #1 }{ #2 }
  }

%    \end{macrocode}
%
% \subsection{\enquote{Catalog} \& subdirectories (pdfcatalog) }
% \subsubsection{\enquote{Catalog} \& subdirectories / backend}
% the backend command is already in the driver:
% \cs{@@_backend_catalog_gput:nn}
%
% \paragraph { Special case: the /Names dictionary }
% Entries to /Names are handled differently, in part (/Desc) it is automatic, for
% other special commands like \cs{pdfnames} must be used.
%    \begin{macrocode}
% pdflatex
\bool_if:nT {\sys_if_engine_pdftex_p: && \sys_if_output_pdf_p:}
 {
   \cs_new_protected:Npn \@@_backend_NamesEmbeddedFiles_gpush:n #1 %array content
     {
        \pdf_object_now:nn {dict} {/Names [#1] }
        \pdfnames{/EmbeddedFiles~\pdf_object_last:}
     }
 }

\sys_if_engine_luatex:T
 {
   \cs_new_protected:Npn \@@_backend_NamesEmbeddedFiles_gpush:n #1 %array content
     {
       \pdf_object_now:nn {dict} {/Names [#1] }
       \pdfextension~names~{/EmbeddedFiles~\pdf_object_last: }
     }
 }

\sys_if_engine_xetex:T
 {
   \cs_new_protected:Npn \@@_backend_NamesEmbeddedFiles_gpush:n #1 %array content
     {
       \pdf_object_now:nn {dict} { /Names [#1] }
       %n or x?
       \__pdf_backend:x {put~@names~<</EmbeddedFiles~\pdf_object_last: >>}
     }
 }

%dvips: noop
\bool_if:nT {\sys_if_engine_pdftex_p: && !\sys_if_output_pdf_p:}
  {
    \cs_new_protected:Npn \@@_backend_NamesEmbeddedFiles_gpush:n #1 {}
  }

%    \end{macrocode}
% \subsubsection{\enquote{Catalog} \& subdirectories / management }
% \begin{NOTE}{UF}
% The catalog dictionary is filled by e.g. \cs{pdfcatalog}. Multiple appearances of
% \cs{pdfcatalog} are concatenated, so one could end with multiple entries
% for the same value with luatex and pdftex -- the other backends normally
% avoid this problem.
% We therefore setup a property which is filled and executed at a sensible
% (not fixed) place.
% /AF is even an array of dictionaries.
% There is probably no way to test what has already been added to the catalog,
% so doublets can only be avoided with ``don't do it''.
% see catalogue.tex for a list of entries ...
% Perhaps some tools to create the AF-file specification dictionaries is useful.
% Open for now:
% /Extensions               (dict, pdf 2.0)
% /Dests ? difference to subdict in Names?
% /DSS                      (dict, pdf 2.0)
% /Acroform/DR/ExtGState etc probably unneeded.
% \end{NOTE}
% The catalog is a central dictionary in a PDF with a number of subdictionaries.
% Entries to the top level of the catalog can be added with
% |\pdfdict_put:nnn {Catalog}|\Arg{Name}\Arg{Value}.
% Entries to subdictionaries by using in the first
% argument one of the pathes described later.
% The entries in the catalog have varying requirements regarding the
% PDF management. Some entries (like /Lang) are simple values where new values should
% overwrite existing values, other like for example \texttt{/OutputIntents}
% can contain a number of values and can be filled from more than one source.
% In some cases the values that needs to be added are not at the top-level
% but in some subsubdictionary or are actually part of an array.
% To handle this some pathes use internally special handlers.
%
% \potentialclash In some cases entries are added implicitly.
% For example entries to the name
% tree of the \texttt{/EmbeddedFiles} key in the \texttt{/Names} directory are
% added with the commands of the \texttt{l3pdffile} module. This clashes with
% e.g. the embedfile package which should not be used!
%
%
%   \paragraph{Entries at the top level of the catalog}
%   The Names in the following tabular are entries that are added to the
%   top level of the catalog.
%
%   If \meta{Name} gets assigned a value more than once the last one wins.
%   There is no check that the values have the correct type and format.
%   It is up to the user to ensure that the value does what is intended.
%
%   The required PDF version is only mentioned if it is larger than 1.5.
%
%   Example: |\pdfdict_gput:nnn {Catalog}{PageMode}{/UseNone}|
%
%% !!!!!!!! Warning for unknown names is currently not working!
%   \medskip
%   \noindent
%   \begin{tabularx}{\linewidth}{ll>{\raggedright\arraybackslash}X}
%    \bfseries Name           &  \bfseries Value  & \bfseries Remark \\\midrule
%    Collection              &  objref or dict     & the content should be
%     build by external packages (see eg embedfile)                   \\
%    DPartRoot               &  objref or dict     & PDF 2.0           \\
%    Lang                    &  string             & e.g. \texttt{(de-DE)} \\
%    Legal                   &  objref or dict                             \\
%    Metadata                &  obj ref or stream                       \\
%    NeedsRendering          &  boolean            &   PDF 1.7\\
%    OpenAction              &  array (dest) or dict (action) \\
%    PageLabels              &  objref or dict     &  number tree \\
%    PageLayout              &  name               & one of /SinglePage, /OneColumn,
%                                        /TwoColumnLeft, /TwoColumnRight,
%                                        /TwoPageLeft,
%                                        /TwoPageRight \\
%    PageMode                &  name               & one of /UseNone, /UseOutlines, /UseThumbs,
%                                    /UseOC, /UseAttachments (PDF 1.6)\\
%    Perms                   &  objref or dict     & permissions\\
%    PieceInfo               &  objref or dict \\
%    SpiderInfo              &  objref or dict \\
%    StructTreeRoot          &  obj ref or dict \\
%    Threads                 &  objref to an array\\
%    URI                     &  objref or dict \\
%    Version                 &  name           & eg. \texttt{/1.7} \\
%    \meta{unknown}          &                 & an unknown \meta{name} will be
%                                                inserted without a warning.\\
%   \end{tabularx}
%   \par\medskip
%
%   \paragraph{Simple entries in subdictionaries of the catalog}
%   The following dictionaries have been predeclared and allow to
%   add values to the respective subdictionaries of the catalog. The
%   names of the dictionaries follow the naming and location of the dictionaries
%   in the PDF reference.
%   If \meta{Name} gets assigned two values the last one wins.
%
%   Example: |\pdfdict_gput:nnn {Catalog/MarkInfo}{Marked}{true}|
%
%   \medskip
%   \noindent
%   \begin{tabularx}{\linewidth}{llll>{\raggedright\arraybackslash}X}
%    \bfseries Dictionary    & \bfseries Names & \bfseries Value  & \bfseries Remark
%    \\\midrule
%    Catalog/AA              &WC, WS, DS, WP,DP& all dict    \\
%    Catalog/AcroFrom        &  NeedAppearances&  boolean & In pdf 2.0
%                                                           NeedAppearances
%                                                           is deprecated,
%                                                           it is then required
%                                                           that every widget has
%                                                           an appearance streams.\\
%                            &  SigFlags       & Integer\\
%                            &  DA             & String \\
%                            &  Q              & Integer\\
%                            &  XFA            & stream or array & pdf 1.5\\
%  Catalog/AcroForm/DR       & \meta{name}     &            & probably unneeded \\
%  Catalog/AcroForm/DR/Font  & \meta{name}     & dict       & \\
%  Catalog/MarkInfo          & Marked          & boolean      \\
%                            & UserProperties  & boolean      \\
%                            & Suspects        & boolean      \\
%  Catalog/ViewerPreferences & HideToolbar     & boolean      \\
%                            & Direction       & /R2L or /L2R \\
%                            & \ldots          &              & many more, see the reference \\
% \end{tabularx}
%
%
% \paragraph{Catalog entries with multiple values in arrays}
% The following entries are special: Their values are arrays and
% it must be possible to append to such arrays. This means that a new
% call to set this value doesn't replace the value but appends it.
% The value is an object reference. It is sensible to declare the object
% first. E.g.
%  \begin{verbatim}
%  \pdf_object_new:nn   {pkg@intent}{dict}
%  \pdf_object_write:nn {pkg@intent}{...}
%  \pdfdict_gput:nnx  {Catalog} {OutputIntents}{\pdf_object_ref:n {pkg@intent}}
%  \end{verbatim}
%
%  or
%  \begin{verbatim}
%  \pdf_object_now:nn   {dict} { ... }
%  \pdfdict_gput:nnx  {Catalog} {OutputIntents}{\pdf_object_last:}
%  \end{verbatim}
%
%
%   \medskip
%   \noindent
%   \begin{tabularx}{\linewidth}{lll>{\raggedright\arraybackslash}X}
%    \bfseries Dictionary &\bfseries Name        & \bfseries Value   & \bfseries Remark \\\midrule
%    Catalog/AcroForm     & Fields               & object reference\\
%    Catalog/AcroForm     & CO                   & object reference\\
%    Catalog              & AF                   & object reference\\
%    Catalog/OCProperties & OCGs                 & object reference  &if there are OCProperties, OCGs and D are required.\\
%    Catalog/OCProperties & Configs              & object reference \\
%    Catalog/OCProperties & D                    & object reference & This actually a single value as
%                                         there can be only one default.
%                                         If the value is set twice, the
%                                         second wins, and the first is
%                                         added to OCProperties/Configs.\\
%    Catalog              & OutputIntents        & object reference\\
%    Catalog              & Requirements         & object reference & PDF 1.7 \\
%   \end{tabularx}
%
%
% \begin{variable}[added=2019-08-24]
%     {
%      \c_@@_dict_Catalog_toplevel_clist,
%      \c_@@_dict_Catalog_sub_clist,
%      \c_@@_dict_Catalog_seq_clist,
%     }
%  This variables hold the list of the various types of entries. With it
%  the various \verb=_gput= commands are generated.
%  \end{variable}
%  \begin{macro}{ \@@_catalog_XX_gput:n }
% Various commands to handle subentries and special cases.
%    \begin{macrocode}
\@@_dict_gnew:n {Catalog}

\clist_const:Nn \c_@@_dict_Catalog_toplevel_clist
  {
    Collection,
    DPartRoot,
    Lang,
    Legal,
    Metadata,
    NeedsRendering,
    OCProperties/D,
    OpenAction,
    PageLabels,
    PageLayout,
    PageMode,
    Perms,
    PieceInfo,
    SpiderInfo,
    StructTreeRoot,
    Threads,
    URI,
    Version
  }

\clist_const:Nn \c_@@_dict_Catalog_sub_clist
  {
    AA,
    AcroForm,
    AcroForm/DR,
    AcroForm/DR/Font,
    MarkInfo,
    ViewerPreferences,
    OCProperties
  }

\clist_map_inline:Nn \c_@@_dict_Catalog_sub_clist
  {
    \@@_dict_gnew:n {Catalog/#1}
  }


\clist_const:Nn \c_@@_dict_Catalog_seq_clist
  {
    AF,
    OCProperties/OCGs,
    OCProperties/Configs,
    OutputIntents,
    Requirements,
    AcroForm/Fields,
    AcroForm/CO
  }



\clist_map_inline:Nn \c_@@_dict_Catalog_seq_clist
 {
   \seq_new:c { g_@@_dict_/Catalog/#1_seq } % new name later
   \cs_new_protected:cpn { @@_dict_handler/Catalog/#1_gput:n } ##1
     {
       \seq_gput_right:cn { g_@@_dict_/Catalog/#1_seq } {  ##1  }
     }
 }

\cs_new_protected:cpn { @@_dict_handler/Catalog/OCProperties/D_gput:n } #1
  {
    \seq_gput_left:cn
      { g_@@_dict_/Catalog/OCProperties/Configs_seq }
      {  #1  }
  }
%    \end{macrocode}
% \end{macro}
% \paragraph {Building the catalog: Push order}
% \begin{macro}{\@@_dict_Catalog_gpush:}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_dict_Catalog_gpush:
  {
    \use:c { @@_dict_/Catalog/AA_gpush: }
    \use:c { @@_dict_/Catalog/AcroForm_gpush: }
    \use:c { @@_dict_/Catalog/AF_gpush: }
    \use:c { @@_dict_/Catalog/MarkInfo_gpush: }
    \use:c { @@_dict_/Catalog/OCProperties_gpush: }
    \use:c { @@_dict_/Catalog/OutputIntents_gpush: }
    \use:c { @@_dict_/Catalog/Requirements_gpush: }
    \use:c { @@_dict_/Catalog/ViewerPreferences_gpush: }
    % output the single values:
    \prop_map_function:cN { \@@_dict_gname:n {Catalog} }  \@@_backend_catalog_gput:nn
    % output names tree:
    \use:c { @@_dict_/Catalog/Names/EmbeddedFiles_gpush: }
  }
%    \end{macrocode}
% \end{macro}
% \paragraph{Building catalog entries: AA}
% \begin{macro}{\@@_dict_/Catalog/AA_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_dict_/Catalog/AA_gpush: }
  {
    \prop_if_empty:cF
     { \@@_dict_gname:n { Catalog/AA } }
     {
       \@@_backend_object_new:nn  { g_@@_dict_/Catalog/AA_obj } { dict }
       \@@_backend_object_write:nx
            { g_@@_dict_/Catalog/AA_obj }
            { \@@_dict_map:n { Catalog/AA } }
       \exp_args:Nnx
         \@@_backend_catalog_gput:nn
           {AA}
           {
             \@@_backend_object_ref:n { g_@@_dict_/Catalog/AA_obj }
           }
     }
  }
%    \end{macrocode}
% \end{macro}
% \paragraph{Building catalog entries: AcroFrom}
% This is the most complicated case.
% The entries is build from
% /Catalog/AcroForm/Fields  (array),
% /Catalog/AcroForm/CO      (array),
% /Catalog/AcroForm/DR/Font (dict),
% /Catalog/AcroForm/DR      (dict),
% /Catalog/AcroForm
%
% \begin{macro}{\@@_dict_/Catalog/AcroForm_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_dict_/Catalog/AcroForm_gpush: }
  {
    \seq_if_empty:cF { g_@@_dict_/Catalog/AcroForm/Fields_seq }
      {
        \@@_backend_object_new:nn  { g_@@_dict_/Catalog/AcroForm/Fields_obj } { array }
        \@@_backend_object_write:nx
            { g_@@_dict_/Catalog/AcroForm/Fields_obj }
            { \seq_use:cn { g_@@_dict_/Catalog/AcroForm/Fields_seq } {~} }
        \exp_args:Nnnx
          \prop_gput:cnn %do wewe have to use \prop here to avoid the handler ...
            { \__pdf_dict_Xname:n { Catalog/AcroForm } }
            { Fields }
            { \@@_backend_object_ref:n { g_@@_dict_/Catalog/AcroForm/Fields_obj } }
      }
    \seq_if_empty:cF { g_@@_dict_/Catalog/AcroForm/CO_seq }
      {
        \@@_backend_object_new:nn  { g_@@_dict_/Catalog/AcroForm/CO_obj } { array }
        \exp_args:Nnx
          \@@_backend_object_write:nn
            { g_@@_dict_/Catalog/AcroForm/CO_obj }
            { \seq_use:cn { g_@@_dict_/Catalog/AcroForm/CO_seq } {~} }
        \exp_args:Nnnx
          \prop_gput:cnn %we have to use \prop here to avoid the handler ...
            { \__pdf_dict_Xname:n { Catalog/AcroForm } }
            { CO }
            { \@@_backend_object_ref:n { g_@@_dict_/Catalog/AcroForm/CO_obj } }
      }
     \prop_if_empty:cF { \@@_dict_gname:n { Catalog/AcroForm/DR/Font}}
       {
         \@@_backend_object_new:nn { g_@@_dict_/Catalog/AcroForm/DR/Font_obj } {dict}
         \exp_args:Nnx
           \@@_backend_object_write:nn
             { g_@@_dict_/Catalog/AcroForm/DR/Font_obj }
             { \@@_dict_map:n { Catalog/AcroForm/DR/Font } }
         \exp_args:Nnnx
           \prop_gput:cnn %we have to use \prop here to avoid the handler ...
             { \__pdf_dict_Xname:n { Catalog/AcroForm/DR } }
             { Font }
             { \@@_backend_object_ref:n { g_@@_dict_/Catalog/AcroForm/DR/Font_obj } }
       }
     \prop_if_empty:cF { \@@_dict_gname:n { Catalog/AcroForm/DR}}
       {
         \@@_backend_object_new:nn { g_@@_dict_/Catalog/AcroForm/DR_obj } {dict}
         \exp_args:Nnx
           \@@_backend_object_write:nn
             { g_@@_dict_/Catalog/AcroForm/DR_obj }
             { \@@_dict_map:n { Catalog/AcroForm/DR } }
         \exp_args:Nnnx
           \prop_gput:cnn %we have to use \prop here to avoid the handler ...
             { \__pdf_dict_Xname:n { Catalog/AcroForm } }
             { DR }
             { \@@_backend_object_ref:n { g_@@_dict_/Catalog/AcroForm/DR_obj } }
       }
     \prop_if_empty:cF { \@@_dict_gname:n { Catalog/AcroForm} }
       {
         \@@_backend_object_new:nn { g_@@_dict_/Catalog/AcroForm_obj } {dict}
         \exp_args:Nnx
           \@@_backend_object_write:nn
             { g_@@_dict_/Catalog/AcroForm_obj }
             { \@@_dict_map:n { Catalog/AcroForm } }
         \exp_args:Nnnx
           \@@_dict_handler_put:nnn
             { Catalog }
             { AcroForm }
             { \@@_backend_object_ref:n { g_@@_dict_/Catalog/AcroForm_obj } }
       }
  }

%    \end{macrocode}
% \end{macro}
%
% \paragraph{Building catalog entries: AF}
% AF is an array.
% \begin{macro}{\@@_dict_/Catalog/AF_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_dict_/Catalog/AF_gpush: }
  {
    \seq_if_empty:cF
     { g_@@_dict_/Catalog/AF_seq }
     {
       \@@_backend_object_new:nn  { g_@@_dict_/Catalog/AF_obj } { array }
       \exp_args:Nnx
         \@@_backend_object_write:nn
            { g_@@_dict_/Catalog/AF_obj }
            { \seq_use:cn { g_@@_dict_/Catalog/AF_seq } {~} }
       \exp_args:Nnx
         \@@_backend_catalog_gput:nn
           {AF}
           {
             \@@_backend_object_ref:n {g_@@_dict_/Catalog/AF_obj}
           }
     }
  }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Building catalog entries: MarkInfo}
% \begin{macro}{\@@_dict_/Catalog/MarkInfo_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_dict_/Catalog/MarkInfo_gpush: }
  {
    \prop_if_empty:cF
     { \@@_dict_gname:n { Catalog/MarkInfo } }
     {
       \@@_backend_object_new:nn  { g_@@_dict_/Catalog/MarkInfo_obj } { dict }
       \exp_args:Nnx
         \@@_backend_object_write:nn
            { g_@@_dict_/Catalog/MarkInfo_obj }
            { \@@_dict_map:n {Catalog/MarkInfo } }
       \exp_args:Nnx
         \@@_backend_catalog_gput:nn
           {MarkInfo}
           {
             \@@_backend_object_ref:n {g_@@_dict_/Catalog/MarkInfo_obj}
           }
     }
  }
%    \end{macrocode}
% \end{macro}
%\paragraph{Building catalog entries: OCProperties}
%  This is a dictionary with three entries:
%  \begin{description}
%  \item[/OCGs] (required) An array of indirect references,
%               access needed for more than one package.
%  \item[/D] (required) a dict (given as an object name) to the default
%            configuration
%  \item[/Configs] (optional) an array of indirect references to more
%        configurations.
%  \end{description}
%  The /D entry is also a config, it is the first of the seq.
%  The overall structure is nested: a dict with arrays.
% \begin{macro}{\@@_dict_/Catalog/OCProperties_gpush:}
%    \begin{macrocode}
% Catalog/OCProperties: OCGs + D is required
\cs_new_protected:cpn { @@_dict_/Catalog/OCProperties_gpush: }
  {
   \int_compare:nNnT
      {
        ( \seq_count:c { g_@@_dict_/Catalog/OCProperties/OCGs_seq }  )*
        ( \seq_count:c { g_@@_dict_/Catalog/OCProperties/Configs_seq } )
      }
      >
      { 0 }
      {
        \@@_backend_object_new:nn  { g_@@_dict_/Catalog/OCProperties_obj } { dict }
        \seq_gpop_left:cN { g_@@_dict_/Catalog/OCProperties/Configs_seq} \l_tmpa_tl
        \exp_args:Nnx
          \@@_backend_object_write:nn {g_@@_dict_/Catalog/OCProperties_obj}
            {
              /OCGs~[ \seq_use:cn { g_@@_dict_/Catalog/OCProperties/OCGs_seq } {~} ]
              /D~\l_tmpa_tl~
              \seq_if_empty:cF { g_@@_dict_/Catalog/OCProperties/Configs_seq }
                {
                  /Configs~
                  [ \seq_use:cn { g_@@_dict_/Catalog/OCProperties/Configs_seq} {~} ]
                }
            }
        \exp_args:Nnx
          \@@_backend_catalog_gput:nn
            { OCProperties }
            { \@@_backend_object_ref:n {g_@@_dict_/Catalog/OCProperties_obj} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Building catalog entries: OutputIntents}
% OutputIntents is an array.
% \begin{macro}{\@@_dict_/Catalog/OutputIntents_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_dict_/Catalog/OutputIntents_gpush: }
  {
    \seq_if_empty:cF
     { g_@@_dict_/Catalog/OutputIntents_seq }
     {
       \@@_backend_object_new:nn  { g_@@_dict_/Catalog/OutputIntents_obj } { array }
       \exp_args:Nnx
         \@@_backend_object_write:nn
            { g_@@_dict_/Catalog/OutputIntents_obj }
            { \seq_use:cn { g_@@_dict_/Catalog/OutputIntents_seq } {~} }
       \exp_args:Nnx
         \@@_backend_catalog_gput:nn
           {OutputIntents}
           {
             \@@_backend_object_ref:n {g_@@_dict_/Catalog/OutputIntents_obj}
           }
     }
  }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Building catalog entries: Requirements}
% Requirements  is an array.
% \begin{macro}{\@@_dict_/Catalog/Requirements _gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_dict_/Catalog/Requirements _gpush: }
  {
    \seq_if_empty:cF
     { g_@@_dict_/Catalog/Requirements _seq }
     {
       \@@_backend_object_new:nn  { g_@@_dict_/Catalog/Requirements _obj } { array }
       \exp_args:Nnx
         \@@_backend_object_write:nn
            { g_@@_dict_/Catalog/Requirements_obj }
            { \seq_use:cn { g_@@_dict_/Catalog/Requirements_seq } {~} }
       \exp_args:Nnx
         \@@_backend_catalog_gput:nn
           {Requirements}
           {
             \@@_backend_object_ref:n { g_@@_dict_/Catalog/Requirements_obj }
           }
     }
  }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Building catalog entries: ViewerPreferences}
% \begin{macro}{\@@_dict_/Catalog/ViewerPreferences_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_dict_/Catalog/ViewerPreferences_gpush: }
  {
    \prop_if_empty:cF
     { \@@_dict_gname:n { Catalog/ViewerPreferences } }
     {
       \@@_backend_object_new:nn  { g_@@_dict_/Catalog/ViewerPreferences_obj } { dict }
       \exp_args:Nnx
         \@@_backend_object_write:nn
            { g_@@_dict_/Catalog/ViewerPreferences_obj }
            { \@@_dict_map:n {Catalog/ViewerPreferences } }
       \exp_args:Nnx
         \@@_backend_catalog_gput:nn
           {ViewerPreferences}
           {
             \@@_backend_object_ref:n {g_@@_dict_/Catalog/ViewerPreferences_obj}
           }
     }
  }
%    \end{macrocode}
% \end{macro}
% \paragraph{Building catalog entries: Names/EmbeddedFiles}
% The entry should only be added if there are actually embedded files.
% This can be tested by checking the names_seq
% \begin{macro}{\@@_dict_/Catalog/Names/EmbeddedFiles_gpush:}
%    \begin{macrocode}
\seq_new:N \g_@@_file_tree_name_seq
\cs_new_protected:cpn { @@_dict_/Catalog/Names/EmbeddedFiles_gpush: }
  {
    \seq_if_empty:NF \g_@@_file_tree_name_seq
      {
        \exp_args:Nx \@@_backend_NamesEmbeddedFiles_gpush:n
          {
            \seq_use:Nn \g_@@_file_tree_name_seq {~}
          }
      }
  }
%
% \subsection{Local dictonaries}
%
% All dictionaries described above were global dictionaries and basically they
% are written at most once (or at most once per page) to the PDF. The pdfdict module
% predefines also a number of local dictionaries. These are used in objects like
% link annotations (see the pdfannot module) which are written in varying
% numbers to the PDF and allow to set their features and change them locally
% if needed. The predefined dictionaries are
%
% \begin{tabular}{lp{6cm}}
%  \multicolumn{2}{l}{annotation related: here are
%                     \texttt{Border} and \texttt{C} (color)}\\
%  annot/Link/Goto   & used in GoTo links (internal references) \\
%  annot/Link/URI    & used in URI links (external uri references) \\
%  annot/Link/GotoR  & used in GoToR links (file  references) \\
%  annot/Link/Named  & used in Named actions (menu calls) \\
%  annot/Link/Launch & used in Launch links (application calls) \\
% \end{tabular}
% \section{Various PDF contents}
% The following commands allow to create a number of important pdf objects and contents in a
% backend independant way.
%
% \subsection{BDC operator / Properties resource}
% \begin{NOTE}{UF}
%  we still need a switch for the case that the resource should be added to
%  xform resource instead of a page resources, see pdfbase.sty
% - xdvipdfmx: looks fine, the resource is added to the xform resource automatically
% - pdftex should now work okay too
% \end{NOTE}
% Entries to the /Properties dictionary in the page resources can
% be added with dvips only through side-effects: if a BDC-mark is created
% dvips/ghostscript will automatically create the necessary objects and names.
% To get a sensible abstraction the code does the same for the other backends:
% There are no public commands to add values to the /Properties dictionary
% directly, only commands to set BDC-marks.
% \begin{function}[added = 2019-06-29]
%   {
%     \pdf_bdc:nn
%   }
%   \begin{syntax}
%     \cs{pdf_bdc:nn} \Arg{tag} \Arg{object name}
%   \end{syntax}
%    This command adds a BDC marked content operator to the current page stream.
%   \meta{tag} is the tag of this operator (without the leading slash),
%   \meta{object name}  is a the name of an dictionary object reserved with
%   \cs{pdf_object_new:nn} and filled with \cs{pdf_object_write:n} with
%   the properties of the BDC.
% \end{function}
% \begin{function}[added = 2019-10-18]
%   {
%     \pdf_bdc:n
%   }
%   \begin{syntax}
%     \cs{pdf_bdc:n} \Arg{tag}
%   \end{syntax}
%    This command adds a BDC marked content operator to the current page stream.
%   \meta{tag} is the tag of this operator (without the leading slash).
%   As object this commands uses the last anonymous dictionary object created with
%   \cs{pdf_object_now:nn}. It lies in the responsibility of the user that the last
%   object is the wanted one.
% \end{function}
% \begin{function}[added = 2019-10-17]
%   {
%     \pdf_bmc:n
%   }
%   \begin{syntax}
%     \cs{pdf_bmc:n} \Arg{tag}
%   \end{syntax}
%    This command created a BMC marked content operator. The argument is the
%    tag without the leading slash. It can be e.g. used for simple artifact
%    markers.
% \end{function}
% \begin{function}[added = 2019-06-30]
%   {
%     \pdf_emc:
%   }
%   \begin{syntax}
%     \cs{pdf_emc:}
%   \end{syntax}
%    This command closes the  BDC marked content operator opened with \cs{pdf_bdc:nn}.
%    It should be one the same page as the bdc-command.
%
%   \begin{verbatim}
%   \pdf_object_new:nn   {objA}{dict}
%   \pdf_object_write:nn {objA}{/Type/Artifact}
%   \pdf_bdc:nn {Span}{objA}
%   text
%   \pdf_emc:
%   \end{verbatim}
% \end{function}
%
% \subsubsection{BDC and Properties / backend}
% \begin{macro}
%   {
%     \@@_backend_bdc:nn,
%     \@@_backend_bdc:n,
%     \@@_backend_bmc:n,
%     \@@_backend_emc:,
%     \@@_backend_PageResources_gpush:n
%   }
% \cs{@@_backend_bdc:nn}, \cs{@@_backend_bmc:n} and \cs{@@_backend_emc:}
%  are the backend command that
%  create the bdc/emc marker and store the properties.
% \cs{@@_backend_PageResources_gpush:n} outputs the /Properties in
% \cs{@@_BACKEND_thispage_shipout_gput:n} for the current page.
%    \begin{macrocode}
% pdftex and luatex (and perhaps dvips ...) need to know if there are in a
% xform stream ...
\bool_new:N \l_@@_backend_xform_bool
\@@_dict_gnew:n {xform/Resources/Properties}

% dvips
% dvips is easy: create an object, and reference it in the bdc
% ghostscript will then automatically replace it by a name
% and add the name to the /Properties dict
% special variant von accsupp https://chat.stackexchange.com/transcript/message/50831812#50831812
\bool_if:nT {\sys_if_engine_pdftex_p: && !\sys_if_output_pdf_p: }
  {
    \cs_set_protected:Npn \@@_backend_bdc:nn #1 #2 % #1 eg. Span, #2: object name
      {
        \special {ps:~mark~/#1~\@@_backend_object_ref:n{#2}~/BDC~pdfmark}
      }
    \cs_set_protected:Npn \@@_backend_bdc:n #1  % #1 eg. Span,
      {
        \special {ps:~mark~/#1~\@@_backend_object_last:~/BDC~pdfmark}
      }
    \cs_set_protected:Npn \@@_backend_emc:
      {
        \special {ps:~mark~/EMC~pdfmark} %
      }
    \cs_set_protected:Npn \@@_backend_bmc:n #1
      {
        \special {ps:~mark~/#1~/BMC~pdfmark} %
      }
    \cs_new_protected:Npn \@@_backend_PageResources_gpush:n #1 {}
 }
% xetex has to create the entries in the /Properties manually
% (like the other backends)
% use pdfbase special
% https://chat.stackexchange.com/transcript/message/50832016#50832016
% the property is added to xform resources automatically,
% no need to worry about it.
\sys_if_engine_xetex:T
  {
    \cs_set_protected:Npn \@@_backend_bdc:nn #1 #2 % #1 eg. Span, #2: object name
      {
        \int_gincr:N \g_@@_backend_name_int
        \__kernel_backend_literal:x
          {
            pdf:code~/#1/l3pdf\int_use:N\g_@@_backend_name_int\c_space_tl BDC
          }
        \__kernel_backend_literal:x
          {
            pdf:put~@resources~
              <<
                /Properties~
                  <<
                    /l3pdf\int_use:N\g_@@_backend_name_int\c_space_tl
                    \@@_backend_object_ref:n { #2 }
                  >>
              >>
          }
      }
    \cs_set_protected:Npn \@@_backend_bdc:n #1  % #1 eg. Span
      {
        \int_gincr:N \g_@@_backend_name_int
        \__kernel_backend_literal:x
          {
            pdf:code~/#1/l3pdf\int_use:N\g_@@_backend_name_int\c_space_tl BDC
          }
        \__kernel_backend_literal:x
          {
            pdf:put~@resources~
              <<
                /Properties~
                  <<
                    /l3pdf\int_use:N\g_@@_backend_name_int\c_space_tl
                    \@@_backend_object_last:
                  >>
              >>
          }
      }
 \cs_set_protected:Npn \@@_backend_bmc:n #1
    {
      \__kernel_backend_literal:n {pdf:code~/#1~BMC}  %pdfbase
    }
  \cs_set_protected:Npn \@@_backend_emc:
    {
      \__kernel_backend_literal:n {pdf:code~EMC}  %pdfbase
    }
  % properties are handled automatically, but the other resources should be added
  % at shipout
  \cs_new_protected:Npn \@@_backend_PageResources_gpush:n #1
    {
      \clist_map_inline:Nn \c_@@_backend_PageResources_clist
        {
          \prop_if_empty:cF { \@@_dict_gname:n {Page/Resources/##1} }
            {
              \__kernel_backend_literal:x
                {
                  pdf:put~@resources~
                    <</##1~\@@_backend_object_ref:n {Page/Resources/##1}>>
                }
            }
        }
    }
 }
% luatex
\sys_if_engine_luatex:T
  {
    \cs_set_protected:Npn \@@_backend_bdc:nn #1 #2 % #1 eg. Span, #2: object name
      {
        \int_gincr:N \g_@@_backend_name_int
        \exp_args:Nx\__kernel_backend_literal_page:n
          { /#1 ~ /l3pdf\int_use:N\g_@@_backend_name_int\c_space_tl BDC }
        \bool_if:NTF \l_@@_backend_xform_bool
          {
            \exp_args:Nnx\@@_dict_handler_put:nnn
              { xform/Resources/Properties }
              { l3pdf\int_use:N\g_@@_backend_name_int }
              { \@@_backend_object_ref:n { #2 } }
          }
          {
            \exp_args:Nx \tex_latelua:D
              {
                l3kernel.pdf.Page_Resources_Properties_gput
                  (
                    tex.count["g_shipout_readonly_int"],
                    "l3pdf\int_use:N\g_@@_backend_name_int",
                    "\@@_backend_object_ref:n { #2 }"
                  )
              }
          }
    }
    \cs_set_protected:Npn \@@_backend_bdc:n #1% #1 eg. Span
      {
        \int_gincr:N \g_@@_backend_name_int
        \exp_args:Nx\__kernel_backend_literal_page:n
          { /#1 ~ /l3pdf\int_use:N\g_@@_backend_name_int\c_space_tl BDC }
        \bool_if:NTF \l_@@_backend_xform_bool
          {
            \@@_dict_handler_put:nxx
              { xform/Resources/Properties }
              { l3pdf\int_use:N\g_@@_backend_name_int }
              { \@@_backend_object_last: }
          }
          {
            \exp_args:Nx \tex_latelua:D
              {
                l3kernel.pdf.Page_Resources_Properties_gput
                  (
                    tex.count["g_shipout_readonly_int"],
                    "l3pdf\int_use:N\g_@@_backend_name_int",
                    "\@@_backend_object_last:"
                  )
              }
          }
    }
   \cs_set_protected:Npn \@@_backend_bmc:n #1
      {
        \__kernel_backend_literal_page:n { /#1~BMC }
      }
    \cs_set_protected:Npn \@@_backend_emc:
      {
        \__kernel_backend_literal_page:n { EMC }
      }

    \cs_new_protected:Npn \@@_backend_PageResources_gpush:n #1 {}
  }

% pdflatex is the most complicated as it has to go through the aux ...
% the push command is extended to take other resources too
\bool_if:nT {\sys_if_engine_pdftex_p: && \sys_if_output_pdf_p: }
  {
    \cs_set_protected:Npn \@@_backend_bdc:nn #1 #2 % #1 eg. Span, #2: object name
      {
        \int_gincr:N \g_@@_backend_name_int
        \exp_args:Nx\__kernel_backend_literal_page:n
          { /#1 ~ /l3pdf\int_use:N\g_@@_backend_name_int\c_space_tl BDC }
        % code to set the property ....
        \int_gincr:N\g_@@_backend_resourceid_int
        \bool_if:NTF \l_@@_backend_xform_bool
          {
            \@@_dict_handler_put:nxx
              { xform/Resources/Properties }
              { l3pdf\int_use:N\g_@@_backend_resourceid_int }
              { \@@_backend_object_ref:n { #2 } }
          }
          {
            \zref@labelbylist
              { l3pdf\int_use:N\g_@@_backend_resourceid_int }
              { l3pdf }
            \tl_set:Nx \l_@@_tmpa_tl
              {
                \zref@extractdefault
                  { l3pdf\int_use:N\g_@@_backend_resourceid_int }
                  {pdf@abspage}
                  {0}
              }
            \@@_dict_if_exist:nF { backend_Page\l_@@_tmpa_tl/Resources/Properties }
              {
                \@@_dict_gnew:n  { backend_Page\l_@@_tmpa_tl/Resources/Properties }
              }
            \@@_dict_handler_put:nxx
              { backend_Page\l_@@_tmpa_tl/Resources/Properties }
              { l3pdf\int_use:N\g_@@_backend_resourceid_int }
              { \@@_backend_object_ref:n{#2} }
          }
      }
    \cs_set_protected:Npn \@@_backend_bdc:n #1% #1 eg. Span
      {
        \int_gincr:N \g_@@_backend_name_int
        \exp_args:Nx\__kernel_backend_literal_page:n
          { /#1 ~ /l3pdf\int_use:N\g_@@_backend_name_int\c_space_tl BDC }
        % code to set the property ....
        \int_gincr:N\g_@@_backend_resourceid_int
        \bool_if:NTF \l_@@_backend_xform_bool
          {
            \@@_dict_handler_put:nxx
              { xform/Resources/Properties }
              { l3pdf\int_use:N\g_@@_backend_resourceid_int }
              { \@@_backend_object_last: }
          }
          {
            \zref@labelbylist
              { l3pdf\int_use:N\g_@@_backend_resourceid_int }
              { l3pdf }
            \tl_set:Nx \l_@@_tmpa_tl
              {
                \zref@extractdefault
                  { l3pdf\int_use:N\g_@@_backend_resourceid_int }
                  {pdf@abspage}
                  {0}
              }
            \@@_dict_if_exist:nF { backend_Page\l_@@_tmpa_tl/Resources/Properties }
              {
                \@@_dict_gnew:n { backend_Page\l_@@_tmpa_tl/Resources/Properties }
              }
            \@@_dict_handler_put:nxx
              { backend_Page\l_@@_tmpa_tl/Resources/Properties }
              { l3pdf\int_use:N\g_@@_backend_resourceid_int }
              { \@@_backend_object_last: }
            %\@@_dict_show:n { backend_Page\l_@@_tmpa_tl/Resources/Properties }
          }
      }
  \cs_set_protected:Npn \@@_backend_bmc:n #1
    {
      \__kernel_backend_literal_page:n { /#1~BMC }
    }
  \cs_set_protected:Npn \@@_backend_emc:
    {
      \__kernel_backend_literal_page:n { EMC }
    }

  \cs_new:Npn \@@_backend_PageResources_gpush_aux:n #1 %#1 ExtGState etc
    {
      \prop_if_empty:cF
        { \@@_dict_gname:n {Page/Resources/#1} }
        {
          \@@_dict_objref_item:nn { #1 }{Page/Resources/#1}
        }
    }

  \cs_new_protected:Npn \@@_backend_PageResources_gpush:n #1
    {
       \exp_args:NNx \tex_global:D \tex_pdfpageresources:D
         {
           \prop_if_exist:cT
             { \@@_dict_gname:n  { backend_Page#1/Resources/Properties } }
             {
               /Properties~
                 <<
                   \prop_map_function:cN
                     { \@@_dict_gname:n  { backend_Page#1/Resources/Properties } }
                     \@@_dict_item:ne
                 >>
             }
           %% add ExtGState etc
           \clist_map_function:NN
             \c_@@_backend_PageResources_clist
             \@@_backend_PageResources_gpush_aux:n
         }
    }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{BDC and Properties  / management}
%    \begin{macrocode}
\cs_new_protected:Npn  \pdf_bdc:nn #1 #2 { \@@_backend_bdc:nn { #1 }{ #2 } }
\cs_new_protected:Npn  \pdf_bdc:n #1     { \@@_backend_bdc:n  { #1 } }
\cs_new_protected:Npn  \pdf_bmc:n #1     { \@@_backend_bmc:n  { #1 } }
\cs_new_protected:Npn  \pdf_emc:         { \@@_backend_emc: }
%    \end{macrocode}
%
% \subsection{Form XObject (pdfxform)}
% \begin{NOTE}{UF}
%  - As in dvi mode the xform is immediate, this is done for pdftex/luatex too.
%    If needed a delayed version can be added later.
%  - the argument for attributes is needed to add e.g. /StructParents
%  - it is not clear if an argument for additional resources is needed, probably they
%    should / need to be added automatically.
%  - code for adding ExtGState etc to the local resource is missing, will be
%    added when the object name is clear.!!!!!!!!!!!!
%  - should the size be stored in dim or tl?
%  - dvips implementation is missing for ideas: pdfbase, atfi-dvips.def,
%  \end{NOTE}
%
%  \subsubsection{Form XObject / management}
%  \begin{function}[added = 2019-08-05]
%   {
%     \pdf_xform_new:nnn
%   }
%   \begin{syntax}
%     \cs{pdf_xform_new:nnn} \Arg{name} \Arg{attributes} \Arg{content}
%   \end{syntax}
%    This command create a new form XObject that can be used as appearance or
%    directly later.
%    If the content contains BDC-marks it should \emph{not} be given as a
%    previously typeset box, but directly so that the names of the
%    BDC-marks can be added to the resources of the xform. The xform will automatically
%    include the resources of the current page.
%    The content will be typeset in a hbox. With pdflatex and luatex
%    the surrounding color is \emph{not} stored in the XObject
%    but should be if wanted added e.g. with |\color_select:n{.}|. This keeps
%    the option of color injection open.
%   \end{function}
%   \begin{function}[added = 2019-08-05]
%     {
%      \pdf_xform_use:n
%     }
%   \begin{syntax}
%     \cs{pdf_xform_use:n} \Arg{name}
%   \end{syntax}
%    This command uses (typesets) a previously created form XObject.
%    If the surrounding color is different, it is injected in the XObject with the
%    engines pdftex or luatex.
%   \end{function}
%   \begin{function}[EXP,added = 2019-08-05]
%     {
%       \pdf_xform_ref:n
%     }
%   \begin{syntax}
%     \cs{pdf_xform_ref:n} \Arg{name}
%   \end{syntax}
%   Inserts the appropriate information to reference the xform \meta{name}
%   in for example appearance dictionaries.
%   \end{function}
%   \begin{function}[EXP,added = 2019-08-05]
%     {
%       \pdf_xform_wd:n, \pdf_xform_ht:n, \pdf_xform_dp:n
%     }
%   \begin{syntax}
%     \cs{pdf_xform_wd:n} \Arg{name}
%   \end{syntax}
%    These command give back the sizes of the XObject. The values are stored in
%    tl-variables with the unit pt and not in dimensions!
%   \end{function}
%   \begin{function}[EXP,pTF,added = 220-04-29]
%     {
%       \pdf_xform_if_exist:n
%     }
%   \begin{syntax}
%     \cs{pdf_xform_if_exist_p:n} \Arg{name}
%     \cs{pdf_xform_if_exist:NTF} \meta{name} \Arg{true code} \Arg{false code}
%   \end{syntax}
%    These command tests if an xform with name \Arg{name} has been already defined.
%   \end{function}%
%    \begin{macrocode}
\cs_new_protected:Npn  \pdf_xform_new:nnn #1 #2 #3
  {
    \@@_backend_xform_new:nnnn { #1 } { #2 } {  } { #3 }
  }

\cs_new_protected:Npn \pdf_xform_use:n #1
  {
    \@@_backend_xform_use:n { #1 }
  }
% expansion?
\cs_new:Npn \pdf_xform_ref:n #1
  {
    \@@_backend_xform_ref:n { #1 }
  }

\cs_generate_variant:Nn \pdf_xform_ref:n {o}

\cs_new:Npn \pdf_xform_wd:n #1
  {
    \tl_use:c { c_@@_backend_xform_wd_ \tl_to_str:n { #1 } _tl }
  }

\cs_new:Npn \pdf_xform_ht:n #1
  {
    \tl_use:c { c_@@_backend_xform_ht_ \tl_to_str:n { #1 } _tl }
  }

\cs_new:Npn \pdf_xform_dp:n #1
  {
    \tl_use:c { c_@@_backend_xform_dp_ \tl_to_str:n { #1 } _tl }
  }

%    \end{macrocode}
%
%  \subsubsection{Form XObject / backend }
%  \begin{macro}{ \@@_backend_xform_new:nnnn }
%  \begin{arguments}
%  \item name
%  \item attributes
%  \item resources %needed?? or are all resources autogenerated?
%  \item content, this doesn't need to be a box!
%  \end{arguments}
%  \begin{macro}{ \@@_backend_xform_use:n, \@@_backend_xform_ref:n }
%    \begin{macrocode}
%%pdftex
\bool_if:nT {\sys_if_engine_pdftex_p: && \sys_if_output_pdf_p: }
  {
    \cs_new_protected:Npn \@@_backend_xform_new:nnnn #1 #2 #3 #4
    % #1 name
    % #2 attributes
    % #3 resources
    % #4 content, not necessarily a box!
      {
        \hbox_set:Nn \l_@@_tmpa_box
          {
            \bool_set_true:N \l_@@_backend_xform_bool
            \@@_dict_clear:n {xform/Resources/Properties}
            #4
          }
        %store the dimensions
        \tl_const:cx
          { c_@@_backend_xform_wd_ \tl_to_str:n {#1} _tl }
          { \tex_the:D \box_wd:N \l_@@_tmpa_box }
        \tl_const:cx
          { c_@@_backend_xform_ht_ \tl_to_str:n {#1} _tl }
          { \tex_the:D \box_ht:N \l_@@_tmpa_box }
        \tl_const:cx
          { c_@@_backend_xform_dp_ \tl_to_str:n {#1} _tl }
          { \tex_the:D \box_dp:N \l_@@_tmpa_box }
        %% do we need to test if #2 and #3 are empty??
        \tex_immediate:D \tex_pdfxform:D
          ~  attr      ~ { #2 }
        %% which other resources should be default? Is an argument actually needed?
          ~  resources ~
          {
            #3
            \int_compare:nNnT
              { \prop_count:c { \@@_dict_gname:n {xform/Resources/Properties} } }
              >
              { 0 }
              {
                /Properties~
                  <<
                    \@@_dict_map:n {xform/Resources/Properties}
                  >>
              }

            \prop_if_empty:cF
              { \@@_dict_gname:n {Page/Resources/ExtGState} }
              {
                /ExtGState~ \pdf_object_ref:n {Page/Resources/ExtGState}
              }
            \prop_if_empty:cF
              { \@@_dict_gname:n {Page/Resources/Pattern} }
              {
                /Pattern~ \pdf_object_ref:n {Page/Resources/Pattern}
              }
            \prop_if_empty:cF
              { \@@_dict_gname:n {Page/Resources/Shading} }
              {
                /Shading~ \pdf_object_ref:n {Page/Resources/Shading}
              }
            \prop_if_empty:cF
              { \@@_dict_gname:n {Page/Resources/ColorSpace} }
              {
                /ColorSpace~ \pdf_object_ref:n {Page/Resources/ColorSpace}
              }
          }
          \l_@@_tmpa_box
       \int_const:cn
         { c_@@_backend_xform_ \tl_to_str:n {#1} _int }
         { \tex_pdflastxform:D }
      }

  \cs_new_protected:Npn \@@_backend_xform_use:n #1
    {
      \tex_pdfrefxform:D
        \int_use:c { c_@@_backend_xform_ \tl_to_str:n {#1} _int }
        \scan_stop:
    }

  \cs_new:Npn \@@_backend_xform_ref:n #1
    {
      \int_use:c { c_@@_backend_xform_ \tl_to_str:n {#1} _int } ~ 0 ~ R
    }
  }

%luatex
%nearly identical but not completely ...
\sys_if_engine_luatex:T
  {
    \cs_new:Npn \@@_backend_xform_new:nnnn #1 #2 #3 #4
    % #1 name
    % #2 attributes
    % #3 resources
    % #4 content, not necessarily a box!
      {
        \hbox_set:Nn \l_@@_tmpa_box
          {
            \bool_set_true:N \l_@@_backend_xform_bool
            \@@_dict_clear:n {xform/Resources/Properties}
            #4
          }
        \tl_const:cx
          { c_@@_backend_xform_wd_ \tl_to_str:n {#1} _tl }
          { \tex_the:D \box_wd:N \l_@@_tmpa_box }
        \tl_const:cx
          { c_@@_backend_xform_ht_ \tl_to_str:n {#1} _tl }
          { \tex_the:D \box_ht:N \l_@@_tmpa_box }
        \tl_const:cx
          { c_@@_backend_xform_dp_ \tl_to_str:n {#1} _tl }
          { \tex_the:D \box_dp:N \l_@@_tmpa_box }
        %% do we need to test if #2 and #3 are empty??
        \tex_immediate:D \tex_pdfxform:D
          ~  attr      ~ { #2 }
          %% which resources should be default? Is an argument actually needed?
          ~  resources ~
          {
            #3
            \int_compare:nNnT
              {\prop_count:c { \@@_dict_gname:n {xform/Resources/Properties} }}
              >
              { 0 }
              {
                /Properties~
                  <<
                    \@@_dict_map:n {xform/Resources/Properties}
                  >>
              }
            \prop_if_empty:cF
              { \@@_dict_gname:n {Page/Resources/ExtGState} }
              {
                /ExtGState~ \pdf_object_ref:n {Page/Resources/ExtGState}
              }
            \prop_if_empty:cF
              { \@@_dict_gname:n {Page/Resources/Pattern} }
              {
                /Pattern~ \pdf_object_ref:n {Page/Resources/Pattern}
              }
            \prop_if_empty:cF
              { \@@_dict_gname:n {Page/Resources/Shading} }
              {
                /Shading~ \pdf_object_ref:n {Page/Resources/Shading}
              }
            \prop_if_empty:cF
              { \@@_dict_gname:n {Page/Resources/ColorSpace} }
              {
                /ColorSpace~ \pdf_object_ref:n {Page/Resources/ColorSpace}
              }
          }
          \l_@@_tmpa_box
          \int_const:cn
            { c_@@_backend_xform_ \tl_to_str:n {#1} _int }
            { \tex_pdflastxform:D }
      }

    \cs_new:Npn \@@_backend_xform_use:n #1
      {
        \tex_pdfrefxform:D \int_use:c
          {
            c_@@_backend_xform_ \tl_to_str:n {#1} _int
          }
          \scan_stop:
      }

    \cs_new:Npn \@@_backend_xform_ref:n #1
      { \int_use:c { c_@@_backend_xform_ \tl_to_str:n {#1} _int } ~ 0 ~ R }
  }


\sys_if_engine_xetex:T
  {
   % it needs a bit testing if it really works to set the box to 0 before the special ...
   % does it disturb viewing the xobject?
   % what happens with the resources (bdc)? (should work as they are specials too)
   % xetex requires that the special is in horizontal mode. This means it affects
   % typesetting. But we can no delay the whole form code to shipout
   % as the object reference and the size is often wanted on the current page.
   % so we need to allocate a box - but probably they won't be thousands xform
   % in a document so it shouldn't matter.
    \cs_new:Npn \@@_backend_xform_new:nnnn #1 #2 #3 #4
    % #1 name
    % #2 attributes
    % #3 resources
    % #4 content, not necessarily a box!
      {
         \int_gincr:N \g_@@_backend_object_int
         \int_const:cn
           { c_@@_backend_xform_ \tl_to_str:n {#1} _int }
           { \g_@@_backend_object_int }
         \box_new:c { g_@@_backend_xform_#1_box }
         \hbox_gset:cn { g_@@_backend_xform_#1_box }
           {
             \bool_set_true:N \l_@@_backend_xform_bool
             #4
           }
         \tl_const:cx
           { c_@@_backend_xform_wd_ \tl_to_str:n {#1} _tl }
           { \tex_the:D \box_wd:c { g_@@_backend_xform_#1_box } }
         \tl_const:cx
           { c_@@_backend_xform_ht_ \tl_to_str:n {#1} _tl }
           { \tex_the:D \box_ht:c { g_@@_backend_xform_#1_box } }
         \tl_const:cx
           { c_@@_backend_xform_dp_ \tl_to_str:n {#1} _tl }
           { \tex_the:D \box_dp:c { g_@@_backend_xform_#1_box } }
         \box_set_dp:cn  { g_@@_backend_xform_#1_box } { \c_zero_dim }
         \box_set_ht:cn  { g_@@_backend_xform_#1_box } { \c_zero_dim }
         \box_set_wd:cn  { g_@@_backend_xform_#1_box } { \c_zero_dim }
         \hook_gput_next_code:nn {shipout/background}
           {
             \mode_leave_vertical: %needed, the xform disappears without it.
             \@@_backend:x
               {
                 bxobj  ~ \@@_backend_xform_ref:n  { #1 }
                 \c_space_tl width  ~ \pdf_xform_wd:n { #1 }
                 \c_space_tl height ~ \pdf_xform_ht:n { #1 }
                 \c_space_tl depth  ~ \pdf_xform_dp:n { #1 }
               }
             \box_use_drop:c { g_@@_backend_xform_#1_box }
             \@@_backend:x {put ~ @resources ~<<#3>> }
             \@@_backend:x
               {
                 put~ @resources ~
                   <<
                     /ExtGState~ \pdf_object_ref:n {Page/Resources/ExtGState}
                   >>
               }
             \@@_backend:x
               {
                 put~ @resources ~
                 <<
                   /Pattern~ \pdf_object_ref:n {Page/Resources/Pattern}
                 >>
               }
             \@@_backend:x
               {
                 put~ @resources ~
                 <<
                   /Shading~ \pdf_object_ref:n {Page/Resources/Shading}
                 >>
               }
             \@@_backend:x
               {
                 put~ @resources ~
                 <<
                   /ColorSpace~
                   \pdf_object_ref:n {Page/Resources/ColorSpace}
                 >>
               }
             \exp_args:Nx
             \@@_backend:x {exobj ~<<#2>>}
           }
      }



    \cs_new:Npn \@@_backend_xform_ref:n #1
      {
        @pdf.xform \int_use:c { c_@@_backend_xform_ \tl_to_str:n {#1} _int }
      }

    \cs_new:Npn \@@_backend_xform_use:n #1
     {
       \hbox_set:Nn \l_@@_tmpa_box
         {
           \@@_backend:x
             {
               uxobj~ \@@_backend_xform_ref:n { #1 }
             }
         }
       \box_set_wd:Nn  \l_@@_tmpa_box { \pdf_xform_wd:n { #1 } }
       \box_set_ht:Nn  \l_@@_tmpa_box { \pdf_xform_ht:n { #1 } }
       \box_set_dp:Nn  \l_@@_tmpa_box { \pdf_xform_dp:n { #1 } }
       \box_use_drop:N \l_@@_tmpa_box
     }
  }
%% all
\prg_new_conditional:Npnn \@@_backend_xform_if_exist:n #1 { p , T , F , TF }
  {
    \int_if_exist:cTF { c_@@_backend_xform_ \tl_to_str:n {#1} _int }
     { \prg_return_true: }
     { \prg_return_false:}
  }
\prg_new_eq_conditional:NNn \pdf_xform_if_exist:n\@@_backend_xform_if_exist:n
  { TF , T , F , p }

%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%\subsection{Annotations}
% \begin{NOTE}{UF}
% The code/naming tries to unify general annotations and the special type of
% link under a common name.
% regarding naming and relation of annotation commands see
% https://github.com/FrankMittelbach/AccessiblePDF/issues/73
% \end{NOTE}

%\subsubsection{Annotations / backend}
% The backend commands are already in the driver:
% \cs{@@_backend_annotation:nnnn} and \cs{@@_backend_annotation_last:}
% \cs{@@_backend_link_begin_user:nnw}, etc
%
% \subsubsection{ general Annotation/management }
% \begin{NOTE}{UF}
% !!!type or not type? Syntax for type???
% \end{NOTE}
%  \begin{function}[added = 2020-04-14]
%   {\pdfannot:nnn}
%   \begin{syntax}
%     \cs{pdfannot:nnn} \Arg{type} \Arg{action spec} \Arg{annot text}
%   \end{syntax}
%   This creates an /Type/Annot object whose rectangle is defined by \Arg{annot text}.
%   If \Arg{type} is a known type the hooks of this type are executed at the begin and
%   the end, and the attribute dictionary of the type is inserted as attributes.
%   This allows to create for example a link annotation which shares border settings
%   with other links. \Arg{type} should e.g. be |Link/URI|. %!!!!!syntax?
% \end{function}
% %!!!!!! should there be a version without type??
% \begin{function}[added = 2019-09-05, updated = 2020-04-14]
%   {\pdfannot_box:nnnn}
%   \begin{syntax}
%     \cs{pdfannot_box:nnnn} \Arg{width} \Arg{height} \Arg{depth} \Arg{annot spec}
%   \end{syntax}
%   This creates an /Type/Annot object with the given dimensions.
% \end{function}
% \begin{function}[added = 2020-03-30]
%   {\pdfannot_box:nnnnn}
%   \begin{syntax}
%     \cs{pdfannot_box:nnnnn} \Arg{type} \Arg{width} \Arg{height} \Arg{depth} \Arg{annot spec}
%   \end{syntax}
%   This creates an /Type/Annot object.
%   If \Arg{type} is a known type the hooks of this type are executed at the begin and
%   the end, and the attribute dictionary of the type is inserted as attributes.
%   This allows to create for example a link annotation which shares border settings
%   with other links. \Arg{type} should e.g. be |Link/URI|. %!!!!!syntax?
% \end{function}
% \begin{function}[added = 2019-09-05]
%   {\pdfannot_box_last:}
%   \begin{syntax}
%     \cs{pdfannot_box_last:}
%   \end{syntax}
%   This retrieves the object reference of the last annotation created. This is not
%   available with xetex.
% \end{function}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfannot_box:nnnn #1 #2 #3 #4
  {
    \@@_backend_annotation:nnnn {#1}{#2}{#3}{#4}
  }

\cs_new:Npn \pdfannot_box_last:
  {
    \@@_backend_annotation_last:
  }

\cs_new_protected:Npn \pdfannot_box:nnnnn #1 #2 #3 #4 #5
  {
    \exp_args:Nx
    \@@_backend_annotation:nnnn {#2}{#3}{#4}
      {
        \@@_dict_if_exist:nT { annot/#1 }
          {
            \@@_dict_map:n {annot/#1}
          }
        #5
      }
  }



%    \end{macrocode}
% \subsection{Annotations, Flags}
% Every flag should have an associated property that allows to set/clear flag positions by
% name. The name is \c_pdfannot_flag_#1_prop
%    \begin{macrocode}
\cs_new_protected:Npn \pdfannot_flag_new:nn #1 #2
  {
    \bitsetReset  { @@_#1_flag }
    \prop_const_from_keyval:cn { c_pdfannot_flag_#1_prop }
      {
        #2
      }
  }

\pdfannot_flag_new:nn {annot/Link}
  {
    Invisible = 0,
    Hidden    = 1,
    Print     = 2,
    NoZoom    = 3,
    NoRotate  = 4,
    NoView    = 5,
    ReadOnly  = 6,
    Locked    = 7,
    ToggleNoView = 8,
    LockedContents = 9
  }

\pdfannot_flag_new:nn {annot/Field} %it is not really an annot, but we will put
  {                                 % form field in this module.
    ReadOnly  = 0,
    Required  = 1,
    NoExport  = 2,
    Multiline = 12,     %Tx
    Password  = 13,
    NoToggleToOff = 14, %Btn, radio button
    Radio     = 15,     %Btn: Radio:    15=1, 16=0
    Pushbutton = 16,    %Btn: Checkbox: 15=0, 16=0
                        %Btn: Pushbutton: 16=1
    Combo      = 17,    %Ch: Combo=1 List=0
    Edit       = 18,    %Ch, Combo=1 -> + edit field
    Sort       = 19,    %Ch, not relevant for view...
    FileSelect = 20,    %Tx
    MultiSelect =21,    %Ch
    DoNotSpellCheck = 22,%Tx, Ch (if Combo + Edit set)
    DoNotScroll     = 23,%Tx
    Comb            = 24,%Tx, requires MaxLen in dict
    RadiosInUnison  = 25, %Btn Radio
    RichText        = 25,  %Tx
    CommitOnSelChange = 26
  }

\pdfannot_flag_new:nn {annot/field/submit}
  {
    Include/Exclude  = 0,
    IncludeNoValueFields  = 1,
    ExportFormat  = 2,
    GetMethod = 3,     % if ExportFormat=0 -> =0 to
    SubmitCoordinates = 4, % if ExportFormat=0 -> =0 to
    XFDF = 5,
    IncludeAppendSaves = 6,
    IncludeAnnotations = 7,
    SubmitPDF = 8,
    CanonicalFormat = 9,
    ExclNonUserAnnots = 10,
    ExclFKey = 11,
    EmbedForm = 12,
  }

% #1: type, e.g. annot/Link
% #2: name of flag, e.g. Print
\cs_new_protected:Npn \pdfannot_flag_set:nn #1 #2
  {
    \bitsetSet  { @@_#1_flag }
      { \prop_item:cn {c_pdfannot_flag_#1_prop} {#2} }
  }

\cs_new_protected:Npn \pdfannot_flag_clear:nn #1 #2
  {
    \bitsetClear{ @@_#1_flag }
      { \prop_item:cn {c_pdfannot_flag_#1_prop} {#2} }
  }

%flags are output as decimals.
\cs_new:Npn \pdfannot_flag_use:n #1
  {
    \bitsetGetDec { @@_#1_flag }
  }

%    \end{macrocode}
% \subsection{Annotations, subtype Widget}\label{pdf:annot:widget}
% The local dictionary \texttt{annot/Widget} is a sceleton
% dictionary for this subtype. It currently contains as only entry
% the subtype setting (the /Type is added by the backend).
%    \begin{macrocode}

\pdfdict_new:n   {annot/Widget}
\pdfdict_put:nnn {annot/Widget}{Subtype}{/Widget}

%    \end{macrocode}
% \subsection{Annotations, subtype Link}\label{sec:links}
% Packages like hyperref, ocgx2 and tagpdf all wants to add code
% to link annotation. So we need commands to start and end a link which allows
% packages to add their code through hooks. There are three places in a link where
% hooks are needed: At the begin (for example for a structure command or color),
% in the \emph{attr spec} of the link (for example for the border), and
% at the end of the link (to close a structure or the color group).
%
% The values for \emph{attr spec} are dictionary values, the order they are
% inserted in the dictionary doesn't matter. So they are stored
% like for other dictionary values in a property list, with the key the name
% without a slash. Packages can add \emph{attr spec} entries through
% dedicated hook commands described below.
%
% Code for the begin and end hooks are stored in sequences. This allows some
% ordering.
%
% The code assumes that there will be different link types
% (currently URI, GoToR, Launch, GoTo, Named, hyperref uses the names
%  url,file,run,link,menu) and that
% links of the same type share the \emph{attr spec} and also the same begin/end
% code. The list of link types need to stay restricted and well documented so that
% all packages know which types they have to handle. It is stored in a constant
% seq.
% \begin{NOTE}{UF}
% Perhaps a |cite| type will be useful at some time. -- Thinking more about it,
% a |cite| type is not sensible. hyperref supports it, but it doesn't fit in.
% Commands like cite, gls, acro, footnote and so one should locally change
% linkcolor and linkbordercolor.
% Probably we will need some commands to add an attribute to all link types
% at once.
% hyperref commands for the various type:
% url  |\hyper@linkurl|,
% file |\hyper@linkfile|,
% run  |\@hyper@launch run|,
% link |\hyper@link|, |\find@pdflink|
% menu |\Acrobatmenu|
% \end{NOTE}
% \begin{variable}[added = 2020-03-12]{ \c_pdfannot_link_types_seq }
% This constant sequence contains the list of currently supported link types
% for which hooks and dictionaries exist.
% \end{variable}
%
%    \begin{macrocode}

\seq_const_from_clist:Nn \c_pdfannot_link_types_seq { URI , GoToR , Launch , GoTo, Named }

\seq_map_inline:Nn \c_pdfannot_link_types_seq
 {
   \pdfdict_new:n   { annot/Link/#1 }
   \pdfdict_put:nnn { annot/Link/#1}{ F }{ \pdfannot_flag_use:n { annot/Link} }
   \hook_new_pair:nn
     {pdf/annot/Link/#1/before}
     {pdf/annot/Link/#1/after}
   \seq_new:c  { l_@@_hook_annot/Link/#1_begin_seq }
   \seq_new:c  { l_@@_hook_annot/Link/#1_end_seq }
 }

%    \end{macrocode}


% \subsubsection{Annotations, subtype Link /management}
% \begin{function}[added = 2020-03-12, updated = 2020-04-14]{ \pdfannot_link:nnn }
%   \begin{syntax}
%     \cs{pdfannot_link:nnn} \Arg{type} \Arg{user action spec} \Arg{link text}
%   \end{syntax}
%  This creates a link around the \Arg{link text} with the specified
%  \Arg{user action spec}\footnote{The wording follows the pdftex documentation}.
%  \texttt{/Subtype/Link} is added automatically.
%  If \texttt{annot/Link/}\Arg{type} is a known local dictionary
%  attributes stored in dictionary of type \Arg{type} are inserted as
%  \emph{attr spec} and the code in
%  the begin and end hook is executed  before and after the link. \Arg{type} should
%  normally be identical to the value of the |/S| key in the action dictionary.
%  As example
%  \begin{verbatim}
%    \pdfannot_link:nnn { URI }
%     {
%       /A
%         <<
%           /Type/Action
%           /S/URI
%           /URI(https://www.latex-project.org)
%         >>
%     }
%     { link text }
%    \end{verbatim}
% \end{function}
%
%    \begin{macrocode}
\cs_new_protected:Nn \pdfannot_link:nnn %#1 type (URI, GoTo etc),
                                        %#2 action spec, #3 link text
  {
    %\seq_if_exist:cT { l_@@_hook_annot/Link/#1_begin_seq }
%      {
%        \seq_use:cn { l_@@_hook_annot/Link/#1_begin_seq }{}
%      }
    \hook_use:n { pdf/annot/Link/#1/before}
    \mode_leave_vertical:
    \exp_args:Nxx %xetex needs expansion
    \@@_backend_link_begin_user:nnw
      {
         \@@_dict_if_exist:nT { annot/Link/#1 }
          {
            \@@_dict_map:n {annot/Link/#1}
          }
      }
      {
        /Subtype/Link
        #2
      }
    #3
    \@@_backend_link_end:
    %\seq_if_exist:cT { l_@@_hook_annot/Link/#1_end_seq }
%      {
%        \seq_use:cn { l_@@_hook_annot/Link/#1_end_seq }{}
%      }
    \hook_use:n { pdf/annot/Link/#1/after}
  }
%    \end{macrocode}
% \begin{function}[added = 2020-03-12]{ \pdfannot_link_begin:nnw, \pdfannot_link_end:n }
%   \begin{syntax}
%     \cs{pdfannot_link_begin:nnw} \Arg{type} \Arg{user action spec} \meta{content}
%     \cs{pdfannot_link_end:n} \Arg{type}
%   \end{syntax}
%  This creates a link around the \meta{content} with the specified
%  \meta{user action spec} (e.g. an /A dictionary with an URI) or
%  \meta{destination} (a name as defined with the
%  first argument of \cs{pdf_destination:nn}).
%  \texttt{/Subtype/Link} is added automatically.
%  In contrast to \cs{pdfannot_link:nnn} this function
%  does not absorb the argument when finding the \meta{content}, and so can
%  be used in circumstances where the \meta{content} may not be a simple
%  argument.
%  If \texttt{annot/Link/}\Arg{type} is a known local dictionary
%  attributes stored in dictionary of type \Arg{type} are inserted as
%  \emph{attr spec} and the code in the begin and end hook is executed
%  before and after the link. As example
%  \begin{verbatim}
%    \pdfannot_link_begin:nnw { URI }
%     {
%       /A<<
%         /Type/Action
%         /S/URI
%         /URI(https://www.latex-project.org)
%       >>
%     }
%     link text
%    \pdfannot_link_end:n { URI }
%    \end{verbatim}
% \end{function}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfannot_link_begin:nnw #1 #2 %#1 type, #2 action spec
  {
    %\seq_if_exist:cT { l_@@_hook_annot/Link/#1_begin_seq }
%      {
%        \seq_use:cn { l_@@_hook_annot/Link/#1_begin_seq }{}
%      }
    \hook_use:n { pdf/annot/Link/#1/before}
    \exp_args:Nxx %xetex needs expansion
      \@@_backend_link_begin_user:nnw
        {
           \@@_dict_if_exist:nT { annot/Link/#1 }
            {
              \@@_dict_map:n {annot/Link/#1}
            }
        }
        { #2 }
  }

\cs_new_protected:Nn \pdfannot_link_end:n %#1 type, e.g. url
  {
    \@@_backend_link_end:
  %  \seq_if_exist:cT {l_@@_hook_annot/Link/#1_end_seq}
%      {
%        \seq_use:cn { l_@@_hook_annot/Link/#1_end_seq }{}
%      }
    \hook_use:n { pdf/annot/Link/#1/after}
  }
%    \end{macrocode}
% \begin{function}[updated = 2020-03-30]{ \pdfannot_link_goto_begin:nw, \pdfannot_link_goto_end: }
%   \begin{syntax}
%     \cs{pdfannot_link_goto_begin:nw} \Arg{destination} \meta{content}
%     \cs{pdfannot_link_goto_end:}
%   \end{syntax}
% This is a special, shorter version for links to internal destinations. It always
% uses the hooks and dictionary of the |GoTo| link type.
% \end{function}
%     \begin{macrocode}
\cs_new_protected:Npn \pdfannot_link_goto_begin:nw #1 %#1 destination
  {
    %\seq_use:cn { l_@@_hook_annot/Link/GoTo_begin_seq }{}
    \hook_use:n { pdf/annot/Link/GoTo/before}
    \exp_args:Nxx %xetex needs expansion
    \@@_backend_link_begin_goto:nnw
      {
        \@@_dict_map:n {annot/Link/GoTo}

      }
      { #1 }
  }

\cs_new_protected:Nn \pdfannot_link_goto_end:
  {
    \@@_backend_link_end:
    %\seq_use:cn { l_@@_hook_annot/Link/GoTo_end_seq }{}
    \hook_use:n { pdf/annot/Link/GoTo/before}
  }

%    \end{macrocode}
% \begin{function}[added = 2020-03-12]{  \pdfannot_link_last: }
%   This retrieves the object reference a previously link created with the commands
%   above
% \end{function}
%    \begin{macrocode}
\cs_set_eq:NN \pdf_link_last: \@@_backend_link_last:
%    \end{macrocode}
% %!!!! only annot link or also annot??
% \begin{function}[added = 2020-03-12]{  \pdfannot_link_margin:n }
%  \begin{syntax}
%    \cs{pdfannot_link_margin:n} \Arg{dimen}
%  \end{syntax}
%   This sets the dimension of the link margin.
% \end{function}
%    \begin{macrocode}
\cs_set_eq:NN \pdfannot_link_margin:n \@@_backend_link_margin:n
%    \end{macrocode}

% \subsection{Destinations}
% \begin{NOTE}{UF}
% I'm unsure about the backend code of the rectangle (FitR) variant. Should it
% really typeset a box???
% I'm also unsure if \cs{pdf_destination:nn} should really allow both
% a type and an integer as second argument. Perhaps a \cs{pdf_destination_zoom:nn}
% would be better??
% \end{NOTE}
% Destinations are \enquote{anchors} for links. The commands here
% create named destinations. The pdf\LaTeX{} primitive doesn't support all
% variants described in the pdf reference. The backend code expect lower case
% arguments, but we add support for the casing of hyperref and the pdf reference.
%
% \begin{tabular}{llll}
% Type & status    & input    &remark \\\hline
% /Fit & supported & fit, Fit \\%
% /FitH& supported & fith, FitH \\
% /FitH \emph{top} & not supported\\
% /FitV & supported& fitv, FitV\\
% /FitV \emph{left} & not supported\\
% /FitB & supported & fitb, FitB\\
% /FitBH & supported & fitbh, FitBH\\
% /FitBH \emph{top}& not supported\\
% /FitBV & supported & fitbv, FitBV\\
% /FitBV \emph{left} & not supported\\
% /FitR \emph{left bottom right top} & supported in part& typesets a box\\
% /XYZ \emph{left} \emph{top} NULL & supported & xyz, XYZ &left, top are automatic\\
% /XYZ \emph{left} \emph{top} zoom & supported & integer (percent) &left, top are automatic\\
% \end{tabular}
%
% \begin{function}[added = 2020-03-10]
%   {\pdf_destination:nn}
%   \begin{syntax}
%     \cs{pdf_destination:nn} \Arg{name} \Arg{type or integer}
%   \end{syntax}
%   This creates a destination. \Arg{type or Integer} can be one of |Fit|, |FitH|,
%   |FitV|, |FitB|, |FitBH|, |FitBV|, |XYZ| and the lower case variants,
%   or an integer representing a  scale factor in percent.
% \end{function}
% \begin{function}[added = 2020-03-10]
%   {\pdf_destination_box:nn}
%   \begin{syntax}
%     \cs{pdf_destination_box:nn} \Arg{name} \Arg{content}
%   \end{syntax}
%   This stores the content in a hbox, outputs the box and
%   creates a destination with |FitR| type encompassing this box.
% \end{function}
%    \begin{macrocode}
% perhaps some manipulation of the argument will be needed to map the current
% hyperref syntax
% unclear currently if is this is useful for anything.
\prop_new:N \l_@@_views_map_prop
\prop_put:Nnn \l_@@_views_map_prop {XYZ} { xyz }
\prop_put:Nnn \l_@@_views_map_prop {xyz} { xyz }
\prop_put:Nnn \l_@@_views_map_prop {Fit} { fit }
\prop_put:Nnn \l_@@_views_map_prop {fit} { fit }
\prop_put:Nnn \l_@@_views_map_prop {FitB} { fitb }
\prop_put:Nnn \l_@@_views_map_prop {fitb} { fitb }
\prop_put:Nnn \l_@@_views_map_prop {FitBH} { fitbh }
\prop_put:Nnn \l_@@_views_map_prop {fitbh} { fitbh }
\prop_put:Nnn \l_@@_views_map_prop {FitBv} { fitbv }
\prop_put:Nnn \l_@@_views_map_prop {fitbv} { fitbv }
\prop_put:Nnn \l_@@_views_map_prop {FitH} { fith }
\prop_put:Nnn \l_@@_views_map_prop {fith} { fith }
\prop_put:Nnn \l_@@_views_map_prop {FitV} { fitv }
\prop_put:Nnn \l_@@_views_map_prop {fitv} { fitv }

\cs_new_protected:Npn \pdf_destination:nn #1 #2
 {
  \prop_if_in:NnTF \l_@@_views_map_prop { #2 }
   {
    \exp_args:Nox %xetex?
    \@@_backend_destination:nn { #1 } { \prop_item:Nn \l_@@_views_map_prop {#2} }
   }
   {
    \exp_args:No %xetex?
    \@@_backend_destination:nn { #1 } { #2 }
    % should we assume that it is a zoom value then??
    % should we test that it is really a number?
    % or should there be a third argument for this case and for other coordinates?
   }
 }
\cs_generate_variant:Nn\pdf_destination:nn {no,nf}

\cs_new_protected:Npn \pdf_destination_box:nn #1 #2 %#1 name, #2 box content
 {
   \@@_backend_destination_box:nn { #1 }{ #2 } %new name!!
 }

%avoid that destinations names are optimized.
% is this still needed??
%see https://tug.org/pipermail/dvipdfmx/2019-May/000002.html
\sys_if_engine_xetex:T
  {
    \__kernel_backend_literal:x { dvipdfmx:config~C~ 0x10 }
  }

%    \end{macrocode}
% \section{Drop?}
% \subsubsection{Doc View/Openaction}
% \begin{NOTE}{UF}
%   /OpenAction can be an array:
%   |/OpenAction [5 0 R /Fit]| or an action: |<< /S /GoTo /D [ 7 0 R /Fit ] >>|.
%  The implementation below allows only the first. It is not quite clear, if
%  this is sensible (and if a special docview command is needed at all).
%  The second could be set directly.
% \end{NOTE}
%
% \begin{function}[added = 2019-08-18]
%   {\pdf_docview:nn}
%   \begin{syntax}
%     \cs{pdf_docview:nn} \Arg{page} \Arg{view}
%   \end{syntax}
% This command allows to set the OpenAction array. The \meta{page}
% is an absolute page number. \Arg{view} a string for the destination
% without the leading slash. Examples are e.g. |XYZ left top zoom| or |Fit|.
% The OpenAction uses (and could also be set directly with)
% \cs{pdfdict_gput:nnn}|{Catalog}|.
% \end{function}
%
%    \begin{macrocode}
\cs_new_protected:Npn \pdf_docview:nn #1 #2
  {
    \pdfdict_gput:nnx {Catalog }{ OpenAction }{[\pdf_pageobject_ref:n {#1}~/#2]}
  }
%    \end{macrocode}
%
% \section{Document metadata}
% We plan a \cs{DeclareDocumentMetaData} so let's start with it.
% It should for the begin allow to set the version, to uncompress a pdf,
% and set the language. We also add a key to activate the metadata stream and
% to set a standard. The code has been moved to l3pdfmeta.
% \begin{NOTE}{UF}
% how to setup a backend/driver key? Can it be copied from expl3?
% \end{NOTE}
% \begin{function}[added=2019-08-25]{\DeclareDocumentMetaData}
%    \begin{macrocode}
\RequirePackage{l3pdfmeta} %


%    \end{macrocode}
% \end{function}
% %load backend driver
%    \begin{macrocode}
\file_input:n {l3\g__sys_backend_tl-pdf.def}

%    \end{macrocode}
%^^A the following is used in the experimental driver
%^^A but it is unclear if is should stay / how the syntax should be
% \section{Hook management}
% hooks are commands that allow users and other packages to inject code. In the
% pdfresources project hooks are used for links (see section \ref{sec:links}).
% Some tools are need to add code and values to these hooks. The following
% contains some code currently used in some experiments and some general remarks.
% It should be move to some hook package.
%
% \subsection{hooks with token lists}
%  Hook code can be stored in a simple token list variable (tl). An example is e.g.
% \cs{@begindocumenthook}. In this case possible operations are
% \begin{itemize}
% \item \emph{appending} to the hook
% \item \emph{prepending} to the hook
% \item and perhaps some more or less complicated \emph{patching} to remove/replace parts
% \end{itemize}
%
% Such a hook can be \emph{used} by using the variable.
%
% \subsection{hooks with sequences}
% Hook code can also be stored in a sequence (seq). In this data structure every user adding
% something to the hook can get an index back.
% In this case possible operations are
% \begin{itemize}
% \item \emph{appending} to the hook (\cs{seq_put_right}),
% \item \emph{prepending} to the hook (need to keep track of the \enquote{zero pointer} if the user
% should get an index back)
% \item \emph{changing} (e.g emptying) a hook item through the index. But as this
% involves mapping through the sequence to find the right item, it is perhaps too slow.
% \end{itemize}
%
% Such a hook can be \emph{used} by mapping over the sequence. It is possible to filter or
% exclude items. It is also possible to insert code while processing the individual items.
% It is not quite clear if the additional features of such sequence hooks are really needed
% but the overhead is not so large, so it should be ok to use is. Probably if the type
% is used at all, it would be sensible to drop the tl-type so that one doesn't have to define
% \cs{hook_put_right_tl:nnn} and \cs{hook_put_right_seq:nnn} functions.
%
% \subsection{hooks with properties}
% Hook code can also be stored in a property (prop). Here possible operations are
% \begin{itemize}
% \item \emph{adding} a new key and its value. It is possible to write the interface so
% that only a specific set of keys are allowed.
% \item \emph{changing} the value of an existing key, either by overwriting the
% current value or by appending more code to the value -- the second could e.g. be used
% to extend the /ExtGState or /ColorSpace values.
% \item \emph{removing} a key
% \end{itemize}
%
% A hook stored like this can be used by mapping over the properties, but selective
% use and filtering is possible too.
%
% Such a hook is useful if -- like in the case of dictionary values in a pdf -- various
% packages need to be able to manipulate the same key.
%
% \subsection{Naming hooks and access functions}
% hooks are module specific. So set functions should probably do be something like
%
% \cs{hook_put_right:nnn}\verb+{<module>}{<hook-name>}{value}+ (seq- or tl-type)
% or in the case of  properties
% \cs{hook_put:nnnn} {<module>}{<hook-name>}{<key>}{<value>}
%
% hooks should be manipulated only through such access functions. So their
% name should be an internal command of the module. E.g.
% \verb+l__<module>_hook_<hook-name>_prop+
%
%    \begin{macrocode}
%\cs_new:Nn \hook_put_right:nnn
% {
%  \seq_put_right:cn { l__#1_hook_#2_seq } { #3 }
% }
%
%\cs_new:Nn \hook_put_left:nnn
% {
%  \seq_put_left:cn { l__#1_hook_#2_seq } { #3 }
% }

%\cs_new:Nn \hook_put:nnnn
% {
%  \prop_put:cnn { l__#1_hook_#2_prop } { #3 }{ #4 }
% }
%
%\cs_new:Nn \hook_gput:nnnn
% {
%  \prop_gput:cnn { g__#1_hook_#2_prop } { #3 }{ #4 }
% }

%\cs_new:Nn \hook_remove:nnn
% {
%  \prop_remove:cn { l__#1_hook_#2_prop } { #3 }
% }
%
%\cs_new:Nn \hook_gremove:nnn
% {
%  \prop_gremove:cn { g__#1_hook_#2_prop } { #3 }
% }
%    \end{macrocode}
% \subsection{Passing external information to hooks}
% hooks sometimes wants to know something about the arguments of the surrounding command.
% E.g. a hook in \cs{@startsection} perhaps needs the current section level or
% if it is a run-in or display sectioning. Using \#-arguments in the hook is possible
% but rather fragile. It is probably better if the surrounding command offers a
% documented interface through e.g. tl-variables. It should be also clear which
% variables are read-only and which can be changed by the hook code.
%
% %%%%%%%%END HOOK
%
% \section{Patches}
% This code is temporary! It tries to patch commands of other packages which
% fills pdfresources too, to remove clashes and test if everything works as expected.
% This code should disappear when packages adapt to the central interfaces.
%
% \subsection{\pkg{pgf}}
%
% In \pkg{pgf}, resource management is set up in the file |pgfutil-common.tex|.
% This then provides three functions for adding to the resources, all of which
% are objects:
% \begin{itemize}
%   \item \cs{pgfutil@addpdfresource@extgs}: Extended graphics state
%   \item \cs{pgfutil@addpdfresource@colorspaces}: Color spaces
%   \item \cs{pgfutil@addpdfresource@patterns}: Patterns
% \end{itemize}
%
% These resource dictionaries are used by adding entries in a cumulative sense;
% the macro layer deals with ensuring that each entry is only given once. Note
% that the objects themselves must be given only once for each page.
%
% To support these functions, there are a series of set-up macros which install
% these resources. That has to take place for every page: the exact route
% therefore depends on the driver.
%
% For the pageresources project we need to avoid that pgf interferes in ExtGState,
% ColorSpace and Pattern (Shadings are added to the xform resources and so probably
% unproblematic for now).
%    \begin{macrocode}
% patches for xetex/dvips doesn't make much sense for colorspace and
% transparent. But pgf should be tested sometimes.
% currently only pdftex/luatex is handled here.
\bool_if:nT { !\g_@@_patches_bool || \sys_if_output_dvi_p:  }
  {
    \file_input_stop:
  }
\RequirePackage{etoolbox}
\@ifpackageloaded{pgfrcs}
 {
  \msg_warning:nn{pdf}{pgf-too-late}
  \file_input_stop:
 }
 {
  \msg_info:nn{pdf}{patches}
 }
\RequirePackage{pgfrcs}
%
%\def\pgfutil@addpdfresource@extgs#1{\pgf@sys@addpdfresource@extgs@plain{#1}}
%\def\pgfutil@addpdfresource@colorspaces#1{\pgf@sys@addpdfresource@colorspaces@plain{#1}}
%\def\pgfutil@addpdfresource@patterns#1{\pgf@sys@addpdfresource@patterns@plain{#1}}
%\def\pgfutil@setuppdfresources{\pgf@sys@setuppdfresources@plain}
% \pgf@sys@pdf@possible@resources %used in xform
%Trying to patch pgf ..
\cs_new_protected:Npn \@@_pgf_sys_setuppdfresources_plain:
  {
   %objects are already created ...
    \def\pgf@sys@pdf@possible@resources
      {
        /ColorSpace~\pdf_object_ref:n {Page/Resources/ColorSpace}
        /Pattern   ~\pdf_object_ref:n {Page/Resources/Pattern}
        /ExtGState ~\pdf_object_ref:n {Page/Resources/ExtGState}
      }
    \let\pgf@sys@pdf@check@resources=\relax%
    %not sure if needed, but perhaps the lists are used somewhere else ...
    \let\pgf@sys@pgf@resource@list@extgs=\pgfutil@empty%
    \let\pgf@sys@pgf@resource@list@patterns=\pgfutil@empty%
    \let\pgf@sys@pgf@resource@list@colorspaces=\pgfutil@empty%
    % the commands to add page resources
    \def\pgf@sys@addpdfresource@extgs@plain##1
      {
        \exp_after:wN %for transparent which passes a command
          \@@_patch_pgfextgs:w ##1\q_stop
      }
    \def\pgf@sys@addpdfresource@patterns@plain##1
      {
        \@@_patch_pgfpatterns:w ##1\q_stop
      }
   \def\pgf@sys@addpdfresource@colorspaces@plain##1
      {
        \@@_patch_pgfcolorspaces:w ##1\q_stop
      }
  }
\def\pgfutil@setuppdfresources{\@@_pgf_sys_setuppdfresources_plain:}

%label??
\hook_gput_code:nnn {begindocument/end} {pdf} { \pgfutil@setuppdfresources }
%\AtEndPreamble{\pgfutil@setuppdfresources}
% helper commands as pgf doesn't pass resources as two arguments
% code to add to the resources existing stuff in the format "/name value":
\cs_new:Npn \@@_split_dict_entry_aux:NNw #1 #2 /#3~#4\q_stop
  {
    \tl_set:Nn #1 {#3}
    \tl_set:Nn #2 {#4}
  }
\tl_new:N \l_@@_name_tmp_tl
\tl_new:N \l_@@_value_tmp_tl

%\cs_generate_variant:Nn \pdf_pageresources_gput:nnn {noo}
%
%\cs_new_protected:Npn \pdf_pageresources_split_gput:nn  #1 #2  %#1  resources
%  {
%    \@@_split_dict_entry_aux:NNw \l_@@_name_tmp_tl \l_@@_value_tmp_tl #2 \q_stop
%    \pdf_pageresources_gput:noo {#1}{\l_@@_name_tmp_tl}{\l_@@_value_tmp_tl}
%  }

\cs_new:Npn \@@_patch_pgfextgs:w  #1/#2<<#3>>#4\q_stop
  {
    \@@_backend_PageResources_gput:nnn {ExtGState}{#2}{<<#3>>}
  }
\cs_new:Npn \@@_patch_pgfpatterns:w  #1/#2\space#3\q_stop
  {
    \exp_args:Nnnx \@@_backend_PageResources_gput:nnn {Pattern}{#2}{#3}
  }
\cs_new:Npn \@@_patch_pgfcolorspaces:w  #1/#2[#3]#4\q_stop
  {
    \@@_backend_PageResources_gput:nnn {ColorSpace}{#2}{[#3]}
  }

%    \end{macrocode}
% \subsection{\pkg{transparent}}
% transparent, we assume that pdfresource is loaded first.
% the code does nothing is with new-transparent ...
%    \begin{macrocode}

%label??
\hook_gput_code:nnn {begindocument/end} {pdf}
%\AtEndPreamble
  {
    \def\TRP@addresource
      {
        \@@_backend_PageResources_gput:nnn{ExtGState}{TRP1}{<</ca~1/CA~1>>}
      }
    \def\transparent@use#1
      {
        \tl_if_exist:cF{TRP#1}
          {
            \@@_backend_PageResources_gput:nnn
              {ExtGState}
              {TRP#1}
              {<</ca~#1/CA~#1>>}
            \tl_const:cn{TRP#1}{/TRP#1~gs}
          }
       }
  }
%    \end{macrocode}
% \subsection{\pkg{colorspace}}
% This is rather difficult as no real places to inject patches
% at first a try to avoid that it's ExtGState is missing:
% it can not be avoided to recreate the objects (and so to get duplicates)
% as colorspace uses temporary macros whose contents is lost.
%    \begin{macrocode}
% this must be earlier, to avoid problems with luatex which has two pageresources
% lua/tex
\hook_gput_code:nnn {begindocument} {pdf}
  {
    \tl_if_exist:NT \spc@op
      {
        \def\spc@Pageresources#1{}
      }

  }

\hook_gput_code:nnn {begindocument/end} {pdf}
%\AtEndPreamble
  {
    \tl_if_exist:NT \spc@op
      {
        \@@_backend_object_new:nn  {__spc_extgstate_op_false}{dict}
        \@@_backend_object_write:nn
          {__spc_extgstate_op_false}
          {/Type /ExtGState~/op~false~/OP~false}
        \pdfdict_gput:nnn
          {Page/Resources/ExtGState}
          {SPCko}
          {\@@_backend_object_ref:n {__spc_extgstate_op_false}}
        \@@_backend_object_new:nn  {__spc_extgstate_op_true0}{dict}
        \@@_backend_object_write:nn
          {__spc_extgstate_op_true0}
          {/Type /ExtGState~/op~true~/OP~true~/OPM~0}%
        \pdfdict_gput:nnn
          {Page/Resources/ExtGState}
          {SPCmz}
          {\@@_backend_object_ref:n {__spc_extgstate_op_true0}}
        \@@_backend_object_new:nn  {__spc_extgstate_op_true1}{dict}
        \@@_backend_object_write:nn
          {__spc_extgstate_op_true1}
          {/Type /ExtGState~/op~true~/OP~true~/OPM~1}%
         \pdfdict_gput:nnn
          {Page/Resources/ExtGState}
          {SPCop}
          {\@@_backend_object_ref:n {__spc_extgstate_op_true1}}
      }
  }
%    \end{macrocode}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \subsection{lua code for lualatex}
%    \begin{macrocode}
%<*lua>
l3kernel= l3kernel or {}
l3kernel.@@      = l3kernel.@@ or {}
l3kernel.@@.Page = l3kernel.@@.Page or {}
l3kernel.@@.Page.dflt = l3kernel.@@.Page.dflt or {}
l3kernel= l3kernel or {}
l3kernel.@@.Page.Resources = l3kernel.@@.Resources or {}
l3kernel.@@.Page.Resources.Properties = l3kernel.@@.Page.Resources.Properties or {}
l3kernel.@@.Page.Resources.List={"ExtGState","ColorSpace","Pattern","Shading"}
l3kernel.@@.object = l3kernel.@@.object or {}

l3kernel.pdf= l3kernel.pdf or {} -- for "public" functions

local @@ = l3kernel.@@
local pdf = pdf

local function @@_backend_Page_gput (name,value)
 @@.Page.dflt[name]=value
end

local function @@_backend_Page_gremove (name)
 @@.Page.dflt[name]=nil
end

local function @@_backend_Page_gclear ()
 @@.Page.dflt={}
end

local function @@_backend_ThisPage_gput (page,name,value)
 @@.Page[page] = @@.Page[page] or {}
 @@.Page[page][name]=value
end

local function @@_backend_ThisPage_gpush (page)
 local token=""
 local t = {}
 local tkeys= {}
 for name,value in pairs(@@.Page.dflt) do
   t[name]=value
 end
 if @@.Page[page] then
  for name,value in pairs(@@.Page[page]) do
   t[name] = value
  end
 end
 -- sort the table to get reliable test files.
 for name,value in pairs(t) do
  table.insert(tkeys,name)
 end
 table.sort(tkeys)
 for _,name in ipairs(tkeys) do
   token = token .. "/"..name.." "..t[name]
 end
 return token
end

function l3kernel.@@.backend_ThisPage_gput (page,name,value) -- tex.count["g_shipout_readonly_int"]
 @@_backend_ThisPage_gput (page,name,value)
end

function l3kernel.@@.backend_ThisPage_gpush (page)
  pdf.setpageattributes(@@_backend_ThisPage_gpush (page))
end

function l3kernel.@@.backend_Page_gput (name,value)
  @@_backend_Page_gput (name,value)
end

function l3kernel.@@.backend_Page_gremove (name)
  @@_backend_Page_gremove (name)
end

function l3kernel.@@.backend_Page_gclear ()
  @@_backend_Page_gclear ()
end


local Properties  = l3kernel.@@.Page.Resources.Properties
local ResourceList= l3kernel.@@.Page.Resources.List
local function @@_backend_PageResources_gpush (page)
 local token=""
 if Properties[page] then
-- we sort the table, so that the pdf test works
  local t = {}
  for name,value in pairs  (Properties[page]) do
   table.insert (t,name)
  end
  table.sort (t)
  for _,name in ipairs(t) do
   token = token .. "/"..name.." ".. Properties[page][name]
  end
  token = "/Properties <<"..token..">>"
 end
  for i,name in ipairs(ResourceList) do
   if l3kernel.@@.Page.Resources[name] then
   token = token .. "/"..name.." "..l3kernel.pdf.object_ref("Page/Resources/"..name)
   end
  end
 return token
end

-- the function is public, as I probably need it in tagpdf too ...
function l3kernel.pdf.Page_Resources_Properties_gput (page,name,value) -- tex.count["g_shipout_readonly_int"]
 Properties[page] = Properties[page] or {}
 Properties[page][name]=value
 pdf.setpageresources(@@_backend_PageResources_gpush (page))
end

function l3kernel.pdf.Page_Resources_gpush(page)
 pdf.setpageresources(@@_backend_PageResources_gpush (page))
end

function l3kernel.pdf.object_ref (objname)
 if l3kernel.@@.object[objname] then
  local ref= l3kernel.@@.object[objname]
  return ref
 else
  return "false"
 end
end
%</lua>
%    \end{macrocode}
% \PrintIndex
