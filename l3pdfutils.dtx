% \iffalse meta-comment
%
%% File: l3pdfutils.dtx
%
% Copyright (C) 2018-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "(experimental) pdfmanagement bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/pdfresources
%
% for those people who are interested.
%
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3pdfutils} package\\ pdf-utilities   ^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released XXXX-XX-XX}
%
% \maketitle
% \begin{documentation}
%
% \section{\pkg{l3pdfutils} documentation}
% This module contains a number of commands to create pdf structures with
% meaningful contents, currently xform, annotations and destinations.
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3pdfutils} implementation}
%
%    \begin{macrocode}
%<*package>
%<@@=pdf>
\ProvidesExplPackage {l3pdfutils} {2020-12-04} {0.2}
  {PDF-utils}
%    \end{macrocode}
% \subsection{Form XObject (pdfxform)}
% \begin{NOTE}{UF}
%  - As in dvi mode the xform is immediate, this is done for pdftex/luatex too.
%    If needed a delayed version can be added later.
%  - the argument for attributes is needed to add e.g. /StructParents
%  - it is not clear if an argument for additional resources is needed, probably they
%    should / need to be added automatically.
%  - code for adding ExtGState etc to the local resource is missing, will be
%    added when the object name is clear.!!!!!!!!!!!!
%  - should the size be stored in dim or tl?
%  - dvips implementation is missing for ideas: pdfbase, atfi-dvips.def,
%  \end{NOTE}
%
%  \subsubsection{Form XObject / management}
%  \begin{function}[added = 2019-08-05]
%   {
%     \pdf_xform_new:nnn
%   }
%   \begin{syntax}
%     \cs{pdf_xform_new:nnn} \Arg{name} \Arg{attributes} \Arg{content}
%   \end{syntax}
%    This command create a new form XObject that can be used as appearance or
%    directly later.
%    If the content contains BDC-marks it should \emph{not} be given as a
%    previously typeset box, but directly so that the names of the
%    BDC-marks can be added to the resources of the xform. The xform will automatically
%    include the resources of the current page.
%    The content will be typeset in a hbox. With pdflatex and luatex
%    the surrounding color is \emph{not} stored in the XObject
%    but should be if wanted added e.g. with |\color_select:n{.}|. This keeps
%    the option of color injection open.
%   \end{function}
%   \begin{function}[added = 2019-08-05]
%     {
%      \pdf_xform_use:n
%     }
%   \begin{syntax}
%     \cs{pdf_xform_use:n} \Arg{name}
%   \end{syntax}
%    This command uses (typesets) a previously created form XObject.
%    If the surrounding color is different, it is injected in the XObject with the
%    engines pdftex or luatex.
%   \end{function}
%   \begin{function}[EXP,added = 2019-08-05]
%     {
%       \pdf_xform_ref:n
%     }
%   \begin{syntax}
%     \cs{pdf_xform_ref:n} \Arg{name}
%   \end{syntax}
%   Inserts the appropriate information to reference the xform \meta{name}
%   in for example appearance dictionaries.
%   \end{function}
%   \begin{function}[EXP,added = 2019-08-05]
%     {
%       \pdf_xform_wd:n, \pdf_xform_ht:n, \pdf_xform_dp:n
%     }
%   \begin{syntax}
%     \cs{pdf_xform_wd:n} \Arg{name}
%   \end{syntax}
%    These command give back the sizes of the XObject. The values are stored in
%    tl-variables with the unit pt and not in dimensions!
%   \end{function}
%   \begin{function}[EXP,pTF,added = 2020-04-29]
%     {
%       \pdf_xform_if_exist:n
%     }
%   \begin{syntax}
%     \cs{pdf_xform_if_exist_p:n} \Arg{name}
%     \cs{pdf_xform_if_exist:NTF} \meta{name} \Arg{true code} \Arg{false code}
%   \end{syntax}
%    These command tests if an xform with name \Arg{name} has been already defined.
%   \end{function}%
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn  \pdf_xform_new:nnn #1 #2 #3
  {
    \@@_backend_xform_new:nnnn { #1 } { #2 } {  } { #3 }
  }

\cs_new_protected:Npn \pdf_xform_use:n #1
  {
    \@@_backend_xform_use:n { #1 }
  }
% expansion?
\cs_new:Npn \pdf_xform_ref:n #1
  {
    \@@_backend_xform_ref:n { #1 }
  }

\cs_generate_variant:Nn \pdf_xform_ref:n {o}

\cs_new:Npn \pdf_xform_wd:n #1
  {
    \tl_use:c { c_@@_backend_xform_wd_ \tl_to_str:n { #1 } _tl }
  }

\cs_new:Npn \pdf_xform_ht:n #1
  {
    \tl_use:c { c_@@_backend_xform_ht_ \tl_to_str:n { #1 } _tl }
  }

\cs_new:Npn \pdf_xform_dp:n #1
  {
    \tl_use:c { c_@@_backend_xform_dp_ \tl_to_str:n { #1 } _tl }
  }
%</package>
%    \end{macrocode}
%
%
%\subsection{Annotations}
%    \begin{macrocode}
%<@@=pdfannot>
%    \end{macrocode}
% \begin{NOTE}{UF}
% The code/naming tries to unify general annotations and the special type of
% link under a common name.
% regarding naming and relation of annotation commands see
% https://github.com/FrankMittelbach/AccessiblePDF/issues/73
% This should probably be moved to l3annot. Or can it be merged with the xform?
% \end{NOTE}

%\subsubsection{Annotations / backend}
% The backend commands are already in the driver:
% \cs{@@_backend_annotation:nnnn} and \cs{@@_backend_annotation_last:}
% \cs{@@_backend_link_begin_user:nnw}, etc
%
% \subsubsection{ general Annotation/management }
% \begin{variable}
%  { \g_@@_use_lastlink_bool }
% The pdf engines have two different primitive commands to refer to the last created
% annotation: one for links, one for boxed annotation. We use a boolean to decide
% which one should be used, so that only one user command is needed.
%    \begin{macrocode}
%<*package>
\bool_new:N \g_@@_use_lastlink_bool
%</package>
%    \end{macrocode}
% \end{variable}
% \begin{NOTE}{UF}
% !!!type or not type? Syntax for type???
% \end{NOTE}
%  \begin{function}[added = 2020-04-14]
%   {\pdfannot:nnn}
%   \begin{syntax}
%     \cs{pdfannot:nnn} \Arg{type} \Arg{action spec} \Arg{annot text}
%   \end{syntax}
%   This creates an /Type/Annot object whose rectangle is defined by \Arg{annot text}.
%   If \Arg{type} is a known type the hooks of this type are executed at the begin and
%   the end, and the attribute dictionary of the type is inserted as attributes.
%   This allows to create for example a link annotation which shares border settings
%   with other links. \Arg{type} should e.g. be |Link/URI|. %!!!!!syntax?
% \end{function}
% %!!!!!! should there be a version without type??
% \begin{function}[added = 2019-09-05, updated = 2020-04-14]
%   {\pdfannot_box:nnnn}
%   \begin{syntax}
%     \cs{pdfannot_box:nnnn} \Arg{width} \Arg{height} \Arg{depth} \Arg{annot spec}
%   \end{syntax}
%   This creates an /Type/Annot object with the given dimensions.
% \end{function}
% \begin{function}[added = 2020-03-30]
%   {\pdfannot_box:nnnnn}
%   \begin{syntax}
%     \cs{pdfannot_box:nnnnn} \Arg{type} \Arg{width} \Arg{height} \Arg{depth} \Arg{annot spec}
%   \end{syntax}
%   This creates an /Type/Annot object.
%   If \Arg{type} is a known type the hooks of this type are executed at the begin and
%   the end, and the attribute dictionary of the type is inserted as attributes.
%   This allows to create for example a link annotation which shares border settings
%   with other links. \Arg{type} should e.g. be |Link/URI|. %!!!!!syntax?
% \end{function}
% \begin{function}[added = 2019-09-05]
%   {\pdfannot_box_last:}
%   \begin{syntax}
%     \cs{pdfannot_box_last:}
%   \end{syntax}
%   This retrieves the object reference of the last box annotation created.
% \end{function}
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdfannot_box:nnnn #1 #2 #3 #4
  {
    \__pdf_backend_annotation:nnnn {#1}{#2}{#3}{#4}
    \bool_gset_false:N\g_@@_use_lastlink_bool
  }

\cs_new:Npn \pdfannot_box_last:
  {
    \__pdf_backend_annotation_last:
  }

\cs_new_protected:Npn \pdfannot_box:nnnnn #1 #2 #3 #4 #5
  {
    \exp_args:Nx
    \__pdf_backend_annotation:nnnn {#2}{#3}{#4}
      {
        \pdfdict_if_exist:nT { l_@@/#1 }
          {
            \pdfdict_use:n { l_@@/#1}
          }
        #5
      }
    \bool_gset_false:N\g_@@_use_lastlink_bool
  }
%</package>
%    \end{macrocode}
% \subsection{Flags}
% Every flag should have an associated property that allows to set/clear flag positions by
% name. The name is \cs{c_@@_flag_\#1_prop}
% \begin{NOTE}{UF}
% not sure about this yes, reconsider (naming, implementation ...)
% \end{NOTE}
%    \begin{macrocode}
%<*package>
%<@@=pdf>
\cs_new_protected:Npn \pdf_flag_new:nn #1 #2
  {
    \bitsetReset  { @@_#1_flag }
    \prop_const_from_keyval:cn { c_@@_flag_#1_prop }
      {
        #2
      }
  }

\pdf_flag_new:nn {annot/Link}
  {
    Invisible      = 0,
    Hidden         = 1,
    Print          = 2,
    NoZoom         = 3,
    NoRotate       = 4,
    NoView         = 5,
    ReadOnly       = 6,
    Locked         = 7,
    ToggleNoView   = 8,
    LockedContents = 9
  }

\pdf_flag_new:nn {annot/Field} %name is wrong ... form?? it is not really an annot,
  {
    ReadOnly          = 0,
    Required          = 1,
    NoExport          = 2,
    Multiline         = 12,%Tx
    Password          = 13,
    NoToggleToOff     = 14,%Btn, radio button
    Radio             = 15,%Btn: Radio:    15=1, 16=0
    Pushbutton        = 16,%Btn: Checkbox: 15=0, 16=0
                           %Btn: Pushbutton: 16=1
    Combo             = 17,%Ch: Combo=1 List=0
    Edit              = 18,%Ch, Combo=1 -> + edit field
    Sort              = 19,%Ch, not relevant for view...
    FileSelect        = 20,%Tx
    MultiSelect       = 21,%Ch
    DoNotSpellCheck   = 22,%Tx, Ch (if Combo + Edit set)
    DoNotScroll       = 23,%Tx
    Comb              = 24,%Tx, requires MaxLen in dict
    RadiosInUnison    = 25,%Btn Radio
    RichText          = 25,%Tx
    CommitOnSelChange = 26
  }

\pdf_flag_new:nn {annot/Field/submit} %name is wrong ...
  {
    Include/Exclude       = 0,
    IncludeNoValueFields  = 1,
    ExportFormat          = 2,
    GetMethod             = 3, % if ExportFormat=0 -> =0 to
    SubmitCoordinates     = 4, % if ExportFormat=0 -> =0 to
    XFDF                  = 5,
    IncludeAppendSaves    = 6,
    IncludeAnnotations    = 7,
    SubmitPDF             = 8,
    CanonicalFormat       = 9,
    ExclNonUserAnnots     = 10,
    ExclFKey              = 11,
    EmbedForm             = 12
  }

% #1: type, e.g. annot/Link
% #2: name of flag, e.g. Print
\cs_new_protected:Npn \pdf_flag_set:nn #1 #2
  {
    \bitsetSet  { @@_#1_flag }
      { \prop_item:cn {c_@@_flag_#1_prop} {#2} }
  }

\cs_new_protected:Npn \pdf_flag_clear:nn #1 #2
  {
    \bitsetClear{ @@_#1_flag }
      { \prop_item:cn {c_@@_flag_#1_prop} {#2} }
  }

%flags are output as decimals.
\cs_new:Npn \pdf_flag_use:n #1
  {
    \bitsetGetDec { @@_#1_flag }
  }
%</package>
%    \end{macrocode}
% \subsection{Annotations, subtype Widget}\label{pdf:annot:widget}
% The local dictionary \texttt{annot/Widget} is a sceleton
% dictionary for this subtype. It currently contains as only entry
% the subtype setting (the /Type is added by the backend).
%    \begin{macrocode}
%<*package>
%<@@=pdfannot>
\pdfdict_new:n { l_@@/Widget}
\pdfdict_put:nnn {l_@@/Widget}{Subtype}{/Widget}
%</package>
%    \end{macrocode}
% \subsection{Annotations, subtype Link}\label{sec:links}
% Packages like hyperref, ocgx2 and tagpdf all wants to add code
% to link annotation. So we need commands to start and end a link which allows
% packages to add their code through hooks. There are three places in a link where
% hooks are needed: At the begin (for example for a structure command or color),
% in the \emph{attr spec} of the link (for example for the border), and
% at the end of the link (to close a structure or the color group).
%
% The values for \emph{attr spec} are dictionary values, the order they are
% inserted in the dictionary doesn't matter. So they are stored
% like for other dictionary values in a property list, with the key the name
% without a slash. Packages can add \emph{attr spec} entries through
% dedicated hook commands described below.
%
% Code for the begin and end hooks are stored in sequences. This allows some
% ordering.
%
% The code assumes that there will be different link types
% (currently URI, GoToR, Launch, GoTo, Named, hyperref uses the names
%  url,file,run,link,menu) and that
% links of the same type share the \emph{attr spec} and also the same begin/end
% code. The list of link types need to stay restricted and well documented so that
% all packages know which types they have to handle. It is stored in a constant
% seq.
% \begin{NOTE}{UF}
% Perhaps a |cite| type will be useful at some time. -- Thinking more about it,
% a |cite| type is not sensible. hyperref supports it, but it doesn't fit in.
% Commands like cite, gls, acro, footnote and so one should locally change
% linkcolor and linkbordercolor.
% Probably we will need some commands to add an attribute to all link types
% at once.
% hyperref commands for the various type:
% url  |\hyper@linkurl|,
% file |\hyper@linkfile|,
% run  |\@hyper@launch run|,
% link |\hyper@link|, |\find@pdflink|
% menu |\Acrobatmenu|
% \end{NOTE}
% \begin{variable}[added = 2020-03-12]{ \c_pdfannot_link_types_seq }
% This constant sequence contains the list of currently supported link types
% for which hooks and dictionaries exist.
% \end{variable}
%
%    \begin{macrocode}
%<*package>
\seq_const_from_clist:Nn \c_pdfannot_link_types_seq { URI , GoToR , Launch , GoTo, Named }

\seq_map_inline:Nn \c_pdfannot_link_types_seq
  {
    \pdfdict_new:n { l_@@/Link/#1 }
    \pdfdict_put:nnn { l_@@/Link/#1}{ F }{ \pdf_flag_use:n { annot/Link} }
    \hook_new_pair:nn
      {pdfannot/Link/#1/before}
      {pdfannot/Link/#1/after}
    \seq_new:c  { l_@@_hook/Link/#1_begin_seq }
    \seq_new:c  { l_@@_hook/Link/#1_end_seq }
  }
%</package>
%    \end{macrocode}


% \subsubsection{Annotations, subtype Link /management}
%
% \begin{function}[added = 2020-03-12, updated = 2020-04-14]{ \pdfannot_link:nnn }
%   \begin{syntax}
%     \cs{pdfannot_link:nnn} \Arg{type} \Arg{user action spec} \Arg{link text}
%   \end{syntax}
%  This creates a link around the \Arg{link text} with the specified
%  \Arg{user action spec}\footnote{The wording follows the pdftex documentation}.
%  \texttt{/Subtype/Link} is added automatically.
%  If \texttt{annot/Link/}\Arg{type} is a known local dictionary
%  attributes stored in dictionary of type \Arg{type} are inserted as
%  \emph{attr spec} and the code in
%  the begin and end hook is executed  before and after the link. \Arg{type} should
%  normally be identical to the value of the |/S| key in the action dictionary.
%  As example
%  \begin{verbatim}
%    \pdfannot_link:nnn { URI }
%     {
%       /A
%         <<
%           /Type/Action
%           /S/URI
%           /URI(https://www.latex-project.org)
%         >>
%     }
%     { link text }
%    \end{verbatim}
% \end{function}
%
%    \begin{macrocode}
%
%<*package>
\cs_new_protected:Nn \pdfannot_link:nnn %#1 type (URI, GoTo etc),
                                        %#2 action spec, #3 link text
  {
    \hook_use:n { pdfannot/Link/#1/before}
    \mode_leave_vertical:
    \exp_args:Nxx %xetex needs expansion
    \@@_backend_link_begin_user:nnw
      {
         \pdfdict_if_exist:nT { l_@@/Link/#1 }
          {
            \pdfdict_use:n { l_@@/Link/#1}
          }
      }
      {
        /Subtype/Link
        #2
      }
    \bool_gset_true:N \g_@@_use_lastlink_bool
    #3
    \@@_backend_link_end:
    \bool_gset_true:N \g_@@_use_lastlink_bool
    \hook_use:n { pdfannot/Link/#1/after}
  }
%</package>
%    \end{macrocode}
% \begin{function}[added = 2020-03-12]{ \pdfannot_link_begin:nnw, \pdfannot_link_end:n }
%   \begin{syntax}
%     \cs{pdfannot_link_begin:nnw} \Arg{type} \Arg{user action spec} \meta{content}
%     \cs{pdfannot_link_end:n} \Arg{type}
%   \end{syntax}
%  This creates a link around the \meta{content} with the specified
%  \meta{user action spec} (e.g. an /A dictionary with an URI) or
%  \meta{destination} (a name as defined with the
%  first argument of \cs{pdf_destination:nn}).
%  \texttt{/Subtype/Link} is added automatically.
%  In contrast to \cs{pdfannot_link:nnn} this function
%  does not absorb the argument when finding the \meta{content}, and so can
%  be used in circumstances where the \meta{content} may not be a simple
%  argument.
%  If \texttt{annot/Link/}\Arg{type} is a known local dictionary
%  attributes stored in dictionary of type \Arg{type} are inserted as
%  \emph{attr spec} and the code in the begin and end hook is executed
%  before and after the link. As example
%  \begin{verbatim}
%    \pdfannot_link_begin:nnw { URI }
%     {
%       /A<<
%         /Type/Action
%         /S/URI
%         /URI(https://www.latex-project.org)
%       >>
%     }
%     link text
%    \pdfannot_link_end:n { URI }
%    \end{verbatim}
% \end{function}
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdfannot_link_begin:nnw #1 #2 %#1 type, #2 action spec
  {
    \hook_use:n { pdfannot/Link/#1/before}
    \exp_args:Nxx %xetex needs expansion
      \__pdf_backend_link_begin_user:nnw
        {
           \pdfdict_if_exist:nT { l_@@/Link/#1 }
            {
              \pdfdict_use:n { l_@@/Link/#1}
            }
        }
        { #2 }
      \bool_gset_true:N \g_@@_use_lastlink_bool
  }

\cs_new_protected:Nn \pdfannot_link_end:n %#1 type, e.g. url
  {
    \__pdf_backend_link_end:
    \bool_gset_true:N \g_@@_use_lastlink_bool
    \hook_use:n { pdfannot/Link/#1/after}
  }
%</package>
%    \end{macrocode}
% \begin{function}[updated = 2020-03-30]{ \pdfannot_link_goto_begin:nw, \pdfannot_link_goto_end: }
%   \begin{syntax}
%     \cs{pdfannot_link_goto_begin:nw} \Arg{destination} \meta{content}
%     \cs{pdfannot_link_goto_end:}
%   \end{syntax}
% This is a special, shorter version for links to internal destinations. It always
% uses the hooks and dictionary of the |GoTo| link type.
% \end{function}
%     \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdfannot_link_goto_begin:nw #1 %#1 destination
  {
    \hook_use:n { pdfannot/Link/GoTo/before}
    \exp_args:Nxx %xetex needs expansion
    \__pdf_backend_link_begin_goto:nnw
      {
        \pdfdict_use:n { l_@@/Link/GoTo}

      }
      { #1 }
     \bool_gset_true:N \g_@@_use_lastlink_bool
  }

\cs_new_protected:Nn \pdfannot_link_goto_end:
  {
    \__pdf_backend_link_end:
    \bool_gset_true:N \g_@@_use_lastlink_bool
     \hook_use:n { pdfannot/Link/GoTo/after}
  }
%</package>
%    \end{macrocode}
% \begin{function}[added = 2020-03-12]{  \pdfannot_link_last: }
%   This retrieves the object reference a previously link created with the commands
%   above. This doesn't work currently with xelatex but a feature request has
%   been made.
% \end{function}
%    \begin{macrocode}
%<*package>
\cs_new:Nn \pdfannot_link_last: { \__pdf_backend_link_last: }
%</package>
%    \end{macrocode}
% \begin{function}[added = 2020-06-29]{  \pdfannot_last: }
%   This retrieves the object reference a previously annotation
%   created either with a link or a box command. When the last was a link
%   it won't work with xelatex.
% \end{function}
%    \begin{macrocode}
%<*package>
\cs_new:Npn \pdfannot_last:
  {
    \bool_if:NTF \g_@@_use_lastlink_bool
      {
        \__pdf_backend_link_last:
      }
      {
        \__pdf_backend_annotation_last:
      }
  }
%</package>
%    \end{macrocode}
% %!!!! only annot link or also annot??
% \begin{function}[added = 2020-03-12]{  \pdfannot_link_margin:n }
%  \begin{syntax}
%    \cs{pdfannot_link_margin:n} \Arg{dimen}
%  \end{syntax}
%   This sets the dimension of the link margin.
% \end{function}
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdfannot_link_margin:n #1
  {
    \__pdf_backend_link_margin:n { #1 }
  }

%</package>
%    \end{macrocode}
%
% \begin{function}[added = 2020-12-04]{ \pdfannot_dict_put:nnn }
%  \begin{syntax}
%    \cs{\pdfannot_dict_put:nnn} \Arg{dictionary name} \Arg{key} \Arg{value}
%  \end{syntax}
%   This adds (locally) a key-value to the internal annot dictionary
% \end{function}
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdfannot_dict_put:nnn #1 #2 #3
  {
    \pdfdict_put:nnn { l_@@/#1 } { #2 }{ #3 }
  }

%</package>
%    \end{macrocode}
% \begin{function}[added = 2020-12-04]{ \pdfannot_dict_remove:nn }
%  \begin{syntax}
%    \cs{\pdfannot_dict_remove:nn} \Arg{dictionary name} \Arg{key}
%  \end{syntax}
%   This removes a key-value from the internal annot dictionary
% \end{function}
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdfannot_dict_remove:nn #1 #2
  {
    \pdfdict_remove:nn { l_@@/#1 } { #2 }
  }

%</package>
%    \end{macrocode}
% \begin{function}[added = 2020-12-04]{ \pdfannot_dict_show:n }
%  \begin{syntax}
%    \cs{\pdfannot_dict_show:n} \Arg{dictionary name}
%  \end{syntax}
%   This shows the content of the internal annot dictionary
% \end{function}
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \pdfannot_dict_show:n #1
  {
    \pdfdict_show:n { l_@@/#1 }
  }

%</package>
%    \end{macrocode}
% \subsection{Destinations}
% \begin{NOTE}{UF}
% I'm unsure about the backend code of the rectangle (FitR) variant. Should it
% really typeset a box???
% I'm also unsure if \cs{pdf_destination:nn} should really allow both
% a type and an integer as second argument. Perhaps a \cs{pdf_destination_zoom:nn}
% would be better??
% \end{NOTE}
% Destinations are \enquote{anchors} for links. The commands here
% create named destinations. The pdf\LaTeX{} primitive doesn't support all
% variants described in the pdf reference. The backend code expect lower case
% arguments, but we add support for the casing of hyperref and the pdf reference.
%
% \begin{tabular}{llll}
% Type             & status    & input    &remark \\\hline
% /Fit             & supported & fit, Fit \\%
% /FitH            & supported & fith, FitH \\
% /FitH \emph{top} & not supported\\
% /FitV            & supported & fitv, FitV\\
% /FitV \emph{left}& not supported\\
% /FitB            & supported & fitb, FitB\\
% /FitBH           & supported & fitbh, FitBH\\
% /FitBH \emph{top}& not supported\\
% /FitBV           & supported & fitbv, FitBV\\
% /FitBV \emph{left} & not supported\\
% /FitR \emph{left bottom right top} & supported in part& typesets a box\\
% /XYZ \emph{left} \emph{top} NULL & supported & xyz, XYZ &left, top are automatic\\
% /XYZ \emph{left} \emph{top} zoom & supported & integer (percent) &left, top are automatic\\
% \end{tabular}
%
% \begin{function}[added = 2020-03-10]
%   {\pdf_destination:nn}
%   \begin{syntax}
%     \cs{pdf_destination:nn} \Arg{name} \Arg{type or integer}
%   \end{syntax}
%   This creates a destination. \Arg{type or Integer} can be one of |Fit|, |FitH|,
%   |FitV|, |FitB|, |FitBH|, |FitBV|, |XYZ| and the lower case variants,
%   or an integer representing a  scale factor in percent.
% \end{function}
% \begin{function}[added = 2020-03-10]
%   {\pdf_destination_box:nn}
%   \begin{syntax}
%     \cs{pdf_destination_box:nn} \Arg{name} \Arg{content}
%   \end{syntax}
%   This stores the content in a hbox, outputs the box and
%   creates a destination with |FitR| type encompassing this box.
% \end{function}
%    \begin{macrocode}
%<*package>
%<@@=pdf>
% perhaps some manipulation of the argument will be needed to map the current
% hyperref syntax
% unclear currently if is this is useful for anything.
\prop_new:N   \l_@@_views_map_prop
\prop_put:Nnn \l_@@_views_map_prop {XYZ} { xyz }
\prop_put:Nnn \l_@@_views_map_prop {xyz} { xyz }
\prop_put:Nnn \l_@@_views_map_prop {Fit} { fit }
\prop_put:Nnn \l_@@_views_map_prop {fit} { fit }
\prop_put:Nnn \l_@@_views_map_prop {FitB} { fitb }
\prop_put:Nnn \l_@@_views_map_prop {fitb} { fitb }
\prop_put:Nnn \l_@@_views_map_prop {FitBH} { fitbh }
\prop_put:Nnn \l_@@_views_map_prop {fitbh} { fitbh }
\prop_put:Nnn \l_@@_views_map_prop {FitBv} { fitbv }
\prop_put:Nnn \l_@@_views_map_prop {fitbv} { fitbv }
\prop_put:Nnn \l_@@_views_map_prop {FitH} { fith }
\prop_put:Nnn \l_@@_views_map_prop {fith} { fith }
\prop_put:Nnn \l_@@_views_map_prop {FitV} { fitv }
\prop_put:Nnn \l_@@_views_map_prop {fitv} { fitv }

\cs_new_protected:Npn \pdf_destination:nn #1 #2
 {
  \prop_if_in:NnTF \l_@@_views_map_prop { #2 }
   {
    \exp_args:Nox %xetex?
    \@@_backend_destination:nn { #1 } { \prop_item:Nn \l_@@_views_map_prop {#2} }
   }
   {
    \exp_args:No %xetex?
    \@@_backend_destination:nn { #1 } { #2 }
    % should we assume that it is a zoom value then??
    % should we test that it is really a number?
    % or should there be a third argument for this case and for other coordinates?
   }
 }
\cs_generate_variant:Nn\pdf_destination:nn {no,nf}

\cs_new_protected:Npn \pdf_destination_box:nn #1 #2 %#1 name, #2 box content
 {
   \@@_backend_destination_box:nn { #1 }{ #2 } %new name!!
 }

%</package>
%    \end{macrocode}
%%
% \section{Drop?}
% \subsubsection{Doc View/Openaction}
% Dropped for now. Is probably not needed
% \begin{NOTE}{UF}
%   /OpenAction can be an array:
%   |/OpenAction [5 0 R /Fit]| or an action: |<< /S /GoTo /D [ 7 0 R /Fit ] >>|.
%  The implementation below allows only the first. It is not quite clear, if
%  this is sensible (and if a special docview command is needed at all).
%  The second could be set directly.
% \end{NOTE}
%
% \begin{function}[added = 2019-08-18]
%   {\pdf_docview:nn}
%   \begin{syntax}
%     \cs{pdf_docview:nn} \Arg{page} \Arg{view}
%   \end{syntax}
% This command allows to set the OpenAction array. The \meta{page}
% is an absolute page number. \Arg{view} a string for the destination
% without the leading slash. Examples are e.g. |XYZ left top zoom| or |Fit|.
% The OpenAction uses (and could also be set directly with)
% \cs{pdfmanagement_add:nnn}|{Catalog}|.
% \end{function}
%
%    \begin{macrocode}
%<*package>
%\cs_new_protected:Npn \pdf_docview:nn #1 #2
%  {
%    \pdfmanagement_add:nnx {Catalog }{ OpenAction }{[\pdf_object_pageref:n {#1}~/#2]}
%  }
%</package>
%    \end{macrocode}

%
% \end{implementation}
%
% \PrintIndex
