% \iffalse meta-comment
%
%% File: l3backend-pdf.dtx
%
% Copyright (C) 2019,2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "pdfresources bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/pdfresources
%
% for those people who are interested.
%
%
%<*driver>
\documentclass[full,kernel]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \textsf{l3backend-pdf-extra} package\\ Additional backend PDF features^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released XXXX-XX-XX}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3backend-pdf-extra} Implementation}
%
%    \begin{macrocode}
%<@@=pdf>
%    \end{macrocode}
% \subsection{some zref code, needs to be replaced later}
% a reference for the absolute page counter. This uses the counter from the
% new lthooks/ltshipout package.
%    \begin{macrocode}
%<*drivers>
\zref@newlist  { l3pdf }
\zref@newprop* { pdf@abspage } [0] { \int_use:N \g_shipout_readonly_int }
\zref@addprop  { l3pdf } { pdf@abspage }
%</drivers>
%    \end{macrocode}
%
% \begin{variable}
%  {\g_@@_backend_resourceid_int, \g_@@_backend_name_int, \g_@@_backend_page_int}
%  a counter to create labels for the resources, a counter
%  to number properties in bdc marks, a counter for the \cs{pdfpageref} implementation.
%    \begin{macrocode}
%<*drivers>
\int_new:N \g_@@_backend_resourceid_int
\int_new:N \g_@@_backend_name_int
\int_new:N \g_@@_backend_page_int
%</drivers>
%    \end{macrocode}
% \end{variable}
% \subsection{luacode}
% Load the lua code.
%    \begin{macrocode}
%<*pdfmode>
\sys_if_engine_luatex:T
  {
    \directlua { require("pdfresources.lua") }
  }
%</pdfmode>
%    \end{macrocode}
% \subsection{Hooks}
% \subsubsection{Add the \enquote{end run} hooks}
% Here we add the end run hook to suitable
% end hooks.
%    \begin{macrocode}
%<*pdfmode>
\hook_gput_code:nnn {enddocument/afterlastpage}
  {pdf/endrun}
  {
    \hook_use:n {pdf/coredict/end_run}
  }
%</pdfmode>
%<*dvipdfmx|xdvipdfmx>
\hook_gput_code:nnn {shipout/lastpage}
  {pdf/endrun}
  {
    \hook_use:n {pdf/coredict/end_run}
  }
\hook_gset_rule:nnnn {shipout/lastpage}{pdf}{before}{pdf/endrun}
%</dvipdfmx|xdvipdfmx>
%<*dvips>
\hook_gput_code:nnn {shipout/lastpage}
  {pdf/endrun}
  {
    \hook_use:n {pdf/coredict/end_run}
  }
\hook_gset_rule:nnnn {shipout/lastpage}{pdf}{before}{pdf/endrun}
%</dvips>
%    \end{macrocode}
% \subsubsection{Add the \enquote{shipout} hooks}
% Now we add to the shipout hooks the relevant token lists.
%    \begin{macrocode}
%<*drivers>
\hook_gput_code:nnn{shipout/background}{pdf}
  {
    \hook_use:n {pdf/coredict/thispage_shipout}
  }
\hook_gput_code:nnn {shipout/lastpage} {pdf}
  {
     \hook_use:n {pdf/coredict/lastpage_shipout}
  }
%</drivers>
%    \end{macrocode}
% \subsection{ The /Pages dictionary (pdfpagesattr) }
% \begin{macro}{\@@_backend_Pages_primitive:n}
% This is the primitive command to add something to the /Pages dictionary.
% It works differently for the backends: pdftex and luatex overwrite existing
% content, dvips and dvipdfmx are additive. luatex sets it in lua.
% The higher level code has to take this into account.
%    \begin{macrocode}
%<*pdfmode>
\sys_if_engine_pdftex:T
  {
    \cs_new_protected:Npn \@@_backend_Pages_primitive:n #1
      {
        \tex_global:D \tex_pdfpagesattr:D { #1 }
      }
  }
%luatex: does it in lua
\sys_if_engine_luatex:T
  {
    \cs_new_protected:Npn \@@_backend_Pages_primitive:n #1
      {
        \tex_directlua:D
          {
            pdf.setpagesattributes( \@@_backend_luastring:n { #1 } )
          }
      }
  }
%</pdfmode>
%<*dvips>
\cs_new_protected:Npx \@@_backend_Pages_primitive:n #1
  {
    \tex_special:D{ps:~[#1~/PAGES~pdfmark} %]
  }
%</dvips>
%<*dvipdfmx|xdvipdfmx>
\cs_new_protected:Npn \@@_backend_Pages_primitive:n #1
  {
    \@@_backend:n{put~@pages~<<#1>>}
  }
%</dvipdfmx|xdvipdfmx>
%    \end{macrocode}
% \end{macro}
%
% \subsection{\enquote{Page} and \enquote{ThisPage} attributes (pdfpageattr)}
% \begin{NOTE}{UF}
%  path: Page
%  !!!!!!!!!!!!!!!!!!!!!!
%  This part of the code depends on zref as it sets labels.
%  It also depends on code in coredict as the code uses the Core-dictionaries
%  !!!!!!!!!!!!!!!!!!!!!!
%
%  The engines differ a lot here: pdflatex and lualatex uses a register while with
%  dvips/dvipdfmx a one-shot-special is used. So for pdflatex and lualatex code
%  to assemble the content of the register is needed. Specials are used at shipout,
%  the registers is set directly. With lualatex one can use
%  \cs{latelua} to delay the setting, with pdflatex one has to use a shipout hook.
%  To get the code on the correct page one has to use the aux with pdflatex.
%  In sum this means that quite a lot backend commands are needed to handle
%  this differences. Simply variants of \cs{pdfpageattr} are not enough ...%
%  dvips syntax: \special{ps: [{ThisPage}<</Rotate 90>> /PUT pdfmark}%
%  There seem to be an in-built management code: multiple uses don't lead to
%  multiple entries (/Rotate is special: there is always a /Rotate 0 in the dict,
%  but seems not to do harm).
%  dvipdfmx syntax: \special{pdf: put @thispage << /Rotate 90 >>},
%  like dvips the backend has an in-built  management code.
%  Both change only the current page, so to get the pdftex behavior (which sets
%  also the following pages) one need to repeat it on every shipout.
% \end{NOTE}
% \begin{macro}
%   {
%     \@@_backend_Page_primitive:n,
%     \@@_backend_Page_gput:nn,
%     \@@_backend_Page_gremove:n,
%     \@@_backend_ThisPage_gput:nn,
%     \@@_backend_ThisPage_gpush:n
%   }
% \cs{@@_backend_Page_primitive:n} is the primitive command to add
% something to the /Page dictionary.
% It works differently for the backends: pdftex and luatex overwrite existing
% content, dvips and dvipdfmx are additive. luatex sets it in lua.
% The higher level code has to take this into account.
% \cs{@@_backend_Page_gput:nn} stores default values.
% \cs{@@_backend_Page_gremove:n} allows to remove a value.
% \cs{@@_backend_ThisPage_gput:nn} adds a value to the current page.
% \cs{@@_backend_ThisPage_gpush:n} merges the default and the current page values
% and add them to the dictionary of the current page in
% \cs{g_@@_backend_thispage_shipout_tl}.
%    \begin{macrocode}
%  backend commands
%<*pdfmode>
\sys_if_engine_pdftex:T
  {
    %the primitive
    \cs_new_protected:Npn \@@_backend_Page_primitive:n #1
      {
        \tex_global:D \tex_pdfpageattr:D { #1 }
      }
  % the command to store default values.
  % Uses a prop with pdflatex + dvi,
  % sets a lua table with lualatex
   \cs_new_protected:Npn \@@_backend_Page_gput:nn #1 #2 %key,value
     {
       \pdfdict_gput:nnn {Core/Page}{ #1 }{ #2 }
     }
  % the command to remove a default value.
  % Uses a prop with pdflatex + dvi,
  % changes a lua table with lualatex
  \cs_new_protected:Npn \@@_backend_Page_gremove:n #1
    {
      \pdfdict_gremove:nn  {Core/Page}{ #1 }
    }
 % the command used in the document.
 % direct call of the primitive special with dvips/dvipdfmx
 % \latelua: fill a page related table with lualatex, merge it with the page
 % table and push it directly
 % write to aux and store in prop with pdflatex
  \cs_new_protected:Npn \@@_backend_ThisPage_gput:nn #1 #2
    {
      %we need to know the page the resource should be added too.
      \int_gincr:N\g_@@_backend_resourceid_int
      \zref@labelbylist {l3pdf\int_use:N\g_@@_backend_resourceid_int} {l3pdf}
      \tl_set:Nx \l_@@_tmpa_tl
        {
          \zref@extractdefault
            {l3pdf\int_use:N\g_@@_backend_resourceid_int}
            {pdf@abspage}
            {0}
        }
      \pdfdict_if_gexist:nF {Core/backend_Page\l_@@_tmpa_tl}
        {
          \pdfdict_gnew:n          {Core/backend_Page\l_@@_tmpa_tl}
        }
      %\__pdfcoredict_handler_gput:nnn {backend_Page\l_@@_tmpa_tl}{ #1 }{ #2 }
      %backend_Page has no handler.
      \pdfdict_gput:nnn {Core/backend_Page\l_@@_tmpa_tl}{ #1 }{ #2 }
    }
  %the code to push the values, used in shipout
  %merges the two props and then fills the register in pdflatex
  %merges the two tables and then fills (in lua) in luatex
  %issues the values stored in the global prop with dvi
  \cs_new_protected:Npn \@@_backend_ThisPage_gpush:n #1
    {
      \prop_gset_eq:Nc \g_@@_tmpa_prop { \pdfdict_gname:n  { Core/Page } }
      \prop_if_exist:cT  { \pdfdict_gname:n  { Core/backend_Page#1 } }
        {
          \prop_map_inline:cn { \pdfdict_gname:n  { Core/backend_Page#1 } }
            {
              \prop_gput:Nnn \g_@@_tmpa_prop { ##1 }{ ##2 }
            }
        }
      \exp_args:Nx \@@_backend_Page_primitive:n
        {
          \prop_map_function:NN \g_@@_tmpa_prop \pdfdict_item:ne
        }
    }
  }

\sys_if_engine_luatex:T
  {% do we need to use some escaping for the values?????
    \cs_new:Npn \@@_backend_luastring:n #1
      {
        "\tex_luaescapestring:D { \tex_unexpanded:D { #1 } }"
      }
 %not used, only there for consistency
    \cs_new_protected:Npn \@@_backend_Page_primitive:n #1
      {
        \tex_latelua:D
          {
            pdf.setpageattributes(\@@_backend_luastring:n { #1 })
          }
      }
  % the command to store default values.
  % Uses a prop with pdflatex + dvi,
  % sets a lua table with lualatex
    \cs_new_protected:Npn \@@_backend_Page_gput:nn #1 #2
      {
        \tex_directlua:D
          {
            l3kernel.@@.backend_Page_gput
              (
                \@@_backend_luastring:n { #1 },
                \@@_backend_luastring:n { #2 }
              )
          }
      }
  % the command to remove a default value.
  % Uses a prop with pdflatex + dvi,
  % changes a lua table with lualatex
  \cs_new_protected:Npn \@@_backend_Page_gremove:n #1
    {
      \tex_directlua:D
        {
          l3kernel.@@.backend_Page_gremove (\@@_backend_luastring:n { #1 })
        }
    }
 % the command used in the document.
 % direct call of the primitive special with dvips/dvipdfmx
 % \latelua: fill a page related table with lualatex, merge it with the page
 % table and push it directly
 % write to aux and store in prop with pdflatex
  \cs_new_protected:Npn \@@_backend_ThisPage_gput:nn #1 #2
    {
      \tex_latelua:D
        {
          l3kernel.@@.backend_ThisPage_gput
            (
              tex.count["g_shipout_readonly_int"],
              \@@_backend_luastring:n { #1 },
              \@@_backend_luastring:n { #2 }
            )
          l3kernel.@@.backend_ThisPage_gpush (tex.count["g_shipout_readonly_int"])
        }
    }
  %the code to push the values, used in shipout
  %merges the two props and then fills the register in pdflatex
  %merges the two tables (the one is probably still empty) and then fills (in lua) in luatex
  %issues the values stored in the global prop with dvi
  \cs_new_protected:Npn \@@_backend_ThisPage_gpush:n #1
    {
      \tex_latelua:D
        {
          l3kernel.@@.backend_ThisPage_gpush (tex.count["g_shipout_readonly_int"])
        }
    }
  }
%</pdfmode>
%<*dvipdfmx|xdvipdfmx>
  %the primitive
\cs_new_protected:Npn \@@_backend_Page_primitive:n #1
  {
    \tex_special:D{pdf:~put~@thispage~<<#1>>}
  }
  % the command to store default values.
  % Uses a prop with pdflatex + dvi,
  % sets a lua table with lualatex
\cs_new_protected:Npn \@@_backend_Page_gput:nn #1 #2
  {
    \pdfdict_gput:nnn {Core/Page}{ #1 }{ #2 }
  }
  % the command to remove a default value.
  % Uses a prop with pdflatex + dvi,
  % changes a lua table with lualatex
\cs_new_protected:Npn \@@_backend_Page_gremove:n #1
   {
     \pdfdict_gremove:nn  {Core/Page}{ #1 }
   }
  % the command used in the document.
  % direct call of the primitive special with dvips/dvipdfmx
  % \latelua: fill a page related table with lualatex, merge it with the page
  % table and push it directly
  % write to aux and store in prop with pdflatex
\cs_new_protected:Npn \@@_backend_ThisPage_gput:nn #1 #2
  {
    \@@_backend_Page_primitive:n { /#1~#2 }
  }
  %the code to push the values, used in shipout
  %merges the two props and then fills the register in pdflatex
  %merges the two tables (the one is probably still empty)
  % and then fills (in lua) in luatex
  %issues the values stored in the global prop with dvi
\cs_new_protected:Npn \@@_backend_ThisPage_gpush:n #1
  {
    \exp_args:Nx \@@_backend_Page_primitive:n
      { \pdfdict_gmap:n {Core/Page} }
  }
%</dvipdfmx|xdvipdfmx>
%<*dvips>
\cs_new_protected:Npn \@@_backend_Page_primitive:n #1
   {
     \tex_special:D{ps:~[{ThisPage}<<#1>>~/PUT~pdfmark} %]
   }
  % the command to store default values.
  % Uses a prop with pdflatex + dvi,
  % sets a lua table with lualatex
\cs_new_protected:Npn \@@_backend_Page_gput:nn #1 #2
   {
     \pdfdict_gput:nnn {Core/Page}{ #1 }{ #2 }
   }
  % the command to remove a default value.
  % Uses a prop with pdflatex + dvi,
  % changes a lua table with lualatex
\cs_new_protected:Npn \@@_backend_Page_gremove:n #1
  {
    \pdfdict_gremove:nn  {Core/Page}{ #1 }
  }
  % the command used in the document.
  % direct call of the primitive special with dvips/dvipdfmx
  % \latelua: fill a page related table with lualatex, merge it with the page
  % table and push it directly
  % write to aux and store in prop with pdflatex
\cs_new_protected:Npn \@@_backend_ThisPage_gput:nn #1 #2
  {
    \@@_backend_Page_primitive:n { /#1~#2 }
  }
  %the code to push the values, used in shipout
  %merges the two props and then fills the register in pdflatex
  %merges the two tables (the one is probably still empty)
  %and then fills (in lua) in luatex
  %issues the values stored in the global prop with dvi
\cs_new_protected:Npn \@@_backend_ThisPage_gpush:n #1
  {
    \exp_args:Nx \@@_backend_Page_primitive:n
          { \pdfdict_gmap:n {Core/Page} }
  }
%</dvips>
%    \end{macrocode}
% \end{macro}
%
% \subsection{\enquote{Page/Resources}: ExtGState, ColorSpace, Shading, Pattern}
% Path: Page/Resources/ExtGState etc. The actual output of the resources is handled
% together with the bdc/Properties. Here is only special code.
% \begin{macro}{\@@_backend_PageResources_gput:nnn}
% stores values for the page resources.
% \begin{arguments}
% \item name of the resource (ExtGState, ColorSpace, Shading, Pattern)
% \item a pdf name without slash
% \item value
% \end{arguments}
% \begin{macro}{\@@_backend_PageResources_obj_gpush:}
% This pushes out the objects. It is a no-op with xdvipdfmx and dvips.
%    \begin{macrocode}
% backend commands the command to fill the register
% and to push the values.
%
% The names are quite often needed
%<*drivers>
\clist_const:Nn \c_@@_backend_PageResources_clist
  {
    ExtGState,
    ColorSpace,
    Pattern,
    Shading,
  }

\clist_map_inline:Nn \c_@@_backend_PageResources_clist
      {
        \pdfdict_gnew:n {Core/Page/Resources/#1}
      }
%</drivers>
% pdftex and luatex
%<*pdfmode>
 %create the backend objects:
\clist_map_inline:Nn \c_@@_backend_PageResources_clist
  {
    \@@_backend_object_new:nn {Page/Resources/#1} {dict}
    \cs_if_exist:NT \tex_directlua:D
      {
        \tex_directlua:D
          {
            l3kernel.@@.object["Page/Resources/#1"]
            =
            "\@@_backend_object_ref:n{Page/Resources/#1}"
          }
      }
   }
 %values are only stored in a prop and will be output at end document.
\sys_if_engine_luatex:T
  {
    \cs_new_protected:Npn \@@_backend_PageResources_gput:nnn #1 #2 #3
      {
        \pdfdict_gput:nnn {Core/Page/Resources/#1} { #2 }{ #3 }
        % luatex must also trigger the lua side
        \tex_latelua:D{l3kernel.@@.Page.Resources.#1=true}
        \tex_latelua:D
          {
            l3kernel.pdf.Page_Resources_gpush(tex.count["g_shipout_readonly_int"])
          }
      }
  }
\sys_if_engine_pdftex:T
  { %pdftex
    \cs_new_protected:Npn \@@_backend_PageResources_gput:nnn #1 #2 #3
      {
        \pdfdict_gput:nnn {Core/Page/Resources/#1} { #2 }{ #3 }
      }
  }

%code for end of document code
\cs_new_protected:Npn \@@_backend_PageResources_obj_gpush:
  {
    \clist_map_inline:Nn \c_@@_backend_PageResources_clist
      {
        \prop_if_empty:cF
          { \pdfdict_gname:n {Core/Page/Resources/##1} }
          {
            \@@_backend_object_write:nx
              { Page/Resources/##1 }
              { \pdfdict_gmap:n {Core/Page/Resources/##1} }
          }
     }
  }
%</pdfmode>
% xdvipdfmx
% \special{pdf:pageresources<<#1>>} doesn't work correctly with object names ...
% https://tug.org/pipermail/dvipdfmx/2019-August/000021.html,
% so we use \special{pdf:put @resources}
% this must be issued on every page!
%<*dvipdfmx|xdvipdfmx>
%objects should not only be created but also "initialized"
\clist_map_inline:Nn \c_@@_backend_PageResources_clist
  {
    \@@_backend_object_new:nn   { Page/Resources/#1 } { dict }
    \@@_backend_object_write:nn { Page/Resources/#1 } {}
  }

\cs_new_protected:Npn \@@_backend_PageResources:n #1
  {
    \@@_backend:n {put~@resources~<<#1>>}
  }
\cs_new_protected:Npn \@@_backend_PageResources_gput:nnn #1 #2 #3
  {
   % this is not used for output, but there is a test if the resource is empty
   \prop_gput:cnn { \pdfdict_gname:n {Core/Page/Resources/#1} } { #2 }{ #3 }
   %objects are not filled with \pdf_object_write as this is not additive!
    \@@_backend:x
      {
        put~\@@_backend_object_ref:n {Page/Resources/#1}<</#2~#3>>
      }
  }

\cs_new_protected:Npn \@@_backend_PageResources_obj_gpush: {}
%</dvipdfmx|xdvipdfmx>
%<*dvips>
% dvips unneeded, or no-op
\cs_new_protected:Npn \@@_backend_PageResources:n #1 {}
\cs_new_protected:Npn \@@_backend_PageResources_gput:nnn #1 #2 #3
  { %only for the show command TEST!!
    \pdfdict_gput:nnn {Core/Page/Resources/#1} { #2 }{ #3 }
  }
\cs_new_protected:Npn \@@_backend_PageResources_obj_gpush: {}
%</dvips>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \subsection{\enquote{Catalog} \& subdirectories (pdfcatalog) }
% The backend command is already in the driver:
% \cs{@@_backend_catalog_gput:nn}
% \subsubsection { Special case: the /Names/EmbeddedFiles dictionary }
% Entries to /Names are handled differently, in part (/Desc) it is automatic, for
% other special commands like \cs{pdfnames} must be used. For EmbeddedFiles
% we need some code to push the tree if files have been added. dvips wants code
% for every file and then creates the Name tree automatically.
%    \begin{macrocode}
% pdflatex
%<*pdfmode>
\sys_if_engine_pdftex:T
 {
   \cs_new_protected:Npn \@@_backend_NamesEmbeddedFiles_gpush:n #1 %array content
     {
        \pdf_object_now:nn {dict} {/Names [#1] }
        \pdfnames{/EmbeddedFiles~\pdf_object_last:}
     }
 }

\sys_if_engine_luatex:T
 {
   \cs_new_protected:Npn \@@_backend_NamesEmbeddedFiles_gpush:n #1 %array content
     {
       \pdf_object_now:nn {dict} {/Names [#1] }
       \pdfextension~names~{/EmbeddedFiles~\pdf_object_last: }
     }
 }
%</pdfmode>
%<*dvipdfmx|xdvipdfmx>
\cs_new_protected:Npn \@@_backend_NamesEmbeddedFiles_gpush:n #1 %array content
  {
    \pdf_object_now:nn {dict} { /Names [#1] }
    %n or x?
    \__pdf_backend:x {put~@names~<</EmbeddedFiles~\pdf_object_last: >>}
  }
%</dvipdfmx|xdvipdfmx>

%dvips: noop
%<*dvips>
\cs_new_protected:Npn \@@_backend_NamesEmbeddedFiles_gpush:n #1 {}
%</dvips>
%    \end{macrocode}
% Names in the EmbeddedFiles name tree must sorted alphabetically,
% so we need commands to create this names. And we need a sequence to store
% the names and the objects. We use the prefix l3ef, and we assume that at
% most 9999 files will be used.
% \begin{variable}{\g_@@_backend_EmbeddedFiles_int}
% \end{variable}
% \begin{macro}{\@@_backend_EmbeddedFiles_name:}
%    \begin{macrocode}
%<*drivers>
\int_new:N \g_@@_backend_EmbeddedFiles_int
\cs_new:Npn \@@_backend_EmbeddedFiles_name:
 {
   (
    l3ef
    \int_compare:nNnT {\g_@@_backend_EmbeddedFiles_int} < {10}
     {0}
    \int_compare:nNnT {\g_@@_backend_EmbeddedFiles_int} < {100}
     {0}
    \int_compare:nNnT {\g_@@_backend_EmbeddedFiles_int} < {1000}
     {0}
    \int_use:N \g_@@_backend_EmbeddedFiles_int
   )
 }
%</drivers>
%    \end{macrocode}
% \end{macro}
% \begin{variable}{\g_@@_backend_EmbeddedFiles_seq}
%    \begin{macrocode}
%<*drivers>
\seq_new:N \g_@@_backend_EmbeddedFiles_seq
%</drivers>
%    \end{macrocode}
% \begin{macro}{\@@_backend_NamesEmbeddedFiles_add:nN}
% This command saves an object reference of a filespec dictionary in the
% EmbeddedFiles name tree.
%    \begin{macrocode}
%<*pdfmode|dvipdfmx|xdvipdfmx>
\cs_new_protected:Npn  \@@_backend_NamesEmbeddedFiles_add:nN #1 #2
    %#1 object ref , #2 in case the name must be retourned
    {
      \int_gincr:N \g_@@_backend_EmbeddedFiles_int
      \tl_set:Nx #2 { \@@_backend_EmbeddedFiles_name: }
      \seq_gput_right:Nx \g_@@_backend_EmbeddedFiles_seq { #2 ~#1 }
    }

%</pdfmode|dvipdfmx|xdvipdfmx>
%<*dvips>
\cs_new_protected:Npn  \@@_backend_NamesEmbeddedFiles_add:nN #1 #2
      {
        \int_gincr:N \g_@@_backend_EmbeddedFiles_int
        \tl_set:Nx #2 { \@@_backend_EmbeddedFiles_name: }
        \@@_backend_pdfmark:x
          {
            /Name~#2~
            /FS~#1~
            /EMBED
          }
      }
%</dvips>
%    \end{macrocode}
% \end{macro}
% \end{implementation}
%
% \PrintIndex
