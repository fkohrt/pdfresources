% \iffalse meta-comment
%
%% File: l3pdffile.dtx
%
% Copyright (C) 2018-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "(experimental) pdfresources bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/pdfresources
%
% for those people who are interested.
%
%<*driver>
\RequirePackage{expl3}
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3pdffile} package\\ Embedding and referencing files in a PDF ^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released XXXX-XX-XX}
%
% \maketitle
% \begin{documentation}
%
% \section{\pkg{l3pdffile} documentation}
% External files can be referenced from a PDF in three ways:
% \begin{enumerate}
% \item through an annotation of type Link,
% \item by referencing a local file in the file system,
% \item by embedding the file directly into the PDF
% \end{enumerate}
%
% Case 1 (Links) are created with the \cs{pdfannot} commands.
%
% This module handles the two other cases. Actually from the view
% of the PDF format they are quite similar: Case 2 is case 3 without the stream
% object and without the /EF entry in the /FileSpec dictionary (this points to the
% stream object of the file). Not embedding the file makes the PDF smaller. But it is
% also less portable: the files can only be found if there are is the right location
% relative to the PDF. The normal case is to embed the file. So this is handled first.
%
% The tasks to embed and reference such file are
% \begin{enumerate}
% \item Embed the file in a stream.
% \item Create a FileSpec dictionary which references the embedded file. In the /EF
% dictionary
% \begin{verbatim}
% <<
% /Type /Filespec
% /F (l3pdffile.dtx)
% /UF (l3pdffile.dtx)
% /AFRelationship /Source
% /EF <</F 21 0 R /UF 21 0 R>>   %case 3, embedded file
% >>
% \end{verbatim}
% \item Reference the FileSpec dictionary so that the user can access the file.
%       This can be done in various way:
%       \begin{enumerate}
%       \item With an annotation (/Subtype/FileAttachment). This is done by
%       attachfile, attachfile2 and intopdf. Typical entries of such an annotation
%       are:
%
%             \begin{tabular}{lll}
%             FS       & object reference &(FileSpec dictionary)\\
%             Name     & name           & Graph, PushPin, Paperclip, Tag\\
%             Contents & text string & optional but recommended\\
%             F        & integer     & Flags\\
%             AP       & dictionary  & Appearance (required if rectangle >0) \\
%             AS       & name\\
%             \end{tabular}
%
%             The AP takes precedence over Border and similar keys.
%       \item Through an entry in the EmbeddedFiles name tree. This is what embedfiles does.
%       \begin{verbatim}
%       20 0 obj %Document Name tree
%        <</EmbeddedFiles 21 0 R>>
%           endobj
%         21 0 obj %Embedded Files Name dictionary
%        <</Names [(AcmeCustomCrypto Protected PDF.pdf) 17 0 R]>>
%        endobj
%       \end{verbatim}
%       The strings (keys) in the /Names dictionary must be sorted lexically. But they
%       don't have to be the file name or anything related to the file name. So the code will
%       use l3emb0001, l3emb0002. The key is needed only in one place:
%       to identify the start file in a collection.
%
%       \item Through the /AF key in various objects (pdf 2.0). The value is normally an array of object
%       references, but it can also be a name which is mapped to an array in /Properties:
%        \begin{verbatim}
%        /AF /NamedAF BDC
%        /Properties <</NamedAF [12 0 R]
%        \end{verbatim}
%        The related FileSpec dictionary should contain an /AFRelationship key in this case:
%
%       \begin{tabular}{lp{6cm}}
%       Source  & shall be used if this file specification is the original
%                source material for the associated content.\\
%       Data    & shall be used if this file specification represents information used to
%                derive a visual presentation – such as for a table or a graph.\\
%       Alternative & shall be used if this file specification is an
%               alternative representation of content, for example audio.\\
%       Supplement & shall be used if this file specification represents
%       a supplemental representation of the original source or data
%       that may be more easily consumable
%       (e.g., A MathML version of an equation).\\
%       EncryptedPayload & shall be used if this file specification
%       is an encrypted payload document that should be displayed to the user
%       if the PDF processor has the cryptographic filter
%       needed to decrypt the document.\\
%       FormData & shall be used if this file specification
%       is the data associated with the AcroForm
%       (see 12.7.3, "Interactive form dictionary") of this PDF.\\
%       Schema & shall be used if this file specification is a schema
%       definition for the associated object
%       (e.g. an XML schema associated with a metadata stream).\\
%       Unspecified &(default value) shall be used when the
%       relationship is not known
%       or cannot be described using one of the other values.\\
%       Other names & Second-class names (see Annex E,
%       “(normative) PDF Name Registry") should be used to
%       represent other types of relationships.
%       \end{tabular}
%      \end{enumerate}
% \end{enumerate}
%
%
%\subsection{Embedding a file}
% Embedding an existing file is in most cases quite straightforward. It can be done with
% \cs{pdf_object_now:nn} or \cs{\pdf_object_new:nn}/\cs{pdf_object_write:nn}.
% In the first variant one should then store the object number for the reference
% in the /FileSpec dictionary.
%
% \begin{verbatim}
% \pdf_object_now:nx {fstream}
%   {
%     {
%       /Type /EmbeddedFile
%       /Subtype /application\c_hash_str2Fpostscript
%       /Params
%         <<
%           /ModDate  ~ (\file_timestamp:n{example-image.eps})
%           /Size     ~  \file_size:n {example-image.eps}
%           /CheckSum ~ (\file_mdfive_hash:n {example-image.eps})
%          >>
%     }
%     {example-image.eps}
%   }
% \tl_set:Nx \l_my_fileobj_tl {\pdf_object_last:}
% \end{verbatim}
%
% Remarks:
% \begin{itemize}
% \item The /Params dictionary is not always required, but as the basic data
% are easily accessed it makes sense to add it automatically. Users will
% perhaps want to add also CreationDate here.
% \item The mimetype (in the /Subtype) can not always be detected automatically but
% it should be possible to store and use a list of common extensions. Other
% can be added manually.
% \item The dictionary can contain additional keys (/Filter, /DecodeParms)
% \item The dictionary can actually refer to an external file (in which case the
% stream is ignored.
% \end{itemize}
%
% Implementation: There will be two local dictionaries, file and file/Params.
% The file/Params will have default settings. The dictionaries are used to
% build the attributes of the object.
%
%
%
%
% \begin{function}{\pdffile_embed:nN}
%   \begin{syntax}
%     \cs{pdffile_embed:nN} \Arg{filename} \meta{tl var}
%   \end{syntax}
%   This commands embeds the file \Arg{filename} in the PDF and stores the
%   object reference in \meta{tl var}. It uses the content of the local
%   dictionaries \texttt{file} and \texttt{file/Params} to setup
%   the dictionary entries of the stream object.
% \end{function}
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3pdffile} implementation}
%
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage {l3pdffile} {2020-04-21} {0.1}
  {embedding and referencing files in PDF}
\RequirePackage{new-pdfescape}  %temporarly!!
\cs_set_eq:NN \@@_file_filename_convert:nN \pdftool_textstringhex_print:nN
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=pdf>
%    \end{macrocode}
%    \begin{macrocode}
% https://github.com/latex3/latex3/issues/711
\prg_new_conditional:Npnn \__pdf_backend_object_if_exist:n #1 { p , T , F , TF }
  {
    \int_if_exist:cTF { c__pdf_backend_object_ \tl_to_str:n {#1} _int }
     { \prg_return_true: }
     { \prg_return_false:}
  }

\prg_new_eq_conditional:NNn \pdfobject_if_exist:n\__pdf_backend_object_if_exist:n
  { TF , T , F , p }
%    \end{macrocode}
% \subsection{Messages}
%    \begin{macrocode}
\msg_new:nnn { pdffile } { file-not-found }
  {
    File~'\tl_to_str:n{#1}'~not~found
  }

\msg_new:nnn { pdffile } { mimetype-missing }
  {
    Mime~type~not~set~for~file~'\tl_to_str:n{#1}'
  }

\msg_new:nnn { pdffile } { file-object-no-found }
  {
    file~object~'\tl_to_str:n{#1}'~is~not~declared
  }
%    \end{macrocode}
% \begin{variable}
%   {
%     \l_@@_file_tmpa_tl,
%     \l_@@_file_tmpa_str,
%     \l_@@_file_ext_str,
%     \l_@@_file_subtype_tl
%   }
% temporary variables: generic, for extension, subtype
% \end{variable}
%    \begin{macrocode}
\tl_new:N  \l_@@_file_tmpa_tl
\str_new:N \l_@@_file_tmpa_str

\str_new:N \l_@@_file_ext_str
\tl_new:N  \l_@@_file_subtype_tl

%    \end{macrocode}
% \begin{variable} {\g_pdffile_mimetypes_prop}
% This variable holds common mimetypes
% \end{variable}
%    \begin{macrocode}
\prop_new:N \g_pdffile_mimetypes_prop
\prop_set_from_keyval:Nn \g_pdffile_mimetypes_prop
  {
    ,.csv = text/csv
    ,.html= text/html
    ,.dtx = text/plain %or application/x-tex, not in iana.org list
    ,.eps = application/postscript
    ,.jpg = image/jpeg
    ,.mp4 = video/mp4
    ,.pdf = application/pdf
    ,.png = image/png
    ,.tex = text/plain %or application/x-tex, not in iana.org list
    ,.txt = text/plain
  }
%    \end{macrocode}
% \begin{variable}
%  {
%   \l_pdffile_full_name_str,
%  }
% \cs{l_pdffile_full_name_str} will be set at the begin of the command and contains the
% , and
% so can be used in dictionary values or other references.
% \end{variable}
%    \begin{macrocode}
\str_new:N  \l_pdffile_full_name_str
\str_new:N  \l_pdffile_full_name_convert_str
%    \end{macrocode}
% Here we define and setup the local dictionaries. We also define constants.
%    \begin{macrocode}
\pdfdict_new:n   { file }
\cs_new_protected:Npn \@@_dict_file_reset:
  {
    \pdfdict_put:nnn { file }{Type}{/EmbeddedFile}
  }
\pdfdict_reset:n { file }

\pdfdict_new:n   { file/Params }
\cs_new_protected:cpn { @@_dict_file/Params_reset: }
  {
    \pdfdict_put:nnn { file/Params }
      {ModDate}  { (\file_timestamp:n { \l_pdffile_full_name_str }) }
    \pdfdict_put:nnn { file/Params }
      {Size}     { \file_size:n { \l_pdffile_full_name_str } }
    \pdfdict_put:nnn { file/Params }
      {CheckSum} { (\file_mdfive_hash:n { \l_pdffile_full_name_str }) }
  }
\pdfdict_reset:n { file/Params }

\pdfdict_new:n   { file/FileSpec }
\cs_new_protected:cpn { @@_dict_file/FileSpec_reset: }
  {
    \pdfdict_put:nnn { file/FileSpec }
      {Type} { /FileSpec }
    \pdfdict_put:nnn { file/FileSpec }
      {F}  { \l_pdffile_full_name_convert_str }
    \pdfdict_put:nnn { file/FileSpec }
      {UF} { \l_pdffile_full_name_convert_str }
    \pdfdict_put:nnn { file/FileSpec }
      {AFRelationship} { /Unspecified }
  }
\pdfdict_reset:n { file/FileSpec }

%    \end{macrocode}
% \end{variable}
% these macros must be combined ...
% \begin{macro}{\pdffile_embed:nN}
%    \begin{macrocode}


\cs_new_protected:Npn \pdffile_embed:nn #1 #2
 % #1 symbolic object name of file spec  #2 file name,
  {
    \file_get_full_name:nNTF {#2} \l_pdffile_full_name_str
      {
      %we need the extension
      \file_parse_full_name:VNNN
        \l_pdffile_full_name_str
        \l_tmpa_tl
        \l_tmpb_tl
        \l_@@_file_ext_str
      %check if Subtype has been set
      \pdfdict_get:nnN {file}{Subtype}\l_@@_file_tmpa_tl
      \quark_if_no_value:NT \l_@@_file_tmpa_tl
        {
          \prop_get:NVNTF \g_pdffile_mimetypes_prop \l_@@_file_ext_str \l_tmpa_tl
            {
              \tl_set:Nx \l_@@_file_subtype_tl {/Subtype~\pdftool_name:V \l_tmpa_tl}
             }
            {
              \tl_clear:N \l_@@_file_subtype_tl
              \msg_warning:nnn { pdffile }{ mimetype-missing} { #2 }
            }
        }
      \pdf_object_now:nx { fstream }
        {
          {
            \l_@@_file_subtype_tl
            \pdfdict_map:n {file}
            \pdfdict_if_empty:nF {file/Params}
              {
                /Params
                  <<
                    \pdfdict_map:n {file/Params}
                  >>
              }
          }
          { \l_pdffile_full_name_str }
        }
      \tl_clear:N \l_@@_file_subtype_tl
      \tl_set:Nx  \l_@@_file_object_last_tl {\pdf_object_last:}
      \pdf_object_new:nn   { #1 } {dict}
      \@@_file_filename_convert:nN  { #2 } \l_pdffile_full_name_convert_str
      \pdf_object_write:nx { #1 }
        {
          \pdfdict_map:n {file/FileSpec}
          /EF <</F~\l_@@_file_object_last_tl /UF~\l_@@_file_object_last_tl>>
        }
     }
     {
        \msg_error:nnn { pdffile }{ file-not-found }{ #2 }
     }
  }
%    \end{macrocode}
% \end{macro}

% \subsection{backend commands to add the file to the /EmbeddedFiles name tree}
% For pdflatex, lualatex and xelatex, the name and object reference is stored in a sequence.
% The pdfresources code for the catalog output this and add a reference to /Names,
% if the sequence is not empty.
% dvips wants code for every file and then sorts this it self.
%    \begin{macrocode}
\int_new:N \g_@@_file_tree_name_int
% \seq_new:N \g_@@_file_tree_name_seq %moved to resource file, to the push command
\cs_new:Npn \@@_file_tree_name:
 {
   (
    l3ef
    \int_compare:nNnT {\g_@@_file_tree_name_int} < {10}
     {0}
    \int_compare:nNnT {\g_@@_file_tree_name_int} < {100}
     {0}
    \int_compare:nNnT {\g_@@_file_tree_name_int} < {1000}
     {0}
    \int_use:N \g_@@_file_tree_name_int
   )
 }

\bool_if:nT %pdftex,luatex,xetex
  {
    ( \sys_if_engine_pdftex_p: && \sys_if_output_pdf_p: ) %
    ||
     \sys_if_engine_luatex_p:
    ||
     \sys_if_engine_xetex_p:
  }
 {
  \cs_new_protected:Npn  \@@_backend_attach_tree_name:nN #1 #2 %#1 object ref , #2 in case the name must be retourned
   {
     \int_gincr:N \g_@@_file_tree_name_int
     \tl_set:Nx #2 { \@@_file_tree_name: }
     \seq_gput_right:Nx \g_@@_file_tree_name_seq { #2 ~#1 }
   }
 }

% dvips
\bool_if:nT {\sys_if_engine_pdftex_p: && !\sys_if_output_pdf_p:}
  {
    % https://github.com/latex3/latex3/issues/710
    \cs_if_free:NT \__pdf_backend_object_write_fstream:nn
      {
        \cs_new_protected:Npn \__pdf_backend_object_write_fstream:nn #1#2
          {
            \exp_args:Nx
              \__pdf_backend_object_write_fstream:nnn {#1} #2
          }

        \cs_new_protected:Npn \__pdf_backend_object_write_fstream:nnn #1#2#3
          {
            \__kernel_backend_literal:n
              { ps::[nobreak]~
                SDict ~ begin ~
                mark ~ #1 ~ << #2 >> /PUT ~ pdfmark ~
                mark ~ #1 ~ ( #3 )~ (r)~ file ~ /PUT ~ pdfmark ~
                end
              }
          }
       }
     % https://github.com/latex3/latex3/issues/709
     \cs_set_protected:Npn \__pdf_backend_object_write_stream:nnn #1#2#3
        {
         \__kernel_backend_literal:n
           {
            ps::[nobreak]~
             SDict ~ begin ~
              mark ~ #1 ~ ( #3 ) /PUT ~ pdfmark ~
              mark ~ #1 ~ << #2 >> /PUT ~ pdfmark ~
              end
           }
        }

    \cs_new_protected:Npn  \@@_backend_attach_tree_name:nN #1 #2
      {
        \int_gincr:N \g_@@_file_tree_name_int
        \tl_set:Nx #2 { \@@_file_tree_name: }
        \@@_backend_pdfmark:x
          {
            /Name~#2~
            /FS~#1~
            /EMBED
          }
      }
  }

%    \end{macrocode}
% \begin{function}[added = 2020-04-24]
%   {\pdffile_attach:n, \pdffile_attach:nN,}
%   \begin{syntax}
%     \cs{pdffile_attach:n}  \Arg{name} \\
%     \cs{pdffile_attach:nN}  \Arg{name} \meta{tl var}
%   \end{syntax}
%   This attaches the file with name \Arg{name} which has been embedded
%   with \csname{pdffile_embed:nn}\Arg{name}\Arg{file} to the attachments panel
%   of the pdf reader. \meta{tl var} stores the name used in the name tree, in
%   case it is needed to setup up for example a collection.
%\end{function}
%    \begin{macrocode}

\cs_new_protected:Npn \pdffile_attach:nN #1 #2 % name of filespec object, #2 in case the name must be retourned
 {
   \@@_backend_object_if_exist:nTF { #1}
     {
       \exp_args:Nx
       \@@_backend_attach_tree_name:nN {\pdf_object_ref:n{#1}} #2
     }
     {
       \msg_error:nnn { pdffile } { file-object-no-found } { #1 }
     }
 }

\cs_new_protected:Npn \pdffile_attach:n #1 % name of filespec object
 {
   \@@_backend_object_if_exist:nTF { #1}
     {
       \exp_args:Nx
         \@@_backend_attach_tree_name:nN
           {\pdf_object_ref:n{#1}} \l_@@_file_tmpa_tl
     }
     {
       \msg_error:nnn { pdffile } { file-object-no-found } { #1 }
     }
 }

%for anonymous objects. This allows to use the interface with objects not
% created with l3 commands / naming
\cs_new_protected:Npn \pdffile_attach_last:N #1 % #1 in case the name must be retourned
 {
   \tl_set:Nx \l_@@_file_tmpa_tl {\pdf_object_last:}
   \exp_args:Nx
     \@@_backend_attach_tree_name:nN { \l_@@_file_tmpa_tl } #1
 }

\cs_new_protected:Npn \pdffile_attach_last:
 {
   \tl_set:Nx \l_@@_file_tmpa_tl {\pdf_object_last:}
   \exp_args:Nx
     \@@_backend_attach_tree_name:nN { \l_@@_file_tmpa_tl } \l_@@_file_tmpa_tl
 }


%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
