% !Mode:: "TeX:UTF-8:Main"

\RequirePackage{pdfmanagement}

\DeclareDocumentMetadata
 {
  uncompress,
  %lang=de-DE,
  pdfversion=1.5,
  pdfstandard={A-1b}
 }
\documentclass{l3doc}
\usepackage{booktabs}
\ExplSyntaxOn
\prg_new_conditional:Npnn \pdfmeta_standard_verify:n #1 {T,F,TF}
  {
     \prop_if_in:NnTF \g_pdfmeta_standard_prop {#1}
       {
         \prg_return_false:
       }
       {
         \prg_return_true:
       }     
  }

\prg_new_protected_conditional:Npnn \pdfmeta_standard_verify:nn #1 #2  {T,F,TF}
  {
    \prop_if_in:NnTF \g_pdfmeta_standard_prop {#1}
      {
        \cs_if_exist:cTF {__pdfmeta_standard_verify_handler_#1:nn}
          { % dedicated test handler:
            % should return true of false.
            \exp_args:Nnnx
            \use:c
              { __pdfmeta_standard_verify_handler_#1:nn}
              { #2 }
              { \prop_item:Nn \g_pdfmeta_standard_prop {#1} }
          }
          {
            \prg_return_false:
          }
      }
      {
        \prg_return_true:
      }
   }
   
\prg_new_protected_conditional:Npnn \pdfmeta_standard_verify:nnN #1 #2 #3 {T,F,TF}
  {
    \prop_if_in:NnTF \g_pdfmeta_standard_prop {#1}
      {
        \tl_set:Nx #3  {\prop_item:Nn \g_pdfmeta_standard_prop {#1}}
        \cs_if_exist:cTF {__pdfmeta_standard_verify_handler_#1:nn}
          { % dedicated test handler:
            % should return true of false.
            \exp_args:Nnno
            \use:c
              { __pdfmeta_standard_verify_handler_#1:nn}
              { #2 }
              { #3 }
          }
          {
            \prg_return_false:
          }
      }
      {
        \tl_set:Nn #3  {}
        \prg_return_true:
      }
   }


% #1 = user value, #2 = standard value
\cs_new_protected:Npn \__pdfmeta_standard_verify_handler_min_pdf_version:nn #1 #2
 {
   \pdf_version_compare:NnTF <
     { #2 }
     {\prg_return_false:}
     {\prg_return_true:}
 }

\cs_new_protected:Npn \__pdfmeta_standard_verify_handler_named_actions:nn #1 #2
 {
   \tl_if_in:nnTF { #2 }{ #1 }
     {\prg_return_true:}
     {\prg_return_false:}
 }

\cs_new_protected:Npn \__pdfmeta_standard_verify_handler_annot_action_A:nn #1 #2
 {
   \tl_if_in:nnTF { #2 }{ #1 }
     {\prg_return_true:}
     {\prg_return_false:}
 }
%not really need probably, but ...
\cs_new_protected:Npn \__pdfmeta_standard_verify_handler_outputintent_subtype:nn #1 #2
 {
   \tl_if_eq:nnTF { #2 }{ #1 }
     {\prg_return_true:}
     {\prg_return_false:}
 }

\pdfmeta_standard_verify:nnNF {min_pdf_version}{} \l_tmpa_tl
  {
    \exp_args:NV \pdf_version_gset:n \l_tmpa_tl
  }

%\pdfmeta_standard_verify:nnNTF {named_actions}{XXXPage}\l_tmpa_tl
% {\show\Fine \show\l_tmpa_tl}{ \show\Problem \show\l_tmpa_tl}

\pdfmeta_standard_verify:nnNTF {annot_action_A}{GoTo}\l_tmpa_tl
 {\show\Fine \show\l_tmpa_tl}{ \show\Problem \show\l_tmpa_tl}


\ExplSyntaxOff

\begin{document}
Verifying standard requirements.

Standards like pdf/A have requirements which basically fall into two group: Some things have be there in the PDF, e.g. the catalog has to contain a /Lang entry and an colorprofile and an /OutputIntent, some other things are forbidden or restricted, e.g. the action dictionary of an annotation should not contain Javascript.

The \pkg{l3pdfmeta} packages collects a number of relevant requirements, tries to enforce the ones which can be enforced and offers some tools for package authors to test if an action is allowed in the standard or not.

This is work in progress and more tests will be added. But it should be noted that it will probably never be possible to check and prevent all actions not allowed by a standard. The commands here don't replace a check with an external validator.


\begin{function}[pTF]{\pdfmeta_standard_verify:n}
\begin{syntax}
\cs{pdfmeta_standard_verify:n}\Arg{requirement}
\end{syntax}

This checks if \meta{requirement} is listed in the standard. |false| as result means that the requirement is in the standard and that probably some special action is required---which one depends on the requirement, see the descriptions below.
|true| means that the requirement is not there and so no special option is needed.
This check can be used for simply requirements where neither a user nor a standard value is of importance.
\end{function}

\begin{function}[pTF]{\pdfmeta_standard_verify:nn}
\begin{syntax}
\cs{pdfmeta_standard_verify:nn}\Arg{requirement}\Arg{value}
\end{syntax}

This checks if \meta{requirement} is listed in the standard, if yes it tries to find a predefined test handler for 
the requirement.   calls a special  and if the \meta{value} requires some action.
|false| as result means that the value is problematic and some special action is required---which one depends on the requirement, see the descriptions below. |true| that no special action is needed.
\end{function}

\begin{function}[pTF]{\pdfmeta_standard_verify:nnN}
\begin{syntax}
\cs{pdfmeta_standard_verify:nn}\Arg{requirement}\Arg{value} \meta{tl var}
\end{syntax}
This works like \cs{pdfmeta_standard_verify:nn} but additionally stores the reference value of the standard
in the \meta{token list variable}. The \meta{token list variable} can then e.g be used in the true or false branch, to fulfill a requirement or to issue a message.
\end{function}

\begin{function}[pTF]{\pdfmeta_standard_get:nN}
\begin{syntax}
\cs{pdfmeta_standard_get:nN}\Arg{requirement} \meta{tl var}
\end{syntax}
This retrieves the value of \meta{requirement} and stores it in the \meta{token list variable}.
If the \meta{requirement} is not found the special value |\q_no_value| is used.  The  \meta{token list variable} is assigned locally.
\end{function}


The following describe the requirements which can be tested. Requirements with a value should use \cs{pdfmeta_standard_verify:nn} or \cs{pdfmeta_standard_verify:nnN} to test a local value against the standard.
The rule numbers refer to \url{https://docs.verapdf.org/validation/pdfa-part1/}

\footnotesize
\extrarowheight2pt
\noindent\begin{tabular}{l>{\raggedright}p{2cm}l>{\raggedright\arraybackslash}p{5cm}}
\toprule
\bfseries requirement &\bfseries test value              &\bfseries rule &\bfseries possible action if |false|    \\
\midrule
|min_pdf_version|      & current pdf version && 
increase the pdf version. \bfseries This check is done by \pkg{l3pdfmeta}. \\
|outputintent|         & ---                 && 
 embed a color profile and reference it as /Outputintent. \bfseries This requirement is detected and fulfilled by \pkg{l3pdfmeta}, see below.\\
|outputintent_subtype| & a subtype like |GTS_PDFA1| && 
change subtype to use the correct name. \bfseries This requirement is detected and fullfilled by \pkg{l3pdfmeta}, see below.\\
|annot_flags|           & --- && Print flag should be true, Hidden, Invisible, NoView should be false. This requirement is detected  and set by \pkg{l3pdfmeta}.\\
\midrule
|no_encryption|        & ---                 && don't encrypt\\
|no_external_content|  & ---                 && no F, FFilter, or FDecodeParms in stream dictionaries\\
|no_embed_content|     & ---                 && no /EF key in filespec, no /Type/EmbeddedFiles\\
|named_actions|        & a named action name && 
 don't use this action, only NextPage, PrevPage, FirstPage, LastPage are allowed \\
|Catalog_no_OCProperties| & ---              &6.1.13-1
 & don't add /OCProperties to the catalog\\
|annot_action_A|       & annot action subtype like |GoTo| or |Movie| & 6.6.1-1 & 
 don't use the subtype. \\
|annot_widget_no_AA|   & ---                 &6.6.2-1& 
 no AA dictionary in widget annotation\\
|annot_widget_no_A_AA| &---                   &6.9-2& 
 no A and AA dictionary in widget.\\
|form_no_AA|           &---                   & 6.9-3& 
 no /AA dictionary in form field\\
\bottomrule
\end{tabular}


\end{document}
