% \iffalse meta-comment
%
%% File: l3pdfgdict.dtx
%
% Copyright (C) 2018-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "(experimental) pdfresources bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/pdfresources
%
% for those people who are interested.
%
%<*driver>
\RequirePackage{expl3}
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3pdfgdict} package\\ Managing core pdf dictionaries ^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released XXXX-XX-XX}
%
% \maketitle
% \begin{documentation}
%
% \section{\pkg{l3pdfgdict} documentation}
% The commands in this module offer interfaces to a number of core dictionaries
% of a PDF. They unify a number of primitives like the pdftex
% registers \cs{pdfcatalog}, \cs{pdfpagesattr}, \cs{pdfinfo} and similar commands
% of the other backends  in a backend independant way.
%
% The dictionaries handled by these module are inserted only
% once in a PDF or only once per page. Examples are the Catalog dictionary,
% the Info dictionary, the page resources. For these dictionaries management by the
% \LaTeX{} kernel is necessary to avoid that packages overwrite settings from
% other packages which would lead to clashes and incompatibilities.
% It is therefor necessary that all packages which want to add content to this
% dictionaries uses the interface provided by this module.
%
% As this dictionaries are so central for the PDF format values to these
% dictionaries are always added globally. Through the interface values
% can be added (and in many cases also removed), but the actually writing of the
% dictionary objects to the PDF are then handled by
% the kernel code at a suitable time.
%
% The names of this core dictionaries follow the names in the PDF reference.
% They all have names starting with an uppercase letter.

%  \end{description}
%
% The following tabular summarize the core dictionaries and which pdftex primitive they
% replace:
% \begin{tabular}{ll}
%  Info                                  & \cs{pdfinfo}           \\
%  Catalog \&  various subdictionaries   & \cs{pdfcatalog}        \\
%  Pages                                 & \cs{pdfpagesattr}      \\
%  Page, ThisPage                        & \cs{pdfpageattr}       \\
%  Page/Resources/ExtGState              & \cs{pdfpageresources}  \\
%  Page/Resources/Shading                & \cs{pdfpageresources}  \\
%  Page/Resources/Pattern                & \cs{pdfpageresources}  \\
%  Page/Resources/ColorSpace             & \cs{pdfpageresources}  \\%
%  \end{tabular}
%
%  There is no \texttt{Page/Resources/Properties} dictionary in the list
%  as this is dictionary is not filled directly but
%  filled and managed through side effects when setting BDC-marks.
%  \subsection{User Commands}
%
% \begin{function}[added = 2020-04-06]
%   {\pdfgdict_gput:nnn}
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \Arg{core dictionary} \Arg{name} \Arg{value}\\
%   \end{syntax}
% This function puts \Arg{name} \Arg{value}  globally in an internal
% property lists.
%
% \Arg{core dictionary} is a symbolic name for a concrete PDF dictionary to
% which the content of these property lists will be written by the PDF
% resource management code.
%
% \Arg{name} should be a valid PDF Name without
% the starting slash.
%
% \Arg{value} should be a valid PDF value for this Name in the
% target dictionary.
%
% The PDF resource management code predefines a large number of
% symbolic names for important core dictionaries and will write the stored values
% at the right time to the PDF. The predefined symbolic names are described below.
%
% The code works with all major engines but not necessarily
% in the same way. Most importantly
% \begin{itemize}
% \item The expansion behaviour of the backends can differ. Some backends expand a
% value always fully when writing to the PDF, with other backends command names
% could end as strings in the PDF. So one should neither rely on \Arg{name}
% \Arg{value} to be expanded nor not expanded by the backend commands.
% \item The number of compilations needed can differ between the engines and
% backends. Some engines have to use labels and the aux-file to setup
% the dictionaries and so need at least two compilations to put everything
% in place.
% \end{itemize}
% \end{function}
% \begin{function}[added = 2020-04-08]
%   {\pdfgdict_show:n }
%   \begin{syntax}
%     \cs{pdfgdict_show:n}  \Arg{dictionary}
%   \end{syntax}
%   This shows the content of \Arg{dictionary} in the log and on the terminal.
%   It doesn't show the special catalog dictionaries with arrays as values
%   as these are filled only at the end of the document. It is not reliable for
%   page resources as these are filled a shipout.
%\end{function}
% \begin{function}[added = 2020-04-07]
%   {
%     \pdfgdict_gremove:nn,
%   }
%   \begin{syntax}
%     \cs{pdfgdict_gremove:nn} \Arg{global dictionary} \Arg{name}
%   \end{syntax}
%   Removes  |/|\meta{name} and its associated \meta{value} from the \Arg{dictionary}
%   The removal is global.
%   If \meta{name} is not found no change occurs,
%   \emph{i.e}~there is no need to test for the existence of a name before
%   trying to remove it.
%   Values from the special Catalog entries with arrays as values can not be
%   removed.
% \end{function}
% \end{documentation}
%
% \begin{implementation}
%    \begin{macrocode}
%<@@=pdfgdict>
%<*package>
%    \end{macrocode}
\ProvidesExplPackage {l3pdfgdict} {2020-04-08} {0.5}
  {Managing global and local dictionaries}
% \section{\pkg{l3pdfgdict} implementation}
% \subsection{Messages}
%    \begin{macrocode}
\msg_new:nnn  { pdfgdict } { unknown-dict }
  {
    The~dictionary~'#1'~is~not~declared.
  }
\msg_new:nnn  { pdfgdict } { wrong-or-unknown-dict }
  {
    The~dictionary~'#1'~is~either~not~a~#2~dictionary\\
    or~is~not~declared.
  }

\msg_new:nnn  { pdfgdict } { empty-value }
              { The~value~for~#1~is~empty~and~will~be~ignored }

\msg_new:nnn  { pdfgdict } { no-removal }
              { It~is~not~possible~to~remove~values~from~dictionary~'#1'.}

\msg_new:nnn  { pdfgdict } { no-show }
              { It~is~not~possible~to~show~the~dictionary~'#1'.}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfgdict_gput:nnn #1 #2 #3
  {
    \@@_if_global:nTF { #1 }
      {
        \@@_handler_put:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \msg_error:nnnn{pdfgdict}{wrong-or-unknown-dict}{#1}{core}
      }
  }

\cs_generate_variant:Nn \pdfgdict_gput:nnn {nnx}
%    \end{macrocode}
% \subsection{Internal dictionary Code}
%  Many code parts are quite similar: property lists for
%  dictionaries are filled and output.
%  So we define some generic commands to ensure systematic
%  internal names. The names are based on paths separated by slashed.
%  The first slash is not used in the names.
%
%  Currently the following names are used: ^^A!!!!! check, compare with g_@@_gnames_seq
%  \begin{verbatim}
%  /Info                      %    (\pdfinfo)
%  /Catalog                   %    (\pdfcatalog)
%  /Catalog/AA                %
%  /Catalog/AcroForm
%  /Catalog/OCProperties
%  /Catalog/OutputIntents
%  /Catalog/AcroForm/DR
%  /Catalog/AcroForm/DR/Font
%  /Catalog/MarkInfo
%  /Catalog/ViewerPreferences
%  /Pages                     %    (\pagesattr)
%  /Page                      %    (\pageattr)
%  /ThisPage                  %    (\pageattr)
%  /backend_PageN/Resources/Properties %
%  /Page/Resources/ExtGState
%  /Page/Resources/ColorSpace
%  /Page/Resources/Pattern
%  /Page/Resources/Shading
%  /Page/Resources/Properties
%  /xform/Resources/Properties
%  \end{verbatim}
% \begin{macro}{\@@_item:nn,\@@_objref_item:nn}
% Commands to output dict entries: The arguments are \meta{name}\meta{value} and
% \meta{name}\meta{object name}, \meta{name} should be a valid pdf name without
% the slash.
% The commands don't check if the arguments are empty or valid. This should be done
% in the pdf layer at the input.
% \begin{NOTE}{UF}
%TODO: check expansion behaviour of \cs{@@_objref_item:nn} in the various uses
%This command could be shared with pdfdict, but is it worth the trouble?
% \end{NOTE}
%    \begin{macrocode}
\cs_new:Npn \@@_item:nn #1 #2 { /#1~#2~ } %name, value
\cs_generate_variant:Nn \@@_item:nn {ne}

\cs_new:Npn \@@_objref_item:nn #1 #2      %name, object name
  {
    /#1~\pdf_object_ref:n { #2 }
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%    \@@_name:n,
%    \@@_new:n,
%    \g_@@_names_seq,
%   }
%    \begin{macrocode}
\seq_new:N \g_@@_names_seq

\cs_new:Npn \@@_name:n #1 % path name without the leading /
  {
    g_@@_/#1_prop
  }

\cs_new_protected:Npn \@@_new:n #1
  {
    \@@_if_exist:nTF { #1 }
      {
        \msg_error:nnx
          { pdfgdict }
          { dict-already-defined }
          { #1}
       }
      {
        \prop_new:c  { \@@_name:n { #1 } }
        \seq_gput_right:Nn \g_@@_names_seq { #1 }
      }
  }

% test existence
\prg_new_conditional:Npnn \@@_if_exist:n #1 { p , T , F , TF }
  {
    \prop_if_exist:cTF
      { \@@_name:n { #1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }

\prg_new_conditional:Npnn \@@_if_empty:n #1 { p , T , F , TF }
  {
    \prop_if_empty:cTF
      { \@@_name:n { #1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{
%                \@@_handler_gput:nnn,
%                \@@_gput:nnn,
%                \@@_get:nnN,
%                \@@_gremove:nn,
%                \@@_show:n
%                }
%  \cs{@@_handler_gput:nnn} is the main command to fill the dictionaries.
%  In simple cases it directly fill the property list, but if a handler exists
%  this is called. It is important to use it only in places where this make sense.
%  \cs{@@_put:nnn} is a simpler variant which only fills the property list.
%
%    \begin{macrocode}

%global
\cs_new_protected:Npn \@@_handler_gput:nnn #1 #2 #3  %#1 path, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfgdict }{ empty-value }{ /#1/#2 }
      }
      {
        \@@_if_exist:nTF { #1 }
          {
            \cs_if_exist:cTF
              { @@_handler/#1/?_gput:nn } %general, name independant handler
              { \use:c {@@_handler/#1/?_gput:nn} {#2} {#3} }
              {
                \cs_if_exist:cTF
                  { @@_handler/#1/#2_gput:n }
                  { \use:c {@@_handler/#1/#2_gput:n} {#3} } %special handler
                  {
                    \use:c { prop_gput:cnn }
                      { \@@_name:n { #1 } }{ #2 } { #3 }
                  }
              }
          }
          {
            \msg_error:nnn { pdfgdict } { unknown-dict } { /#1 }
          }
      }
  }


\cs_generate_variant:Nn \@@_handler_gput:nnn {nxx}

\cs_new_protected:Npn \@@_gput:nnn #1 #2 #3  %#1 path, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfgdict }{ empty-value }{ /#1/#2 }
      }
      {
       \@@_if_exist:nTF { #1 }
         {
           \use:c { prop_gput:cnn }
             { \@@_name:n { #1 } }{ #2 } { #3 }
         }
         {
           \msg_error:nnn { pdfgdict } { unknown-dict } { /#1 }
         }
      }
  }

\cs_new_protected:Npn \@@_get:nnN  #1 #2 #3 %path,key,macro
  {
    \prop_get:cnN
      { \@@_name:n { #1 } }
      { #2 } #3
  }


\cs_new_protected:Npn \@@_handler_gremove:nn #1 #2 %path,key
  {
    \@@_if_exist:nTF { #1 }
          {
            \cs_if_exist:cTF
              { @@_handler/#1/?_gremove:n } %general, name independant handler
              { \use:c {@@_handler/#1/?_gremove:n} {#2} }
              {
                \cs_if_exist:cTF
                  { @@_handler/#1/#2_gremove: }
                  { \use:c {@@_handler/#1/#2_gremove:} } %special handler
                  {
                    \prop_gremove:cn
                      { \@@_name:n { #1 } }{ #2 }
                  }
              }
          }
          {
            \msg_error:nnn { pdfgdict } { unknown-dict } { /#1 }
          }
  }

\cs_new_protected:Npn \@@_gremove:nn #1 #2 %path,key
  {
    \@@_if_exist:nTF { #1 }
          {
            \prop_gremove:cn
              { \@@_name:n { #1 } }{ #2 }
          }
          {
            \msg_error:nnn { pdfgdict } { unknown-dict } { /#1 }
          }
  }


\cs_new_protected:Npn \@@_show:Nn #1#2
  {
    \cs_if_exist:cTF
      { @@_handler/#2/?_show: } %general, name independant handler
      { \use:c {@@_handler/#2/?_show:} }
      {
        \prop_if_exist:cTF { \@@_name:n { #2 } }
          {
             #1
               { pdfgdict } { show-dict }
               { \tl_to_str:n {#2} }
               { \prop_map_function:cN {\@@_name:n { #2 }} \msg_show_item:nn }
               { } { }
          }
          {
            #1 { pdfgdict } { unknown-dict } {#2}{}{}{}
          }
       }
  }

\cs_new_protected:Npn \@@_show:n #1  %path
  {
    \prop_show:c { \@@_name:n { #1 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_map:n }
% \cs{@@_map:n} outputs a prop as needed in a dictionary:
%  as a list of /\meta{key} \meta{value} pairs.
%    \begin{macrocode}
% !! is e-expansion the right thing?
\cs_new:Npn \@@_map:n #1 %path
  {
    \prop_map_function:cN { \@@_name:n { #1 } } \@@_item:ne
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_gmerge:nnN }
% \cs{@@_gmerge:nnN} merges at first the property \meta{name_1}
%  then optionally \meta{name_2} into property |#3|.
%    \begin{macrocode}

\cs_new_protected:Npn \@@_gmerge:nnN #1 #2 #3
  {
    \prop_gset_eq:Nc #3 { \@@_name:n  { #1 } }
    \prop_if_exist:cT  { \@@_name:n  { #2 } }
      {
        \prop_map_inline:cn { \@@_name:n  { #2 } }
          {
            \prop_gput:Nnn #3 { ##1 }{ ##2 }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfgdict_show:n
  {
    \@@_show:Nn \msg_show:nnxxxx {#1}
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfgdict_gremove:nn #1 #2
  {
    \@@_if_exist:nTF { #1 }
      {
        \@@_handler_gremove:nn { #1 }{ #2 }
      }
      {
        \msg_error:nnnn{pdfgdict}{wrong-or-unknown-dict}{#1}{core}
      }
  }
%    \end{macrocode}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
