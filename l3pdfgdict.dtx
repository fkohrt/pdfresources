% \iffalse meta-comment
%
%% File: l3pdfgdict.dtx
%
% Copyright (C) 2018-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "(experimental) pdfresources bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/pdfresources
%
% for those people who are interested.
%
%<*driver>
\RequirePackage{expl3}
\documentclass[full]{l3doc}
\providecommand\potentialclash{\noindent\llap{\dbend\ }}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3pdfgdict} package\\ Managing core pdf dictionaries ^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released XXXX-XX-XX}
%
% \maketitle
% \begin{documentation}
%
% \section{\pkg{l3pdfgdict} documentation}
% When creating a pdf a number of objects, dictionaries and entries to
% dictionaries must be created. The \LaTeX{} format currently contains no
% support for theses tasks. It either relies on the binaries to do the job,
% or on external packages using the primitives of the binaries. These
% approach is problematic for two reasons: packages trying to set the same resources
% can clash, and as the primitives differ between the various binaries and backend with
% which \LaTeX{} is used all packages have to write and maintain \enquote{driver} files
% for the various backends.
%
% The commands in this module offer interfaces to this core PDF dictionaries
% They unify a number of primitives like the pdftex
% registers \cs{pdfcatalog}, \cs{pdfpagesattr}, \cs{pdfinfo} and similar commands
% of the other backends  in a backend independant way.
%
% The supported backends are pdflatex, lualatex, (x)dvipdfmx (latex, xelatex)
% and dvips with ps2pdf (not completely yet). dvips with distiller could work too
% but is untested.
%
% That the interfaces are backend independent doesn't mean that the results and even
% the compilation behavior is identical. The backends are too different to allow
% this. Some backends expand arguments e.g. in a \cs{special} while other don't.
% Some backends can insert a resource at the first compilation, while another uses
% the aux-file and a label and so needs at least two.
%
% The dictionaries handled by these module are inserted only
% once in a PDF or only once per page. Examples are the Catalog dictionary,
% the Info dictionary, the page resources. For these dictionaries management by the
% \LaTeX{} kernel is necessary to avoid that packages overwrite settings from
% other packages which would lead to clashes and incompatibilities.
% It is therefor necessary that all packages which want to add content to this
% dictionaries uses the interface provided by this module.
%
% As these dictionaries are so central for the PDF format values to these
% dictionaries are always added globally. Through the interface values
% can be added (and in many cases also removed), but the actually writing of the
% dictionary objects to the PDF are then handled by
% the kernel code at a suitable time.
%
% The names of this core dictionaries follow the names in the PDF reference.
% They all have names starting with an uppercase letter.
%
% The following tabular summarize the core dictionaries and which pdftex primitive they
% replace:
%
% \begin{tabular}{ll}
%  Info                                  & \cs{pdfinfo}           \\
%  Catalog \&  various subdictionaries   & \cs{pdfcatalog}        \\
%  Pages                                 & \cs{pdfpagesattr}      \\
%  Page, ThisPage                        & \cs{pdfpageattr}       \\
%  Page/Resources/ExtGState              & \cs{pdfpageresources}  \\
%  Page/Resources/Shading                & \cs{pdfpageresources}  \\
%  Page/Resources/Pattern                & \cs{pdfpageresources}  \\
%  Page/Resources/ColorSpace             & \cs{pdfpageresources}  \\%
%  \end{tabular}
%
%  There is no \texttt{Page/Resources/Properties} dictionary in the list
%  as this dictionary is not filled directly but
%  managed through side effects when setting BDC-marks.
%  \subsection{User Commands}
%
% \begin{function}[added = 2020-04-06]
%   {\pdfgdict_gput:nnn}
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \Arg{core dictionary} \Arg{name} \Arg{value}\\
%   \end{syntax}
% This function puts \Arg{name} \Arg{value}  globally in an internal
% property lists.
% \Arg{core dictionary} is a symbolic name for a concrete PDF dictionary to
% which the content of these property lists will be written by the PDF
% resource management code.
% \Arg{name} should be a valid PDF Name without
% the starting slash.
% \Arg{value} should be a valid PDF value for this Name in the
% target dictionary.
%
% The PDF resource management code predefines a large number of
% symbolic names for important core dictionaries and will write the stored values
% at the right time to the PDF. The predefined symbolic names are described below.
%
% The code works with all major engines but not necessarily
% in the same way. Most importantly
% \begin{itemize}
% \item The expansion behaviour of the backends can differ. Some backends expand a
% value always fully when writing to the PDF, with other backends command names
% could end as strings in the PDF. So one should neither rely on \Arg{name}
% \Arg{value} to be expanded nor not expanded by the backend commands.
% \item The number of compilations needed can differ between the engines and
% backends. Some engines have to use labels and the aux-file to setup
% the dictionaries and so need at least two compilations to put everything
% in place.
% \end{itemize}
% \end{function}
% \begin{function}[added = 2020-04-08]
%   {\pdfgdict_show:n }
%   \begin{syntax}
%     \cs{pdfgdict_show:n}  \Arg{dictionary}
%   \end{syntax}
%   This shows the content of \Arg{dictionary} in the log and on the terminal.
%   It doesn't show the special catalog dictionaries with arrays as values
%   as these are filled only at the end of the document. It is not reliable for
%   page resources as these are filled at shipout.
%\end{function}
% \begin{function}[added = 2020-04-07]
%   {
%     \pdfgdict_gremove:nn,
%   }
%   \begin{syntax}
%     \cs{pdfgdict_gremove:nn} \Arg{global dictionary} \Arg{name}
%   \end{syntax}
%   Removes  |/|\meta{name} and its associated \meta{value} from the \Arg{dictionary}
%   The removal is global.
%   If \meta{name} is not found no change occurs,
%   \emph{i.e}~there is no need to test for the existence of a name before
%   trying to remove it.
%   Values from the special Catalog entries with arrays as values can not be
%   removed.
% \end{function}
% \subsection{The core dictionaries}
% \subsubsection{The Info dictionary}
% \potentialclash If the primitive commands of the engines are used too there will
% be double entries in the pdf (at least with the backend pdftex and luatex).
% How pdf viewer handles this is unpredictable.
%
%  \begin{function}
%   {
%     pdfgdict: Info
%   }
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \{Info\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Adds |/|\meta{name} and the \meta{value} to the Info dictionary.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value. Any escaping or (re)encoding must be
%   done explicitly.
%   If a \meta{name} is used twice, only the last \meta{value}
%   set will be used. The info dictionary is written at the end of the compilation,
%   so values can be set at any time.
%   The info dictionary expects utf16be in the strings, so a conversion like this is
%   normally sensible:
%   \begin{verbatim}
%   \sys_if_engine_pdftex:TF
%    {
%     \str_set_convert:Nnnn \l_tmpa_str { Grüße }{ utf8 } {utf16/string}
%    }
%    {
%     \str_set_convert:Nnnn \l_tmpa_str { Grüße }{  } {utf16/string}
%    }
%   \pdfgdict_gput:nnx {Info} {Title}{(\l_tmpa_str)}
%   \end{verbatim}
% \end{function}
%
% \subsubsection{The \enquote{Pages} dictionary}
% \potentialclash As the content of this dictionary is written at the end it will
% in pdftex and luatex overwrite values added with the primitive commands (e.g.
% \cs{pdfpagesattr}.
% Package authors should use the management commands instead.

% The content of the property list associated with this dictionary name
% is written to the /Pages object. This replaces for example \cs{pdfpagesattr}.
%
% \begin{function}{pdfgdict: Pages}
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \{Pages\} \Arg{name} \Arg{value}
%   \end{syntax}
%
%   Adds |/|\meta{name} \meta{value} to the |/Pages| dictionary.
%   It is always stored globally. The content is written to the pdf
%   at the end of the compilation, so values can be added, changed or
%   removed until then.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value. Any escaping or (re)encoding must
%   be done explicitly. Some backends expand the value but this should not be
%   relied on. If a \meta{name} is used twice, only the last \meta{value}
%   set will be used.
%
% \end{function}
%
% \subsubsection{\enquote{Page} and \enquote{ThisPage}}
% \begin{function}[added = 2020-04-12]
%   {pdfgdict: Page}
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \{Page\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Values added to the dictionary \texttt{Page} are added to the page dictionary
%   of the current page and the following pages. The current page means the page
%   on which the command is \emph{executed}. \meta{name} should be a valid pdf name
%   without the leading slash. Typical names used here are e.g.
%   \texttt{Rotate} and \texttt{CropBox}.
%   \meta{value} should be a valid pdf value.
%   Any escaping or (re)encoding must be done explicitly. Some backends expand the
%   value but this should not be relied on.
%   To avoid problems with the asynchronous page breaking
%   the command should be used after \cs{newpage}, or in the header,
%   and better not in a float.
%   The value is assigned directly and is always stored globally.
%   If a \meta{name} is used twice, only the last \meta{value}
%   set will be used. Names set with \cs{pdfgdict_gput:nnn}|{ThisPage}| will overwrite
%   names set with \cs{pdfgdict_gput:nnn}|{Page}| if there is a clash.
%   Values can be removed again with \cs{pdfgdict_gremove:nn}
% \end{function}
% \begin{function}[added = 2020-04-12]
%   { pdfgdict: ThisPage}
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \{ThisPage\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Adds |/|\meta{name} \meta{value} at \emph{shipout} to the page dictionary of the
%   current page. Current page means here the \emph{shipout} page.
%   It is always stored globally.
%   If \Arg{name} has already a value set in the \texttt{Page}
%   dictionary it will be overwritte for this page.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value. Any escaping or (re)encoding must be
%   done explicitly. If a \meta{name} is used twice, only the last \meta{value}
%   set will be used.
%   With the engine pdflatex (at least) a second compilation is needed.
%   Values added to \texttt{ThisPage} can not be removed. It is not possible to
%   show the content of this dictionary with \cs{pdfgdict_show:n}.
% \end{function}
% \subsubsection{\enquote{Page/Resources}: ExtGState, ColorSpace, Shading, Pattern}
% \begin{function}[updated = 2020-04-10]
%   {
%    pdfgdict: Page/Resources/ExtGState,
%    pdfgdict: Page/Resources/ColorSpace,
%    pdfgdict: Page/Resources/Shading,
%    pdfgdict: Page/Resources/Pattern,
%   }
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \{Page/Resources/\meta{resource}\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Adds |/|\meta{name} \meta{value} to the page resource \meta{resource}.
%   \meta{resource} can be |ExtGState|, |ColorSpace|, |Pattern| oder |Shading|.
%   The values are always stored globally. The content is written to the pdf
%   at the end of the compilation, so values can be added until then.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value for the resource.
%   Any escaping or (re)encoding must be done explicitly. If a \meta{name} is
%   used twice, only the last \meta{value} set will be used.
%
%   With the dvips backend the command does nothing: resources are managed by
%   ghostscript or the distiller if e.\,g. transparency is used.
%
%   The resources are added to all pages starting with the first where something has
%   been added to a resources. That means that for example
%   all ExtGState resources are combined in one
%   dictionary object and every page with a ExtGState resource refer to this object.
%
%   \potentialclash The primitive commands to set the resources should not be used
%   together with this code as the calls will overwrite each other and values
%   will be lost. This means that currently there are clashes with the packages tikz,
%   transparent and colorspace.
% \end{function}
% \subsubsection{\enquote{Catalog} \& subdirectories}
% The catalog is a central dictionary in a PDF with a number of subdictionaries.
% Entries to the top level of the catalog can be added with
% |\pdfgdict_gput:nnn {Catalog}|\Arg{Name}\Arg{Value}.
% Entries to subdictionaries by using in the first
% argument one of the pathes described later.
% The entries in the catalog have varying requirements regarding the
% PDF management. Some entries (like \texttt{/Lang}) are simple values
% where new values should
% overwrite existing values, other like for example \texttt{/OutputIntents}
% can contain a number of values and can be filled from more than one source.
% In some cases the values that needs to be added are not at the top-level
% but in some subsubdictionary or are actually part of an array.
% To handle this some pathes use internally special handlers.
%
% \potentialclash In some cases entries are added implicitly.
% For example entries to the name
% tree of the \texttt{/EmbeddedFiles} key in the \texttt{/Names} directory are
% added with the commands of the \texttt{l3pdffile} module. This clashes with
% e.g. the embedfile package which should not be used!
%
%
%   \paragraph{Entries at the top level of the catalog}
%   The Names in the following tabular are entries that are added to the
%   top level of the catalog.
%
%   If \meta{Name} gets assigned a value more than once the last one wins.
%   There is no check that the values have the correct type and format.
%   It is up to the user to ensure that the value does what is intended.
%
%   The required PDF version is only mentioned if it is larger than 1.5.
%
%   Example: |\pdfgdict_gput:nnn {Catalog}{PageMode}{/UseNone}|
%
%% !!!!!!!! Warning for unknown names is currently not working!
%   \medskip
%   \noindent
%   \begin{tabularx}{\linewidth}{ll>{\raggedright\arraybackslash}X}
%    \bfseries Name           &  \bfseries Value  & \bfseries Remark \\\midrule
%    Collection              &  objref or dict     & the content should be
%     build by external packages (see eg embedfile)                   \\
%    DPartRoot               &  objref or dict     & PDF 2.0           \\
%    Lang                    &  string             & e.g. \texttt{(de-DE)} \\
%    Legal                   &  objref or dict                             \\
%    Metadata                &  obj ref or stream                       \\
%    NeedsRendering          &  boolean            &   PDF 1.7\\
%    OpenAction              &  array (dest) or dict (action) \\
%    PageLabels              &  objref or dict     &  number tree \\
%    PageLayout              &  name               & one of /SinglePage, /OneColumn,
%                                        /TwoColumnLeft, /TwoColumnRight,
%                                        /TwoPageLeft,
%                                        /TwoPageRight \\
%    PageMode                &  name               & one of /UseNone, /UseOutlines, /UseThumbs,
%                                    /UseOC, /UseAttachments (PDF 1.6)\\
%    Perms                   &  objref or dict     & permissions\\
%    PieceInfo               &  objref or dict \\
%    SpiderInfo              &  objref or dict \\
%    StructTreeRoot          &  obj ref or dict \\
%    Threads                 &  objref to an array\\
%    URI                     &  objref or dict \\
%    Version                 &  name           & eg. \texttt{/1.7} \\
%    \meta{unknown}          &                 & an unknown \meta{name} will be
%                                                inserted without a warning.\\
%   \end{tabularx}
%   \par\medskip
%
%   \paragraph{Simple entries in subdictionaries of the catalog}
%   The following dictionaries have been predeclared and allow to
%   add values to the respective subdictionaries of the catalog. The
%   names of the dictionaries follow the naming and location of the dictionaries
%   in the PDF reference.
%   If \meta{Name} gets assigned two values the last one wins.
%
%   Example: |\pdfgdict_gput:nnn {Catalog/MarkInfo}{Marked}{true}|
%
%   \medskip
%   \noindent
%   \begin{tabularx}{\linewidth}{llll>{\raggedright\arraybackslash}X}
%    \bfseries Dictionary    & \bfseries Names & \bfseries Value  & \bfseries Remark
%    \\\midrule
%    Catalog/AA              &WC, WS, DS, WP,DP& all dict    \\
%    Catalog/AcroFrom        &  NeedAppearances&  boolean & In pdf 2.0
%                                                           NeedAppearances
%                                                           is deprecated,
%                                                           it is then required
%                                                           that every widget has
%                                                           an appearance streams.\\
%                            &  SigFlags       & Integer\\
%                            &  DA             & String \\
%                            &  Q              & Integer\\
%                            &  XFA            & stream or array & pdf 1.5\\
%  Catalog/AcroForm/DR       & \meta{name}     &            & probably unneeded \\
%  Catalog/AcroForm/DR/Font  & \meta{name}     & dict       & \\
%  Catalog/MarkInfo          & Marked          & boolean      \\
%                            & UserProperties  & boolean      \\
%                            & Suspects        & boolean      \\
%  Catalog/ViewerPreferences & HideToolbar     & boolean      \\
%                            & Direction       & /R2L or /L2R \\
%                            & \ldots          &              & many more, see the reference \\
% \end{tabularx}
%
%
% \paragraph{Catalog entries with multiple values in arrays}
% The following entries are special: Their values are arrays and
% it must be possible to append to such arrays. This means that a new
% call to set this value doesn't replace the value but appends it.
% The value is an object reference. It is sensible to declare the object
% first. E.g.
%  \begin{verbatim}
%  \pdf_object_new:nn   {pkg@intent}{dict}
%  \pdf_object_write:nn {pkg@intent}{...}
%  \pdfgdict_gput:nnx  {Catalog} {OutputIntents}{\pdf_object_ref:n {pkg@intent}}
%  \end{verbatim}
%
%  or
%  \begin{verbatim}
%  \pdf_object_now:nn   {dict} { ... }
%  \pdfgdict_gput:nnx  {Catalog} {OutputIntents}{\pdf_object_last:}
%  \end{verbatim}
%
%
%   \medskip
%   \noindent
%   \begin{tabularx}{\linewidth}{lll>{\raggedright\arraybackslash}X}
%    \bfseries Dictionary &\bfseries Name        & \bfseries Value   & \bfseries Remark \\\midrule
%    Catalog/AcroForm     & Fields               & object reference\\
%    Catalog/AcroForm     & CO                   & object reference\\
%    Catalog              & AF                   & object reference\\
%    Catalog/OCProperties & OCGs                 & object reference  &if there are OCProperties, OCGs and D are required.\\
%    Catalog/OCProperties & Configs              & object reference \\
%    Catalog/OCProperties & D                    & object reference & This actually a single value as
%                                         there can be only one default.
%                                         If the value is set twice, the
%                                         second wins, and the first is
%                                         added to OCProperties/Configs.\\
%    Catalog              & OutputIntents        & object reference\\
%    Catalog              & Requirements         & object reference & PDF 1.7 \\
%   \end{tabularx}
%
% \end{documentation}
%
% \begin{implementation}
%  \section{\pkg{l3pdfgdict} implementation}
%    \begin{macrocode}
%<@@=pdfgdict>
%<*package>
%
\ProvidesExplPackage {l3pdfgdict} {2020-04-08} {0.5}
  {Managing global and local dictionaries}
%    \end{macrocode}
% \subsection{Messages}
%    \begin{macrocode}
\msg_new:nnn  { pdfgdict } { unknown-dict }
              { The~dictionary~'#1'~is~not~declared. }

\msg_new:nnn  { pdfgdict } { empty-value }
              { The~value~for~#1~is~empty~and~will~be~ignored }

\msg_new:nnn  { pdfgdict } { no-removal }
              { It~is~not~possible~to~remove~values~from~dictionary~'#1'.}

\msg_new:nnn  { pdfgdict } { no-show }
              { It~is~not~possible~to~show~the~dictionary~'#1'.}

\msg_new:nnn  { pdfgdict } { show-dict }
  {
    The~dictionary~'#1'~
    \tl_if_empty:nTF {#2}
      { is~empty \\>~ . }
      { contains~the~pairs~(without~outer~braces): #2 . }
  }
\msg_new:nnn  { pdfgdict } { dict-already-defined  }
  {
    The~dictionary~'#1'~is~already~defined.
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfgdict_gput:nnn #1 #2 #3
  {
    \@@_if_exist:nTF { #1 }
      {
        \@@_handler_gput:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \msg_error:nnn{pdfgdict}{unknown-dict}{#1}
      }
  }

\cs_generate_variant:Nn \pdfgdict_gput:nnn {nnx}
%    \end{macrocode}
% \subsection{Internal dictionary Code}
%  Many code parts are quite similar: property lists for
%  dictionaries are filled and output.
%  So we define some generic commands to ensure systematic
%  internal names. The names are based on paths separated by slashed.
%  The first slash is not used in the names.
%
%  Currently the following names are used: ^^A!!!!! check, compare with g_@@_gnames_seq
%  \begin{verbatim}
%  /Info                      %    (\pdfinfo)
%  /Catalog                   %    (\pdfcatalog)
%  /Catalog/AA                %
%  /Catalog/AcroForm
%  /Catalog/OCProperties
%  /Catalog/OutputIntents
%  /Catalog/AcroForm/DR
%  /Catalog/AcroForm/DR/Font
%  /Catalog/MarkInfo
%  /Catalog/ViewerPreferences
%  /Pages                     %    (\pagesattr)
%  /Page                      %    (\pageattr)
%  /ThisPage                  %    (\pageattr)
%  /backend_PageN/Resources/Properties %
%  /Page/Resources/ExtGState
%  /Page/Resources/ColorSpace
%  /Page/Resources/Pattern
%  /Page/Resources/Shading
%  /Page/Resources/Properties
%  /xform/Resources/Properties
%  \end{verbatim}

% \begin{macro}
%   {
%    \@@_name:n,
%    \@@_new:n,
%    \g_@@_names_seq,
%   }
%    \begin{macrocode}
\seq_new:N \g_@@_names_seq

\cs_new:Npn \@@_name:n #1 % path name without the leading /
  {
    g_@@_/#1_prop
  }

\cs_new_protected:Npn \@@_new:n #1
  {
    \@@_if_exist:nTF { #1 }
      {
        \msg_error:nnx
          { pdfgdict }
          { dict-already-defined }
          { #1}
       }
      {
        \prop_new:c  { \@@_name:n { #1 } }
        \seq_gput_right:Nn \g_@@_names_seq { #1 }
      }
  }

% test existence
\prg_new_conditional:Npnn \@@_if_exist:n #1 { p , T , F , TF }
  {
    \prop_if_exist:cTF
      { \@@_name:n { #1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }

\prg_new_conditional:Npnn \@@_if_empty:n #1 { p , T , F , TF }
  {
    \prop_if_empty:cTF
      { \@@_name:n { #1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\@@_gclear:n}
%    \begin{macrocode}
  \cs_new_protected:Npn \@@_gclear:n #1
  {
    \@@_if_exist:nT { #1 }
      {
        \prop_gclear:c  { \@@_name:n { #1 } }
      }
  }
%    \end{macrocode}
% \end{macro}
%  \begin{macro}{
%                \@@_handler_gput:nnn,
%                \@@_gput:nnn,
%                \@@_get:nnN,
%                \@@_gremove:nn,
%                \@@_show:n
%                }
%  \cs{@@_handler_gput:nnn} is the main command to fill the dictionaries.
%  In simple cases it directly fill the property list, but if a handler exists
%  this is called. It is important to use it only in places where this make sense.
%  \cs{@@_put:nnn} is a simpler variant which only fills the property list.
%
%    \begin{macrocode}

%global
\cs_new_protected:Npn \@@_handler_gput:nnn #1 #2 #3  %#1 path, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfgdict }{ empty-value }{ /#1/#2 }
      }
      {
        \@@_if_exist:nTF { #1 }
          {
            \cs_if_exist:cTF
              { @@_handler/#1/?_gput:nn } %general, name independant handler
              { \use:c {@@_handler/#1/?_gput:nn} {#2} {#3} }
              {
                \cs_if_exist:cTF
                  { @@_handler/#1/#2_gput:n }
                  { \use:c {@@_handler/#1/#2_gput:n} {#3} } %special handler
                  {
                    \use:c { prop_gput:cnn }
                      { \@@_name:n { #1 } }{ #2 } { #3 }
                  }
              }
          }
          {
            \msg_error:nnn { pdfgdict } { unknown-dict } { #1 }
          }
      }
  }


\cs_generate_variant:Nn \@@_handler_gput:nnn {nxx}

\cs_new_protected:Npn \@@_gput:nnn #1 #2 #3  %#1 path, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfgdict }{ empty-value }{ /#1/#2 }
      }
      {
       \@@_if_exist:nTF { #1 }
         {
           \use:c { prop_gput:cnn }
             { \@@_name:n { #1 } }{ #2 } { #3 }
         }
         {
           \msg_error:nnn { pdfgdict } { unknown-dict } { #1 }
         }
      }
  }

\cs_new_protected:Npn \@@_get:nnN  #1 #2 #3 %path,key,macro
  {
    \prop_get:cnN
      { \@@_name:n { #1 } }
      { #2 } #3
  }


\cs_new_protected:Npn \@@_handler_gremove:nn #1 #2 %path,key
  {
    \@@_if_exist:nTF { #1 }
          {
            \cs_if_exist:cTF
              { @@_handler/#1/?_gremove:n } %general, name independant handler
              { \use:c {@@_handler/#1/?_gremove:n} {#2} }
              {
                \cs_if_exist:cTF
                  { @@_handler/#1/#2_gremove: }
                  { \use:c {@@_handler/#1/#2_gremove:} } %special handler
                  {
                    \prop_gremove:cn
                      { \@@_name:n { #1 } }{ #2 }
                  }
              }
          }
          {
            \msg_error:nnn { pdfgdict } { unknown-dict } { #1 }
          }
  }

\cs_new_protected:Npn \@@_gremove:nn #1 #2 %path,key
  {
    \@@_if_exist:nTF { #1 }
          {
            \prop_gremove:cn
              { \@@_name:n { #1 } }{ #2 }
          }
          {
            \msg_error:nnn { pdfgdict } { unknown-dict } { #1 }
          }
  }


\cs_new_protected:Npn \@@_show:Nn #1#2
  {
    \cs_if_exist:cTF
      { @@_handler/#2/?_show: } %general, name independant handler
      { \use:c {@@_handler/#2/?_show:} }
      {
        \prop_if_exist:cTF { \@@_name:n { #2 } }
          {
             #1
               { pdfgdict } { show-dict }
               { \tl_to_str:n {#2} }
               { \prop_map_function:cN {\@@_name:n { #2 }} \msg_show_item:nn }
               { } { }
          }
          {
            #1 { pdfgdict } { unknown-dict } {#2}{}{}{}
          }
       }
  }

\cs_new_protected:Npn \@@_show:n #1  %path
  {
    \prop_show:c { \@@_name:n { #1 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_map:n }
% \cs{@@_map:n} outputs a prop as needed in a dictionary:
%  as a list of /\meta{key} \meta{value} pairs.
%    \begin{macrocode}
% !! is e-expansion the right thing?
\cs_new:Npn \@@_map:n #1 %path
  {
    \prop_map_function:cN { \@@_name:n { #1 } } \pdfdict_item:ne
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_gmerge:nnN }
% \cs{@@_gmerge:nnN} merges at first the property \meta{name_1}
%  then optionally \meta{name_2} into property |#3|.
%    \begin{macrocode}

\cs_new_protected:Npn \@@_gmerge:nnN #1 #2 #3
  {
    \prop_gset_eq:Nc #3 { \@@_name:n  { #1 } }
    \prop_if_exist:cT  { \@@_name:n  { #2 } }
      {
        \prop_map_inline:cn { \@@_name:n  { #2 } }
          {
            \prop_gput:Nnn #3 { ##1 }{ ##2 }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfgdict_show:n #1
  {
    \@@_show:Nn \msg_show:nnxxxx {#1}
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfgdict_gremove:nn #1 #2
  {
    \@@_if_exist:nTF { #1 }
      {
        \@@_handler_gremove:nn { #1 }{ #2 }
      }
      {
        \msg_error:nnn{pdfgdict}{unknown-dict}{#1}
      }
  }
%    \end{macrocode}
% \subsection{The Info dictionary}
% Initialization of the dictionary:
%    \begin{macrocode}
\@@_new:n {Info}
%    \end{macrocode}
%
% \begin{macro}{\@@_Info_gpush:}
% \cs{@@_Info_gpush:} is the command that outputs the info dictionary (currently
% in the end-of-run hooks).
%    \begin{macrocode}
% push to the register command / issue the special
\cs_new_protected:Npn \@@_Info_gpush:
  {
    \prop_map_function:cN  { \@@_name:n {Info} } \__pdf_backend_info_gput:nn
    \prop_gclear:c { \@@_name:n {Info} }
  }
%    \end{macrocode}
% \end{macro}
% \subsection{The Pages dictionary code}
% At first the initialisation
%     \begin{macrocode}
\@@_new:n {Pages}
%    \end{macrocode}
%
% \begin{macro}{\@@_Pages_gpush:}
% This is the command that outputs the Pages dictionary. It is used
% at the end of the document in \cs{g__pdf_backend_end_run_tl}
%    \begin{macrocode}
% push to the register command / issue the special
\cs_new_protected:Npn \@@_Pages_gpush:
  {
    \exp_args:Nx \__pdf_backend_Pages_primitive:n
      {
        \@@_map:n {Pages}
      }
  }

%    \end{macrocode}
% \end{macro}
% \subsection{The Page and ThisPage dictionary}
% At first the initialisation.
%    \begin{macrocode}
\@@_new:n { Page }
\@@_new:n { ThisPage }

%handler for pdfgdict
\cs_new_protected:cpn { @@_handler/Page/?_gput:nn } #1 #2
  {
    \__pdf_backend_Page_gput:nn { #1 }{ #2 }
  }
% remove:
\cs_new_protected:cpn { @@_handler/Page/?_gremove:n } #1
  {
    \__pdf_backend_Page_gremove:n { #1 }
  }

% handler for pdfgdict
\cs_new_protected:cpn { @@_handler/ThisPage/?_gput:nn } #1 #2
  {
    \prop_gput:cnn  { \@@_name:n { ThisPage } }{ #1 } { #2 }
    \__pdf_backend_ThisPage_gput:nn { #1 }{ #2 }
  }

\cs_new_protected:cpn { @@_handler/ThisPage/?_gremove:n } #1
  {
    \msg_warning:nnn { pdfgdict } { no-removal }{ThisPage}
  }

\cs_new_protected:cpn { @@_handler/ThisPage/?_show: }
  {
    \msg_warning:nnn { pdfgdict } { no-show }{ThisPage}
  }

%    \end{macrocode}
% \subsubsection{\enquote{Page/Resources}: ExtGState, ColorSpace, Shading, Pattern}
%    \begin{macrocode}
%
% setter:  #1 is the name of the resource
\cs_new_protected:cpn { @@_handler/Page/Resources/ExtGState/?_gput:nn } #1 #2
  {
    \__pdf_backend_PageResources_gput:nnn {ExtGState} { #1 }{ #2 }
  }

\cs_new_protected:cpn { @@_handler/Page/Resources/ColorSpace/?_gput:nn } #1 #2
  {
    \__pdf_backend_PageResources_gput:nnn {ColorSpace} { #1 }{ #2 }
  }

\cs_new_protected:cpn { @@_handler/Page/Resources/Shading/?_gput:nn } #1 #2
  {
    \__pdf_backend_PageResources_gput:nnn {Shading} { #1 }{ #2 }
  }

\cs_new_protected:cpn { @@_handler/Page/Resources/Pattern/?_gput:nn } #1 #2
  {
    \__pdf_backend_PageResources_gput:nnn {Pattern} { #1 }{ #2 }
  }
%    \end{macrocode}
% \begin{variable}[added=2019-08-24]
%     {
%      \c_@@_Catalog_toplevel_clist,
%      \c_@@_Catalog_sub_clist,
%      \c_@@_Catalog_seq_clist,
%     }
%  This variables hold the list of the various types of entries. With it
%  the various \verb=_gput= commands are generated.
%  \end{variable}
%  \begin{macro}{ \@@_catalog_XX_gput:n }
% Various commands to handle subentries and special cases.
%    \begin{macrocode}
\@@_new:n {Catalog}

\clist_const:Nn \c_@@_Catalog_toplevel_clist
  {
    Collection,
    DPartRoot,
    Lang,
    Legal,
    Metadata,
    NeedsRendering,
    OCProperties/D,
    OpenAction,
    PageLabels,
    PageLayout,
    PageMode,
    Perms,
    PieceInfo,
    SpiderInfo,
    StructTreeRoot,
    Threads,
    URI,
    Version
  }

\clist_const:Nn \c_@@_Catalog_sub_clist
  {
    AA,
    AcroForm,
    AcroForm/DR,
    AcroForm/DR/Font,
    MarkInfo,
    ViewerPreferences,
    OCProperties
  }

\clist_map_inline:Nn \c_@@_Catalog_sub_clist
  {
    \@@_new:n {Catalog/#1}
  }


\clist_const:Nn \c_@@_Catalog_seq_clist
  {
    AF,
    OCProperties/OCGs,
    OCProperties/Configs,
    OutputIntents,
    Requirements,
    AcroForm/Fields,
    AcroForm/CO
  }



\clist_map_inline:Nn \c_@@_Catalog_seq_clist
 {
   \seq_new:c { g_@@_/Catalog/#1_seq } % new name later
   \cs_new_protected:cpn { @@_handler/Catalog/#1_gput:n } ##1
     {
       \seq_gput_right:cn { g_@@_/Catalog/#1_seq } {  ##1  }
     }
 }

\cs_new_protected:cpn { @@_handler/Catalog/OCProperties/D_gput:n } #1
  {
    \seq_gput_left:cn
      { g_@@_/Catalog/OCProperties/Configs_seq }
      {  #1  }
  }
%    \end{macrocode}
% \end{macro}
% % \paragraph {Building the catalog: Push order}
% \begin{macro}{\@@_Catalog_gpush:}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_Catalog_gpush:
  {
    \use:c { @@_/Catalog/AA_gpush: }
    \use:c { @@_/Catalog/AcroForm_gpush: }
    \use:c { @@_/Catalog/AF_gpush: }
    \use:c { @@_/Catalog/MarkInfo_gpush: }
    \use:c { @@_/Catalog/OCProperties_gpush: }
    \use:c { @@_/Catalog/OutputIntents_gpush: }
    \use:c { @@_/Catalog/Requirements_gpush: }
    \use:c { @@_/Catalog/ViewerPreferences_gpush: }
    % output the single values:
    \prop_map_function:cN { \@@_name:n {Catalog} }  \__pdf_backend_catalog_gput:nn
    % output names tree:
    \use:c { @@_/Catalog/Names/EmbeddedFiles_gpush: }
  }
%    \end{macrocode}
% \end{macro}
% \paragraph{Building catalog entries: AA}
% \begin{macro}{\@@_/Catalog/AA_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_/Catalog/AA_gpush: }
  {
    \prop_if_empty:cF
     { \@@_name:n { Catalog/AA } }
     {
       \__pdf_backend_object_new:nn  { g_@@_/Catalog/AA_obj } { dict }
       \__pdf_backend_object_write:nx
            { g_@@_/Catalog/AA_obj }
            { \@@_map:n { Catalog/AA } }
       \exp_args:Nnx
         \__pdf_backend_catalog_gput:nn
           {AA}
           {
             \__pdf_backend_object_ref:n { g_@@_/Catalog/AA_obj }
           }
     }
  }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Building catalog entries: AcroFrom}
% This is the most complicated case.
% The entries is build from
% /Catalog/AcroForm/Fields  (array),
% /Catalog/AcroForm/CO      (array),
% /Catalog/AcroForm/DR/Font (dict),
% /Catalog/AcroForm/DR      (dict),
% /Catalog/AcroForm
%
% \begin{macro}{\@@_/Catalog/AcroForm_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_/Catalog/AcroForm_gpush: }
  {
    \seq_if_empty:cF { g_@@_/Catalog/AcroForm/Fields_seq }
      {
        \__pdf_backend_object_new:nn  { g_@@_/Catalog/AcroForm/Fields_obj } { array }
        \__pdf_backend_object_write:nx
            { g_@@_/Catalog/AcroForm/Fields_obj }
            { \seq_use:cn { g_@@_/Catalog/AcroForm/Fields_seq } {~} }
        \exp_args:Nnnx
          \prop_gput:cnn %we have to use \prop here to avoid the handler ...
            { \@@_name:n { Catalog/AcroForm } }
            { Fields }
            { \__pdf_backend_object_ref:n { g_@@_/Catalog/AcroForm/Fields_obj } }
      }
    \seq_if_empty:cF { g_@@_/Catalog/AcroForm/CO_seq }
      {
        \__pdf_backend_object_new:nn  { g_@@_/Catalog/AcroForm/CO_obj } { array }
        \exp_args:Nnx
          \__pdf_backend_object_write:nn
            { g_@@_/Catalog/AcroForm/CO_obj }
            { \seq_use:cn { g_@@_/Catalog/AcroForm/CO_seq } {~} }
        \exp_args:Nnnx
          \prop_gput:cnn %we have to use \prop here to avoid the handler ...
            { \@@_name:n { Catalog/AcroForm } }
            { CO }
            { \__pdf_backend_object_ref:n { g_@@_/Catalog/AcroForm/CO_obj } }
      }
     \prop_if_empty:cF { \@@_name:n { Catalog/AcroForm/DR/Font}}
       {
         \__pdf_backend_object_new:nn { g_@@_/Catalog/AcroForm/DR/Font_obj } {dict}
         \exp_args:Nnx
           \__pdf_backend_object_write:nn
             { g_@@_/Catalog/AcroForm/DR/Font_obj }
             { \@@_map:n { Catalog/AcroForm/DR/Font } }
         \exp_args:Nnnx
           \prop_gput:cnn %we have to use \prop here to avoid the handler ...
             { \@@_name:n { Catalog/AcroForm/DR } }
             { Font }
             { \__pdf_backend_object_ref:n { g_@@_/Catalog/AcroForm/DR/Font_obj } }
       }
     \prop_if_empty:cF { \@@_name:n { Catalog/AcroForm/DR}}
       {
         \__pdf_backend_object_new:nn { g_@@_/Catalog/AcroForm/DR_obj } {dict}
         \exp_args:Nnx
           \__pdf_backend_object_write:nn
             { g_@@_/Catalog/AcroForm/DR_obj }
             { \@@_map:n { Catalog/AcroForm/DR } }
         \exp_args:Nnnx
           \prop_gput:cnn %we have to use \prop here to avoid the handler ...
             { \@@_name:n { Catalog/AcroForm } }
             { DR }
             { \__pdf_backend_object_ref:n { g_@@_/Catalog/AcroForm/DR_obj } }
       }
     \prop_if_empty:cF { \@@_name:n { Catalog/AcroForm} }
       {
         \__pdf_backend_object_new:nn { g_@@_/Catalog/AcroForm_obj } {dict}
         \exp_args:Nnx
           \__pdf_backend_object_write:nn
             { g_@@_/Catalog/AcroForm_obj }
             { \@@_map:n { Catalog/AcroForm } }
         \exp_args:Nnnx
           \@@_handler_gput:nnn
             { Catalog }
             { AcroForm }
             { \__pdf_backend_object_ref:n { g_@@_/Catalog/AcroForm_obj } }
       }
  }

%    \end{macrocode}
% \end{macro}
%
% \paragraph{Building catalog entries: AF}
% AF is an array.
% \begin{macro}{\@@_/Catalog/AF_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_/Catalog/AF_gpush: }
  {
    \seq_if_empty:cF
     { g_@@_/Catalog/AF_seq }
     {
       \__pdf_backend_object_new:nn  { g_@@_/Catalog/AF_obj } { array }
       \exp_args:Nnx
         \__pdf_backend_object_write:nn
            { g_@@_/Catalog/AF_obj }
            { \seq_use:cn { g_@@_/Catalog/AF_seq } {~} }
       \exp_args:Nnx
         \__pdf_backend_catalog_gput:nn
           {AF}
           {
             \__pdf_backend_object_ref:n {g_@@_/Catalog/AF_obj}
           }
     }
  }
%    \end{macrocode}
% \end{macro}
% %
% \paragraph{Building catalog entries: MarkInfo}
% \begin{macro}{\@@_/Catalog/MarkInfo_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_/Catalog/MarkInfo_gpush: }
  {
    \prop_if_empty:cF
     { \@@_name:n { Catalog/MarkInfo } }
     {
       \__pdf_backend_object_new:nn  { g_@@_/Catalog/MarkInfo_obj } { dict }
       \exp_args:Nnx
         \__pdf_backend_object_write:nn
            { g_@@_/Catalog/MarkInfo_obj }
            { \@@_map:n {Catalog/MarkInfo } }
       \exp_args:Nnx
         \__pdf_backend_catalog_gput:nn
           {MarkInfo}
           {
             \__pdf_backend_object_ref:n {g_@@_/Catalog/MarkInfo_obj}
           }
     }
  }
%    \end{macrocode}
% \end{macro}
%
%\paragraph{Building catalog entries: OCProperties}
%  This is a dictionary with three entries:
%  \begin{description}
%  \item[/OCGs] (required) An array of indirect references,
%               access needed for more than one package.
%  \item[/D] (required) a dict (given as an object name) to the default
%            configuration
%  \item[/Configs] (optional) an array of indirect references to more
%        configurations.
%  \end{description}
%  The /D entry is also a config, it is the first of the seq.
%  The overall structure is nested: a dict with arrays.
% \begin{macro}{\@@_/Catalog/OCProperties_gpush:}
%    \begin{macrocode}
% Catalog/OCProperties: OCGs + D is required
\cs_new_protected:cpn { @@_/Catalog/OCProperties_gpush: }
  {
   \int_compare:nNnT
      {
        ( \seq_count:c { g_@@_/Catalog/OCProperties/OCGs_seq }  )*
        ( \seq_count:c { g_@@_/Catalog/OCProperties/Configs_seq } )
      }
      >
      { 0 }
      {
        \__pdf_backend_object_new:nn  { g_@@_/Catalog/OCProperties_obj } { dict }
        \seq_gpop_left:cN { g_@@_/Catalog/OCProperties/Configs_seq} \l_tmpa_tl
        \exp_args:Nnx
          \__pdf_backend_object_write:nn {g_@@_/Catalog/OCProperties_obj}
            {
              /OCGs~[ \seq_use:cn { g_@@_/Catalog/OCProperties/OCGs_seq } {~} ]
              /D~\l_tmpa_tl~
              \seq_if_empty:cF { g_@@_/Catalog/OCProperties/Configs_seq }
                {
                  /Configs~
                  [ \seq_use:cn { g_@@_/Catalog/OCProperties/Configs_seq} {~} ]
                }
            }
        \exp_args:Nnx
          \__pdf_backend_catalog_gput:nn
            { OCProperties }
            { \__pdf_backend_object_ref:n {g_@@_/Catalog/OCProperties_obj} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Building catalog entries: OutputIntents}
% OutputIntents is an array.
% \begin{macro}{\@@_/Catalog/OutputIntents_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_/Catalog/OutputIntents_gpush: }
  {
    \seq_if_empty:cF
     { g_@@_/Catalog/OutputIntents_seq }
     {
       \__pdf_backend_object_new:nn  { g_@@_/Catalog/OutputIntents_obj } { array }
       \exp_args:Nnx
         \__pdf_backend_object_write:nn
            { g_@@_/Catalog/OutputIntents_obj }
            { \seq_use:cn { g_@@_/Catalog/OutputIntents_seq } {~} }
       \exp_args:Nnx
         \__pdf_backend_catalog_gput:nn
           {OutputIntents}
           {
             \__pdf_backend_object_ref:n {g_@@_/Catalog/OutputIntents_obj}
           }
     }
  }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Building catalog entries: Requirements}
% Requirements  is an array.
% \begin{macro}{\@@_/Catalog/Requirements_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_/Catalog/Requirements_gpush: }
  {
    \seq_if_empty:cF
     { g_@@_/Catalog/Requirements_seq }
     {
       \__pdf_backend_object_new:nn  { g_@@_/Catalog/Requirements_obj } { array }
       \exp_args:Nnx
         \__pdf_backend_object_write:nn
            { g_@@_/Catalog/Requirements_obj }
            { \seq_use:cn { g_@@_/Catalog/Requirements_seq } {~} }
       \exp_args:Nnx
         \__pdf_backend_catalog_gput:nn
           {Requirements}
           {
             \__pdf_backend_object_ref:n { g_@@_/Catalog/Requirements_obj }
           }
     }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \paragraph{Building catalog entries: ViewerPreferences}
% \begin{macro}{\@@_/Catalog/ViewerPreferences_gpush:}
%    \begin{macrocode}
\cs_new_protected:cpn { @@_/Catalog/ViewerPreferences_gpush: }
  {
    \prop_if_empty:cF
     { \@@_name:n { Catalog/ViewerPreferences } }
     {
       \__pdf_backend_object_new:nn  { g_@@_/Catalog/ViewerPreferences_obj } { dict }
       \exp_args:Nnx
         \__pdf_backend_object_write:nn
            { g_@@_/Catalog/ViewerPreferences_obj }
            { \@@_map:n {Catalog/ViewerPreferences } }
       \exp_args:Nnx
         \__pdf_backend_catalog_gput:nn
           {ViewerPreferences}
           {
             \__pdf_backend_object_ref:n {g_@@_/Catalog/ViewerPreferences_obj}
           }
     }
  }
%    \end{macrocode}
% \end{macro}
% % \paragraph{Building catalog entries: Names/EmbeddedFiles}
% The entry should only be added if there are actually embedded files.
% This can be tested by checking the names_seq
% \begin{macro}{\@@_/Catalog/Names/EmbeddedFiles_gpush:}
%    \begin{macrocode}
% !!!!!!!!!!!!!!! how to name this seq????
\seq_new:N \g__pdf_file_tree_name_seq
\cs_new_protected:cpn { @@_/Catalog/Names/EmbeddedFiles_gpush: }
  {
    \seq_if_empty:NF \g__pdf_file_tree_name_seq
      {
        \exp_args:Nx \__pdf_backend_NamesEmbeddedFiles_gpush:n
          {
            \seq_use:Nn \g__pdf_file_tree_name_seq {~}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \subsection{ xform / Properties }
%    \begin{macrocode}
\@@_new:n {xform/Resources/Properties}
%    \end{macrocode}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
