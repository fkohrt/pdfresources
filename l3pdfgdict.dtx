% \iffalse meta-comment
%
%% File: l3pdfgdict.dtx
%
% Copyright (C) 2018-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "(experimental) pdfresources bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/pdfresources
%
% for those people who are interested.
%
%<*driver>
\RequirePackage{expl3}
\documentclass[full]{l3doc}
\providecommand\potentialclash{\noindent\llap{\dbend\ }}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3pdfgdict} package\\ Managing core pdf dictionaries ^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released XXXX-XX-XX}
%
% \maketitle
% \begin{documentation}
%
% \section{\pkg{l3pdfgdict} documentation}
% When creating a pdf a number of objects, dictionaries and entries to
% dictionaries must be created. The \LaTeX{} format currently contains no
% support for theses tasks. It either relies on the binaries to do the job,
% or on external packages using the primitives of the binaries. These
% approach is problematic for two reasons: packages trying to set the same resources
% can clash, and as the primitives differ between the various binaries and backend with
% which \LaTeX{} is used all packages have to write and maintain \enquote{driver} files
% for the various backends.
%
% The commands in this module offer interfaces to this core PDF dictionaries
% They unify a number of primitives like the pdftex
% registers \cs{pdfcatalog}, \cs{pdfpagesattr}, \cs{pdfinfo} and similar commands
% of the other backends  in a backend independant way.
%
% The supported backends are pdflatex, lualatex, (x)dvipdfmx (latex, xelatex)
% and dvips with ps2pdf (not completely yet). dvips with distiller could work too
% but is untested.
%
% That the interfaces are backend independent doesn't mean that the results and even
% the compilation behavior is identical. The backends are too different to allow
% this. Some backends expand arguments e.g. in a \cs{special} while other don't.
% Some backends can insert a resource at the first compilation, while another uses
% the aux-file and a label and so needs at least two.
%
% The dictionaries handled by these module are inserted only
% once in a PDF or only once per page. Examples are the Catalog dictionary,
% the Info dictionary, the page resources. For these dictionaries management by the
% \LaTeX{} kernel is necessary to avoid that packages overwrite settings from
% other packages which would lead to clashes and incompatibilities.
% It is therefor necessary that all packages which want to add content to this
% dictionaries uses the interface provided by this module.
%
% As these dictionaries are so central for the PDF format values to these
% dictionaries are always added globally. Through the interface values
% can be added (and in many cases also removed), but the actually writing of the
% dictionary objects to the PDF are then handled by
% the kernel code at a suitable time.
%
% The names of this core dictionaries follow the names in the PDF reference.
% They all have names starting with an uppercase letter.
%
% The following tabular summarize the core dictionaries and which pdftex primitive they
% replace:
%
% \begin{tabular}{ll}
%  Info                                  & \cs{pdfinfo}           \\
%  Catalog \&  various subdictionaries   & \cs{pdfcatalog}        \\
%  Pages                                 & \cs{pdfpagesattr}      \\
%  Page, ThisPage                        & \cs{pdfpageattr}       \\
%  Page/Resources/ExtGState              & \cs{pdfpageresources}  \\
%  Page/Resources/Shading                & \cs{pdfpageresources}  \\
%  Page/Resources/Pattern                & \cs{pdfpageresources}  \\
%  Page/Resources/ColorSpace             & \cs{pdfpageresources}  \\%
%  \end{tabular}
%
%  There is no \texttt{Page/Resources/Properties} dictionary in the list
%  as this dictionary is not filled directly but
%  managed through side effects when setting BDC-marks.
%  \subsection{User Commands}
%
% \begin{function}[added = 2020-04-06]
%   {\pdfgdict_gput:nnn}
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \Arg{core dictionary} \Arg{name} \Arg{value}\\
%   \end{syntax}
% This function puts \Arg{name} \Arg{value}  globally in an internal
% property lists.
% \Arg{core dictionary} is a symbolic name for a concrete PDF dictionary to
% which the content of these property lists will be written by the PDF
% resource management code.
% \Arg{name} should be a valid PDF Name without
% the starting slash.
% \Arg{value} should be a valid PDF value for this Name in the
% target dictionary.
%
% The PDF resource management code predefines a large number of
% symbolic names for important core dictionaries and will write the stored values
% at the right time to the PDF. The predefined symbolic names are described below.
%
% The code works with all major engines but not necessarily
% in the same way. Most importantly
% \begin{itemize}
% \item The expansion behaviour of the backends can differ. Some backends expand a
% value always fully when writing to the PDF, with other backends command names
% could end as strings in the PDF. So one should neither rely on \Arg{name}
% \Arg{value} to be expanded nor not expanded by the backend commands.
% \item The number of compilations needed can differ between the engines and
% backends. Some engines have to use labels and the aux-file to setup
% the dictionaries and so need at least two compilations to put everything
% in place.
% \end{itemize}
% \end{function}
% \begin{function}[added = 2020-04-08]
%   {\pdfgdict_show:n }
%   \begin{syntax}
%     \cs{pdfgdict_show:n}  \Arg{dictionary}
%   \end{syntax}
%   This shows the content of \Arg{dictionary} in the log and on the terminal.
%   It doesn't show the special catalog dictionaries with arrays as values
%   as these are filled only at the end of the document. It is not reliable for
%   page resources as these are filled at shipout.
%\end{function}
% \begin{function}[added = 2020-04-07]
%   {
%     \pdfgdict_gremove:nn,
%   }
%   \begin{syntax}
%     \cs{pdfgdict_gremove:nn} \Arg{global dictionary} \Arg{name}
%   \end{syntax}
%   Removes  |/|\meta{name} and its associated \meta{value} from the \Arg{dictionary}
%   The removal is global.
%   If \meta{name} is not found no change occurs,
%   \emph{i.e}~there is no need to test for the existence of a name before
%   trying to remove it.
%   Values from the special Catalog entries with arrays as values can not be
%   removed.
% \end{function}
% \subsection{The core dictionaries}
% \subsubsection{The Info dictionary}
% \potentialclash If the primitive commands of the engines are used too there will
% be double entries in the pdf (at least with the backend pdftex and luatex).
% How pdf viewer handles this is unpredictable.
%
%  \begin{function}
%   {
%     pdfgdict: Info
%   }
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \{Info\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Adds |/|\meta{name} and the \meta{value} to the Info dictionary.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value. Any escaping or (re)encoding must be
%   done explicitly.
%   If a \meta{name} is used twice, only the last \meta{value}
%   set will be used. The info dictionary is written at the end of the compilation,
%   so values can be set at any time.
%   The info dictionary expects utf16be in the strings, so a conversion like this is
%   normally sensible:
%   \begin{verbatim}
%   \sys_if_engine_pdftex:TF
%    {
%     \str_set_convert:Nnnn \l_tmpa_str { Grüße }{ utf8 } {utf16/string}
%    }
%    {
%     \str_set_convert:Nnnn \l_tmpa_str { Grüße }{  } {utf16/string}
%    }
%   \pdfgdict_gput:nnx {Info} {Title}{(\l_tmpa_str)}
%   \end{verbatim}
% \end{function}
%
% \subsubsection{The \enquote{Pages} dictionary}
% \potentialclash As the content of this dictionary is written at the end it will
% in pdftex and luatex overwrite values added with the primitive commands (e.g.
% \cs{pdfpagesattr}.
% Package authors should use the management commands instead.

% The content of the property list associated with this dictionary name
% is written to the /Pages object. This replaces for example \cs{pdfpagesattr}.
%
% \begin{function}{pdfgdict: Pages}
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \{Pages\} \Arg{name} \Arg{value}
%   \end{syntax}
%
%   Adds |/|\meta{name} \meta{value} to the |/Pages| dictionary.
%   It is always stored globally. The content is written to the pdf
%   at the end of the compilation, so values can be added, changed or
%   removed until then.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value. Any escaping or (re)encoding must
%   be done explicitly. Some backends expand the value but this should not be
%   relied on. If a \meta{name} is used twice, only the last \meta{value}
%   set will be used.
%
% \end{function}
%
% \subsubsection{\enquote{Page} and \enquote{ThisPage}}
% \begin{function}[added = 2020-04-12]
%   {pdfgdict: Page}
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \{Page\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Values added to the dictionary \texttt{Page} are added to the page dictionary
%   of the current page and the following pages. The current page means the page
%   on which the command is \emph{executed}. \meta{name} should be a valid pdf name
%   without the leading slash. Typical names used here are e.g.
%   \texttt{Rotate} and \texttt{CropBox}.
%   \meta{value} should be a valid pdf value.
%   Any escaping or (re)encoding must be done explicitly. Some backends expand the
%   value but this should not be relied on.
%   To avoid problems with the asynchronous page breaking
%   the command should be used after \cs{newpage}, or in the header,
%   and better not in a float.
%   The value is assigned directly and is always stored globally.
%   If a \meta{name} is used twice, only the last \meta{value}
%   set will be used. Names set with \cs{pdfgdict_gput:nnn}|{ThisPage}| will overwrite
%   names set with \cs{pdfgdict_gput:nnn}|{Page}| if there is a clash.
%   Values can be removed again with \cs{pdfgdict_gremove:nn}
% \end{function}
% \begin{function}[added = 2020-04-12]
%   { pdfgdict: ThisPage}
%   \begin{syntax}
%     \cs{pdfgdict_gput:nnn} \{ThisPage\} \Arg{name} \Arg{value}
%   \end{syntax}
%   Adds |/|\meta{name} \meta{value} at \emph{shipout} to the page dictionary of the
%   current page. Current page means here the \emph{shipout} page.
%   It is always stored globally.
%   If \Arg{name} has already a value set in the \texttt{Page}
%   dictionary it will be overwritte for this page.
%   \meta{name} should be a valid pdf name without the leading slash,
%   \meta{value} should be a valid pdf value. Any escaping or (re)encoding must be
%   done explicitly. If a \meta{name} is used twice, only the last \meta{value}
%   set will be used.
%   With the engine pdflatex (at least) a second compilation is needed.
%   Values added to \texttt{ThisPage} can not be removed. It is not possible to
%   show the content of this dictionary with \cs{pdfgdict_show:n}.
% \end{function}
% \end{documentation}
%
% \begin{implementation}
%  \section{\pkg{l3pdfgdict} implementation}
%    \begin{macrocode}
%<@@=pdfgdict>
%<*package>
%
\ProvidesExplPackage {l3pdfgdict} {2020-04-08} {0.5}
  {Managing global and local dictionaries}
%    \end{macrocode}
% \subsection{Messages}
%    \begin{macrocode}
\msg_new:nnn  { pdfgdict } { unknown-dict }
              { The~dictionary~'#1'~is~not~declared. }

\msg_new:nnn  { pdfgdict } { empty-value }
              { The~value~for~#1~is~empty~and~will~be~ignored }

\msg_new:nnn  { pdfgdict } { no-removal }
              { It~is~not~possible~to~remove~values~from~dictionary~'#1'.}

\msg_new:nnn  { pdfgdict } { no-show }
              { It~is~not~possible~to~show~the~dictionary~'#1'.}

\msg_new:nnn  { pdfgdict } { show-dict }
  {
    The~dictionary~'#1'~
    \tl_if_empty:nTF {#2}
      { is~empty \\>~ . }
      { contains~the~pairs~(without~outer~braces): #2 . }
  }
\msg_new:nnn  { pdfgdict } { dict-already-defined  }
  {
    The~dictionary~'#1'~is~already~defined.
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfgdict_gput:nnn #1 #2 #3
  {
    \@@_if_global:nTF { #1 }
      {
        \@@_handler_gput:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \msg_error:nnn{pdfgdict}{unknown-dict}{#1}
      }
  }

\cs_generate_variant:Nn \pdfgdict_gput:nnn {nnx}
%    \end{macrocode}
% \subsection{Internal dictionary Code}
%  Many code parts are quite similar: property lists for
%  dictionaries are filled and output.
%  So we define some generic commands to ensure systematic
%  internal names. The names are based on paths separated by slashed.
%  The first slash is not used in the names.
%
%  Currently the following names are used: ^^A!!!!! check, compare with g_@@_gnames_seq
%  \begin{verbatim}
%  /Info                      %    (\pdfinfo)
%  /Catalog                   %    (\pdfcatalog)
%  /Catalog/AA                %
%  /Catalog/AcroForm
%  /Catalog/OCProperties
%  /Catalog/OutputIntents
%  /Catalog/AcroForm/DR
%  /Catalog/AcroForm/DR/Font
%  /Catalog/MarkInfo
%  /Catalog/ViewerPreferences
%  /Pages                     %    (\pagesattr)
%  /Page                      %    (\pageattr)
%  /ThisPage                  %    (\pageattr)
%  /backend_PageN/Resources/Properties %
%  /Page/Resources/ExtGState
%  /Page/Resources/ColorSpace
%  /Page/Resources/Pattern
%  /Page/Resources/Shading
%  /Page/Resources/Properties
%  /xform/Resources/Properties
%  \end{verbatim}
% \begin{macro}{\@@_item:nn,\@@_objref_item:nn}
% Commands to output dict entries: The arguments are \meta{name}\meta{value} and
% \meta{name}\meta{object name}, \meta{name} should be a valid pdf name without
% the slash.
% The commands don't check if the arguments are empty or valid. This should be done
% in the pdf layer at the input.
% \begin{NOTE}{UF}
%TODO: check expansion behaviour of \cs{@@_objref_item:nn} in the various uses
%This command could be shared with pdfdict, but is it worth the trouble?
% \end{NOTE}
%    \begin{macrocode}
\cs_new:Npn \@@_item:nn #1 #2 { /#1~#2~ } %name, value
\cs_generate_variant:Nn \@@_item:nn {ne}

\cs_new:Npn \@@_objref_item:nn #1 #2      %name, object name
  {
    /#1~\pdf_object_ref:n { #2 }
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%    \@@_name:n,
%    \@@_new:n,
%    \g_@@_names_seq,
%   }
%    \begin{macrocode}
\seq_new:N \g_@@_names_seq

\cs_new:Npn \@@_name:n #1 % path name without the leading /
  {
    g_@@_/#1_prop
  }

\cs_new_protected:Npn \@@_new:n #1
  {
    \@@_if_exist:nTF { #1 }
      {
        \msg_error:nnx
          { pdfgdict }
          { dict-already-defined }
          { #1}
       }
      {
        \prop_new:c  { \@@_name:n { #1 } }
        \seq_gput_right:Nn \g_@@_names_seq { #1 }
      }
  }

% test existence
\prg_new_conditional:Npnn \@@_if_exist:n #1 { p , T , F , TF }
  {
    \prop_if_exist:cTF
      { \@@_name:n { #1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }

\prg_new_conditional:Npnn \@@_if_empty:n #1 { p , T , F , TF }
  {
    \prop_if_empty:cTF
      { \@@_name:n { #1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{
%                \@@_handler_gput:nnn,
%                \@@_gput:nnn,
%                \@@_get:nnN,
%                \@@_gremove:nn,
%                \@@_show:n
%                }
%  \cs{@@_handler_gput:nnn} is the main command to fill the dictionaries.
%  In simple cases it directly fill the property list, but if a handler exists
%  this is called. It is important to use it only in places where this make sense.
%  \cs{@@_put:nnn} is a simpler variant which only fills the property list.
%
%    \begin{macrocode}

%global
\cs_new_protected:Npn \@@_handler_gput:nnn #1 #2 #3  %#1 path, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfgdict }{ empty-value }{ /#1/#2 }
      }
      {
        \@@_if_exist:nTF { #1 }
          {
            \cs_if_exist:cTF
              { @@_handler/#1/?_gput:nn } %general, name independant handler
              { \use:c {@@_handler/#1/?_gput:nn} {#2} {#3} }
              {
                \cs_if_exist:cTF
                  { @@_handler/#1/#2_gput:n }
                  { \use:c {@@_handler/#1/#2_gput:n} {#3} } %special handler
                  {
                    \use:c { prop_gput:cnn }
                      { \@@_name:n { #1 } }{ #2 } { #3 }
                  }
              }
          }
          {
            \msg_error:nnn { pdfgdict } { unknown-dict } { #1 }
          }
      }
  }


\cs_generate_variant:Nn \@@_handler_gput:nnn {nxx}

\cs_new_protected:Npn \@@_gput:nnn #1 #2 #3  %#1 path, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfgdict }{ empty-value }{ /#1/#2 }
      }
      {
       \@@_if_exist:nTF { #1 }
         {
           \use:c { prop_gput:cnn }
             { \@@_name:n { #1 } }{ #2 } { #3 }
         }
         {
           \msg_error:nnn { pdfgdict } { unknown-dict } { #1 }
         }
      }
  }

\cs_new_protected:Npn \@@_get:nnN  #1 #2 #3 %path,key,macro
  {
    \prop_get:cnN
      { \@@_name:n { #1 } }
      { #2 } #3
  }


\cs_new_protected:Npn \@@_handler_gremove:nn #1 #2 %path,key
  {
    \@@_if_exist:nTF { #1 }
          {
            \cs_if_exist:cTF
              { @@_handler/#1/?_gremove:n } %general, name independant handler
              { \use:c {@@_handler/#1/?_gremove:n} {#2} }
              {
                \cs_if_exist:cTF
                  { @@_handler/#1/#2_gremove: }
                  { \use:c {@@_handler/#1/#2_gremove:} } %special handler
                  {
                    \prop_gremove:cn
                      { \@@_name:n { #1 } }{ #2 }
                  }
              }
          }
          {
            \msg_error:nnn { pdfgdict } { unknown-dict } { #1 }
          }
  }

\cs_new_protected:Npn \@@_gremove:nn #1 #2 %path,key
  {
    \@@_if_exist:nTF { #1 }
          {
            \prop_gremove:cn
              { \@@_name:n { #1 } }{ #2 }
          }
          {
            \msg_error:nnn { pdfgdict } { unknown-dict } { #1 }
          }
  }


\cs_new_protected:Npn \@@_show:Nn #1#2
  {
    \cs_if_exist:cTF
      { @@_handler/#2/?_show: } %general, name independant handler
      { \use:c {@@_handler/#2/?_show:} }
      {
        \prop_if_exist:cTF { \@@_name:n { #2 } }
          {
             #1
               { pdfgdict } { show-dict }
               { \tl_to_str:n {#2} }
               { \prop_map_function:cN {\@@_name:n { #2 }} \msg_show_item:nn }
               { } { }
          }
          {
            #1 { pdfgdict } { unknown-dict } {#2}{}{}{}
          }
       }
  }

\cs_new_protected:Npn \@@_show:n #1  %path
  {
    \prop_show:c { \@@_name:n { #1 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_map:n }
% \cs{@@_map:n} outputs a prop as needed in a dictionary:
%  as a list of /\meta{key} \meta{value} pairs.
%    \begin{macrocode}
% !! is e-expansion the right thing?
\cs_new:Npn \@@_map:n #1 %path
  {
    \prop_map_function:cN { \@@_name:n { #1 } } \@@_item:ne
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_gmerge:nnN }
% \cs{@@_gmerge:nnN} merges at first the property \meta{name_1}
%  then optionally \meta{name_2} into property |#3|.
%    \begin{macrocode}

\cs_new_protected:Npn \@@_gmerge:nnN #1 #2 #3
  {
    \prop_gset_eq:Nc #3 { \@@_name:n  { #1 } }
    \prop_if_exist:cT  { \@@_name:n  { #2 } }
      {
        \prop_map_inline:cn { \@@_name:n  { #2 } }
          {
            \prop_gput:Nnn #3 { ##1 }{ ##2 }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfgdict_show:n
  {
    \@@_show:Nn \msg_show:nnxxxx {#1}
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfgdict_gremove:nn #1 #2
  {
    \@@_if_exist:nTF { #1 }
      {
        \@@_handler_gremove:nn { #1 }{ #2 }
      }
      {
        \msg_error:nnn{pdfgdict}{unknown-dict}{#1}
      }
  }
%    \end{macrocode}
% \subsection{The Info dictionary}
% Initialization of the dictionary:
%    \begin{macrocode}
\@@_new:n {Info}
%    \end{macrocode}
%
% \begin{macro}{\@@_Info_gpush:}
% \cs{@@_dict_Info_gpush:} is the command that outputs the info dictionary (currently
% in the end-of-run hooks).
%    \begin{macrocode}
% push to the register command / issue the special
\cs_new_protected:Npn \@@_dict_Info_gpush:
  {
    \prop_map_function:cN  { \@@_dict_gname:n {Info} } \@@_backend_info_gput:nn
    \prop_gclear:c { \@@_dict_gname:n {Info} }
  }
%    \end{macrocode}
% \end{macro}
% \subsection{The Pages dictionary code}
% At first the initialisation
%     \begin{macrocode}
\@@_new:n {Pages}
%    \end{macrocode}
%
% \begin{macro}{\@@_Pages_gpush:}
% This is the command that outputs the Pages dictionary. It is used
% at the end of the document in \cs{g__pdf_backend_end_run_tl}
%    \begin{macrocode}
% push to the register command / issue the special
\cs_new_protected:Npn \@@_Pages_gpush:
  {
    \exp_args:Nx \__pdf_backend_Pages_primitive:n
      {
        \@@_map:n {Pages}
      }
  }

%    \end{macrocode}
% \end{macro}
% \subsection{The Page and ThisPage dictionary}
% At first the initialisation.
%    \begin{macrocode}
\@@_new:n { Page }
\@@_new:n { ThisPage }

%handler for pdfgdict
\cs_new_protected:cpn { @@_handler/Page/?_gput:nn } #1 #2
  {
    \@@_backend_Page_gput:nn { #1 }{ #2 }
  }
% remove:
\cs_new_protected:cpn { @@_handler/Page/?_gremove:n } #1
  {
    \@@_backend_Page_gremove:n { #1 }
  }

% handler for pdfgdict
\cs_new_protected:cpn { @@_handler/ThisPage/?_gput:nn } #1 #2
  {
    \prop_gput:cnn  { \@@_name:n { ThisPage } }{ #1 } { #2 }
    \@@_backend_ThisPage_gput:nn { #1 }{ #2 }
  }

\cs_new_protected:cpn { @@_handler/ThisPage/?_gremove:n } #1
  {
    \msg_warning:nnn { pdfgdict } { no-removal }{ThisPage}
  }

\cs_new_protected:cpn { @@_handler/ThisPage/?_show: }
  {
    \msg_warning:nnn { pdfgdict } { no-show }{ThisPage}
  }

%    \end{macrocode}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
