% \iffalse meta-comment
%
%% File: l3pdfdict.dtx
%
% Copyright (C) 2018-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "(experimental) pdfmanagement bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/pdfresources
%
% for those people who are interested.
%
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
% \title{^^A
%   The \pkg{l3pdfdict} package  -- tools for PDF dictionaries ^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released XXXX-XX-XX}
%
% \maketitle
% \begin{documentation}
%
% \section{\pkg{l3pdfdict} documentation}
% Many PDF objects are or contain dictionaries -- structures
% containing a number of \mbox{(pdf-)}Name/value pairs.
% Examples are attributes of links,
% filespec dictionaries, xform dictionaries, the catalog, the info dictionary.
% The commands in this module offer an number of
% tools to handle such dictionaries. The module setups a namespace for the
% dictionary names and offers some commands to output dictionaries.
%
% The dictionaries are implemented with property lists. The keys are always
% converted with \cs{str_convert_pdfname} to get a correct PDF name, and empty
% values will be ignored.
%
% Local and global dictionaries can be created and for a number of commands both
% a local and a global version exists.

% \subsection{User Commands}
% \begin{function}[updated = 2020-07-06]
%   {\pdfdict_new:nn}
%   \begin{syntax}
%     \cs{pdfdict_new:nn} \Arg{type prefix}  \Arg{dictionary name}\\
%   \end{syntax}
% \begin{NOTE}{UF}
% perhaps the type prefix will be extended to |g_module| at some time.
% Leaving this open for now
% \end{NOTE}
% This function create a new local or global dictionary. \Arg{type prefix} should
% be either \texttt{l} for a local or \texttt{g} for a global dictionary.
% The commands are only small wrappers around \cs{prop_new:c}, but use a special name space.
% It is possible to create a local and a global with the same name, but it is
% recommended to use lowercase for global and uppercase for global dictionaries.
% \end{function}
% \begin{function}[added = 2020-06-16]
%   {\pdfdict_set_eq:nn,\pdfdict_gset_eq:nn}
%   \begin{syntax}
%     \cs{pdfdict_set_eq:nn}  \Arg{local dictionary name_1} \Arg{local dictionary name_2}\\
%     \cs{pdfdict_gset_eq:nn} \Arg{global dictionary name_1}\Arg{global dictionary name_2}
%   \end{syntax}
% This functions copy \Arg{local/global dictionary name_2} into
% \Arg{local/global dictionary name_1} locally or globally. If the
% dictionary \Arg{local/global dictionary name_1} doesn't exist yet, it will be created.
% If \Arg{local/global dictionary name_2} doesn't exist yet, an error will be raised.
%
% \end{function}
% \begin{function}[EXP,updated = 2020-07-06]
%   {\pdfdict_name:nn}
%   \begin{syntax}
%     \cs{pdfdict_name:n} \Arg{type prefix} \Arg{dictionary name}\\
%   \end{syntax}
% These command expand to the internal name. With these commands
% it is possible to use standard commands of the \texttt{prop} module
% to deal with the dictionaries. For example\\
% |\prop_clear:c { \pdfdict_name:nn {l} { name }}|
% \end{function}
% \begin{function}[added = 2020-04-06]
%   {\pdfdict_put:nnn, \pdfdict_gput:nnn}
%   \begin{syntax}
%     \cs{pdfdict_put:nnn}  \Arg{local dictionary}  \Arg{name} \Arg{value} \\
%     \cs{pdfdict_gput:nnn} \Arg{global dictionary} \Arg{name} \Arg{value}
%   \end{syntax}
% This function puts \Arg{name} \Arg{value} locally or globally in the
% \Arg{dictionary} created with \cs{pdfdict_new:nn}.
% \Arg{name} should be a PDF Name without the starting slash. It will be stored
% with \cs{str_convert_pdfname}, so will be automatically correctly escaped in case
% it contains slashes, spaces or other chars not allowed in a PDF name.
% \Arg{value} should be a valid PDF value for this name in the
% target dictionary. The value is \emph{not} converted nor escaped automatically.
% If the value is blank nothing is added to the dictionary.
%
% When adding a value keep in mind that the expansion behaviour
% of the backends can differ. Some backends expand a
% value always fully when writing to the PDF, with other backends commands
% could end as strings in the PDF. So one should neither rely on
% \Arg{value} to be expanded nor not expanded by the backend commands.
% \end{function}
% \begin{function}[EXP,added = 2020-04-21]
%   {\pdfdict_use:nn  }
%   \begin{syntax}
%     \cs{pdfdict_use:nn}  \Arg{type prefix} \Arg{local dictionary}\\
%   \end{syntax}
%   This outputs the property list of the dictionary as a list of
%   \texttt{/key value} pairs.
%   This can be used e.g. when writing a dictionary object with
%   \cs{pdf_object_write:nx}
% \end{function}
% \begin{function}[added = 2020-04-08]
%   {\pdfdict_show:n }
%   \begin{syntax}
%     \cs{pdfdict_show:n}  \Arg{dictionary}
%   \end{syntax}
%   This shows the content of \Arg{dictionary} in the log and on the terminal.
%   If both a local and a global dictionary with the name \Arg{dictionary}
%   exists it will show both.
%\end{function}
%\begin{function}[EXP, pTF,updated = 2020-07-06]
%   { \pdfdict_if_exist:nn  }
%   \begin{syntax}
%     \cs{pdfdict_if_exist:n} \Arg{type prefix}  \Arg{dictionary}\\
%   \end{syntax}
%   This tests if the dictionary exists.
% \end{function}
% \begin{function}[EXP, pTF,updated = 2020-07-06]
%   { \pdfdict_if_empty:nn }
%   \begin{syntax}
%     \cs{pdfdict_if_empty:nn}  \Arg{type prefix} \Arg{dictionary}\\
%   \end{syntax}
%   This tests if the dictionary is empty. The result is false if the
%   dictionary doesn't exist.
% \end{function}
% \begin{function}[added = 2020-07-06]
%   {\pdfdict_get:nnnN }
%   \begin{syntax}
%     \cs{pdfdict_get:nnnN} \Arg{type prefix} \Arg{dictionary}  \Arg{name} \meta{tl var}\\
%   \end{syntax}
%   Recovers the \meta{value} stored by \cs{pdfdict_put:nnn} or
%   \cs{pdfdict_gput:nnn}
%   for \meta{name} and places this in the \meta{token list
%   variable}. If \meta{name} is not found
%   then the \meta{token list variable} is set
%   to the special marker \cs{q_no_value}. \meta{name} is first converted
%   with \cs{str_convert_pdfname}.  The \meta{token list
%   variable} is set within the current \TeX{} group.
% \end{function}
% \begin{function}[added = 2020-04-07]
%   {
%     \pdfdict_remove:nn, \pdfdict_gremove:nn
%   }
%   \begin{syntax}
%     \cs{pdfdict_remove:nn}  \Arg{local dictionary}  \Arg{name}\\
%     \cs{pdfdict_gremove:nn} \Arg{global dictionary} \Arg{name}
%   \end{syntax}
%   Removes  |/|\meta{name} and its associated \meta{value} from
%   the \Arg{dictionary}
%   The removal is local from local dictionaries
%   and global from global dictionaries.
%   If \meta{name} is not found no change occurs,
%   \emph{i.e}~there is no need to test for the existence of a name before
%   trying to remove it. \Arg{name} is first converted
%   with \cs{str_convert_pdfname}.
% \end{function}
% \subsection{Predeclared dictionaries}
% The module predeclares a number of local dictionaries and fills them with
% some standard values. Some are not more than templates. But others are used
% in core commands and can be used to change their settings.
% For example an link created with \cs{pdfannot_link:nnn}
% will use the \texttt{annot/Link/URI} dictionary. By adding or changing entries
% in this dictionary user or packages can for example adapt the border color or
% add keys needed for ocg layers.
%
%
% The following tabular summarize the predeclared dictionaries.
% \begin{NOTE}{UF}
% Check which (local) dictionaries should be predefined.
% Check also if the reset idea makes sense. (Removed for now)
% \end{NOTE}
%
% \medskip
% \noindent
% \begin{tabular}{p{\dimexpr0.25\textwidth-6\tabcolsep}p{0.25\textwidth}>{\raggedright}p{0.5\textwidth}}
%  name      & default keys & notes \tabularnewline\hline
%  annot/Link/Goto   &F (Flag)& used in GoTo links (internal references) \tabularnewline
%  annot/Link/URI    &F (Flag)& used in URI links (external uri references) \tabularnewline
%  annot/Link/GotoR  &F (Flag)& used in GoToR links (file  references) \tabularnewline
%  annot/Link/Named  &F (Flag)& used in Named actions (menu calls) \tabularnewline
%  annot/Link/Launch &F (Flag)& used in Launch links (application calls) \tabularnewline
%  page/Trans& /Type /Trans & for transitions dictionaries. Other keys:
%                   /S (name), /D integer, /Dm (name),
%                   /M (name), /SS number /B boolean.
%  \end{tabular}

% \end{documentation}
%
% \begin{implementation}
% \section{\pkg{l3pdfdict} implementation}
%    \begin{macrocode}
%<@@=pdfdict>
%<*package>
\ProvidesExplPackage {l3pdfdict} {2020-04-08} {0.5}
  {Tools for PDF dictionaries}
%</package>
%    \end{macrocode}
% \subsection{messages}
%    \begin{macrocode}
%<*package>
\msg_new:nnn  { pdfdict } { show-dict }
  { %#1: name of the dictionary
    %#2: expanded content
    %#3: "local" or "global"
    The~#3~dictionary~'#1'~
    \tl_if_empty:nTF {#2}
      { is~empty \\>~ . }
      { contains~the~pairs~(without~outer~braces): #2 . }
  }
\msg_new:nnn  { pdfdict } { unknown-dict }
  {
    The~dictionary~'#1'~is~not~a~declared~#2~dictionary.
  }
\msg_new:nnn  { pdfdict } { dict-already-defined  }
  {
    The~#2~dictionary~'#1'~is~already~defined.
  }
\msg_new:nnn  { pdfdict } { empty-value }
              { The~value~#1~for~#2~is~blank~and~will~be~ignored }


%    \end{macrocode}


% \subsection{Creating dictionaries}
% \begin{variable}
%    {\g_@@_names_seq,\g_@@_gnames_seq}
% Two seq to store the used names for diagnostics.
%    \begin{macrocode}
%<*package>
\seq_new:N \g_@@_lnames_seq
\seq_new:N \g_@@_gnames_seq
%</package>
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}
%   {
%    \@@_name:nn, \pdfdict_name:nn,
%    \@@_new:nn,  \pdfdict_new:nn,
%   }
%
%   This are the commands to create new dictionaries and to access their internal
%   name.
%    \begin{macrocode}
%<*package>
\cs_new:Npn \@@_name:nn #1 #2  % #1 l or g, #2 dictionary name
  {
    #1_@@_/#2_prop
  }
\cs_set_eq:NN \pdfdict_name:nn \@@_name:nn

\cs_new_protected:Npn \@@_new:nn #1 #2
  {
    \@@_if_exist:nnTF { #1 } { #2 }
      {
        \msg_error:nnxx
          { pdfdict }
          { dict-already-defined }
          { \tl_to_str:n {#1}}
          { #1-type }
       }
       {
         \prop_new:c  { \@@_name:nn { #1 } { #2 } }
         \seq_if_exist:cT {g_@@_#1names_seq}
           {
            \seq_gput_right:cn {g_@@_#1names_seq} { #2 }
           }
       }
  }

\cs_set_eq:NN \pdfdict_new:nn \@@_new:nn

%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \@@_set_eq:nn,\pdfdict_set_eq:nn,
%     \@@_gset_eq:nn,\pdfdict_gset_eq:nn
%   }
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \@@_set_eq:nn #1 #2
  {
    \@@_if_exist:nnTF { l } { #2 }
      {
        \@@_if_exist:nnF { l } { #1 }
          {
            \@@_new:nn { l } { #1 }
          }
        \prop_set_eq:cc { \@@_name:nn { l } {#1} }{ \@@_name:nn { l } {#2} }
      }
      {
         \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } { local }
      }
  }

\cs_set_eq:NN \pdfdict_set_eq:nn \@@_set_eq:nn

\cs_new_protected:Npn \@@_gset_eq:nn #1 #2
  {
    \@@_if_exist:nnTF { g } { #2 }
      {
        \@@_if_exist:nnF { g } { #1 }
          {
            \@@_new:nn { g } { #1 }
          }
        \prop_set_eq:cc { \@@_name:nn { g } {#1} }{ \@@_name:nn { g } {#2} }
      }
      {
         \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } { global }
      }
  }

\cs_set_eq:NN \pdfdict_gset_eq:nn \@@_gset_eq:nn
%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \@@_if_exist:nn,  \pdfdict_if_exist:nn,
%   }
%
% Existence tests.
%    \begin{macrocode}
%<*package>
%local
\prg_new_conditional:Npnn \@@_if_exist:nn #1 #2 { p , T , F , TF }
  {
    \prop_if_exist:cTF
      { \@@_name:nn { #1 } { #2 }  }
      { \prg_return_true:  }
      { \prg_return_false: }
  }
\prg_set_eq_conditional:NNn
  \pdfdict_if_exist:nn \@@_if_exist:nn { p , T , F , TF }

%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \@@_if_empty:nn,  \pdfdict_if_empty:nn,
%   }
%
% Tests for emptiness.
%    \begin{macrocode}
%<*package>
\prg_new_conditional:Npnn \@@_if_empty:nn #1 #2 { p , T , F , TF }
  {
    \prop_if_empty:cTF
      { \@@_name:nn { #1 } { #2 }  }
      { \prg_return_true:  }
      { \prg_return_false: }
  }

\prg_set_eq_conditional:NNn
  \pdfdict_if_empty:nn \@@_if_empty:nn { p , T , F , TF }

%</package>
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}
%   {
%     \@@_put:nnn, \pdfdict_put:nnn,
%     \@@_gput:nnn,\pdfdict_gput:nnn
%   }
% These are the commands to store values into the dictionaries.
% The main difference to adding values to a normal property list is,
% that the keys are converted with \cs{str_convert_pdfname:n}
% and that empty values are ignored.
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \@@_put:nnn #1 #2 #3  %#1 (local) dict, #2 name, #3 value
  {
    \tl_if_blank:nTF { #3 }
      {
        \msg_none:nnnn { pdfdict }{ empty-value }{ #2 } { #1 }
      }
      {
        \@@_if_exist:nnTF { l } { #1 }
          {
            \exp_args:Nnx \prop_put:cnn
              { \@@_name:nn { l } { #1 } }{ \str_convert_pdfname:n { #2 } } { #3 }
          }
          {
            \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } { local }
          }
      }
  }


\cs_set_eq:NN \pdfdict_put:nnn \@@_put:nnn
\cs_generate_variant:Nn \pdfdict_put:nnn {nnx,nno}

\cs_new_protected:Npn \@@_gput:nnn #1 #2 #3  %#1 global dict, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfdict }{ empty-value }{ #2 } { #1 }
      }
      {
        \@@_if_exist:nnTF { g } { #1 }
          {
            \exp_args:Nnx \prop_gput:cnn
              { \@@_name:nn { g }{ #1 } }{ \str_convert_pdfname:n { #2 } } { #3 }
          }
          {
            \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } { global }
          }
      }
  }

\cs_set_eq:NN \pdfdict_gput:nnn \@@_gput:nnn
\cs_generate_variant:Nn \pdfdict_gput:nnn {nnx,nno}
%</package>
%    \end{macrocode}
% \end{macro}

% \begin{macro}
%   {
%     \@@_get:nnnN, \pdfdict_get:nnnN,
%   }
% Recover the values. The name must be first escaped to match the stored name.
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \@@_get:nnnN  #1 #2 #3 #4 %type,dict,key,macro
  {
    \@@_if_exist:nnTF { #1 } { #2 }
      {
        \exp_args:Nnx \prop_get:cnN
          { \@@_name:nn { #1 } { #2 }}
          { \str_convert_pdfname:n { #3 } } #4
      }
      {
        \msg_error:nnnn { pdfdict } { unknown-dict } { #2 } { #1-type }
      }
  }

\cs_set_eq:NN \pdfdict_get:nnnN \@@_get:nnnN

%</package>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_remove:nn, \pdfdict_remove:nn,
%     \@@_gremove:nn,\pdfdict_gremove:nn
%   }
% This removes a name/value pair from a dictionary.
% The name has to be passed through the escaping.
%    \begin{macrocode}
%<*package>

\cs_new_protected:Npn \@@_remove:nn #1 #2 %dict,name
  {
    \@@_if_exist:nnTF { l } { #1 }
      {
        \exp_args:Nnx \prop_remove:cn
          { \@@_name:nn { l } { #1 } }{ \str_convert_pdfname:n { #2 } }
      }
      {
        \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } {local}
      }
  }
\cs_set_eq:NN \pdfdict_remove:nn \@@_remove:nn

\cs_new_protected:Npn \@@_gremove:nn #1 #2 %dict,name
  {
    \@@_if_exist:nnTF { g } { #1 }
       {
         \exp_args:Nnx \prop_gremove:cn
           { \@@_name:nn { g } { #1 } }{ \str_convert_pdfname:n { #2 } }
       }
       {
         \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } {global}
       }
  }

\cs_set_eq:NN \pdfdict_gremove:nn \@@_gremove:nn
%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   { \@@_show:Nn, \pdfdict_show:n }
% This allows to show the content of dictionaries. It also displays if a
% dictionary is local or global. If both exists both are shown.
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \@@_show:Nn #1#2 %#1 message command, #2 dict
  {
    \prop_if_exist:cT { \@@_name:nn { l } { #2 } }
       {
         #1
            { pdfdict }
            { show-dict }
            { \tl_to_str:n {#2} }
            { \prop_map_function:cN {\@@_name:nn { l } { #2 }} \msg_show_item:nn }
            { local }
            { }
       }
    \prop_if_exist:cT { \@@_name:nn { g } { #2 } }
       {
         #1
            { pdfdict }
            { show-dict }
            { \tl_to_str:n {#2} }
            { \prop_map_function:cN {\@@_name:nn { g } { #2 }} \msg_show_item:nn }
            { global }
            { }
       }
    \bool_if:nF {\prop_if_exist_p:c {\@@_name:nn { g } { #2 }} || \prop_if_exist_p:c {\@@_name:nn { l } { #2 }} }
       {
         #1 { pdfdict } { unknown-dict } { #2 } { global~or~local }{}{}
       }
  }
\cs_new_protected:Npn \pdfdict_show:n #1
  {
    \@@_show:Nn \msg_show:nnxxxx {#1}
  }
%</package>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_use:nn
%   }
% \cs{@@_use:nn} outputs a prop as needed in a dictionary:
%  as a list of /\meta{key} \meta{value} pairs.
% \begin{NOTE}{UF}
%  !! is e-expansion the right thing?
% \end{NOTE}
%    \begin{macrocode}
%<*package>
\cs_new:Npn \@@_use:nn #1 #2  %#1 type, #2 dict
  {
    \prop_map_function:cN { \@@_name:nn { #1 } { #2 } } \__pdf_dict_item:ne
  }

\cs_set_eq:NN \pdfdict_use:nn \@@_use:nn

%</package>
%    \end{macrocode}
% \end{macro}
%
% \subsection{Predeclared dictionaries}
% \begin{variable}{page/Trans}
%     \begin{macrocode}
%<*package>
\pdfdict_new:nn  { l } {page/Trans}
\pdfdict_put:nnn {page/Trans}{Type}{/Trans}
% keys: /S (name), /D integer, /Dm (name), /M (name), /SS number /B boolean.
% decribes transition *to* the page.
%</package>
%    \end{macrocode}
% \end{variable}

% \end{implementation}
%
% \PrintIndex
