% \iffalse meta-comment
%
%% File: l3pdfdict.dtx
%
% Copyright (C) 2018-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "(experimental) pdfresources bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/pdfresources
%
% for those people who are interested.
%
%<*driver>
\RequirePackage{expl3}
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   The \pkg{l3pdfdict} package\\ Managing local dictionaries ^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released XXXX-XX-XX}
%
% \maketitle
% \begin{documentation}
%
% \section{\pkg{l3pdfdict} documentation}
% Many features of a PDF are set by adding a (pdf-)Name and a value
% to specific PDF dictionaries. Examples are attributes of links,
% filespec dictionaries, xform dictionaries.
% The commands in this module offer an number of
% tools to handle such dictionaries. The main purpose of the code
% here is to give packages and users a better interface to add or
% change values of such objects.
%
% The dictionaries are implemented with local property lists.
% All assignments are local.
%
% The following tabular summarize the dictionaries
% \begin{tabular}{lll}
%  xform\ldots                           & argument of \cs{pdfxform} &local\\
%  annot\ldots                           & argument of \cs{pdfannot},
%                                          \cs{pdfstartlink} &local\\
%  \end{tabular}

%  \subsection{User Commands}
% \begin{NOTE}{UF}
% local:  lower case: annot/link/URI.
% \end{NOTE}
% \begin{function}[added = 2020-04-21]
%   {\pdfdict_new:n}
%   \begin{syntax}
%     \cs{pdfdict_new:n} \Arg{local dictionary name}
%   \end{syntax}
% This function create a new local dictionary.
% \end{function}
% \begin{function}[added = 2020-04-06]
%   {\pdfdict_put:nnn, \pdfdict_gput:nnn}
%   \begin{syntax}
%     \cs{pdfdict_put:nnn} \Arg{local dictionary} \Arg{name} \Arg{value}
%   \end{syntax}
% This function puts \Arg{name} \Arg{value} locally in an internal
% property lists.
%
% \Arg{dictionary} is a symbolic name for a concrete PDF dictionary to which the
% content of these property lists will be written by the PDF resource management code.
%
% \Arg{name} should be a valid PDF Name without
% the starting slash.
%
% \Arg{value} should be a valid PDF value for this Name in the
% target dictionary.
%
% When adding a value keep in mind that
% \begin{itemize}
% \item the expansion behaviour of the backends can differ. Some backends expand a
% value always fully when writing to the PDF, with other backends command names
% could end as strings in the PDF. So one should neither rely on \Arg{name}
% \Arg{value} to be expanded nor not expanded by the backend commands.
% \end{itemize}
% \end{function}
% \begin{function}[EXP,added = 2020-04-21]
%   {\pdfdict_map:n }
%   \begin{syntax}
%     \cs{pdfdict_map:n}  \Arg{dictionary}
%   \end{syntax}
%   This outputs the property list of the dictionary as a list of
%   \texttt{/key value} pairs.
%   This can be used e.g. when writing a dictionary object with
%   \cs{pdf_object_write:nx}
% \end{function}
% \begin{function}[added = 2020-04-25]
%   {\pdfdict_reset:n }
%   \begin{syntax}
%     \cs{pdfdict_reset:n}  \Arg{(local) dictionary}
%   \end{syntax}
% This resets a dictionary: it clears the entries and then adds eventually
% default values (normally at least the Type entry).
%  \end{function}
%  \begin{function}[added = 2020-04-08]
%   {\pdfdict_show:n }
%   \begin{syntax}
%     \cs{pdfdict_show:n}  \Arg{dictionary}
%   \end{syntax}
%   This shows the content of \Arg{dictionary} in the log and on the terminal.
%\end{function}
%\begin{function}[EXP, pTF,added = 2020-04-08]
%   {\pdfdict_if_exist:n }
%   \begin{syntax}
%     \cs{pdfdict_if_exist:n}  \Arg{dictionary}
%   \end{syntax}
%   This tests if the dictionary exists.
%\end{function}
% \begin{function}[EXP, pTF,added = 2020-04-08]
%   {\pdfdict_if_empty:n }
%   \begin{syntax}
%     \cs{pdfdict_if_empty:n}  \Arg{dictionary}
%   \end{syntax}
%   This tests if the dictionary is empty. The result is false if the
%   dictionary doesn't exist.
%\end{function}
% \begin{function}[added = 2020-04-07]
%   {\pdfdict_get:nn }
%   \begin{syntax}
%     \cs{pdfdict_get:nnN}  \Arg{dictionary} \Arg{name} \meta{tl var}
%   \end{syntax}
%   Recovers the \meta{value} stored by \cs{pdfdict_put:nnn}
%   for \meta{name} and places this in the \meta{token list
%   variable}. If \meta{name} is not found
%   then the \meta{token list variable} is set
%   to the special marker \cs{q_no_value}. The \meta{token list
%   variable} is set within the current \TeX{} group.
%\end{function}
% \begin{function}[added = 2020-04-07]
%   {
%     \pdfdict_remove:nn,
%   }
%   \begin{syntax}
%     \cs{pdfdict_remove:nn} \Arg{dictionary} \Arg{name}\\
%   \end{syntax}
%   Removes  |/|\meta{name} and its associated \meta{value} from
%   the \Arg{dictionary}
%   The removal is local.
%   If \meta{name} is not found no change occurs,
%   \emph{i.e}~there is no need to test for the existence of a name before
%   trying to remove it.
% \end{function}
% \end{documentation}
%
% \begin{implementation}
%<@@=pdfdict>
%<*package>
\ProvidesExplPackage {l3pdfdict} {2020-04-08} {0.5}
  {Managing local dictionaries}
% \section{\pkg{l3pdfdict} implementation}
% \begin{macro}{\pdfdict_new:n}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfdict_new:n #1
  {
    \@@_new:n {#1}
  }
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfdict_put:nnn #1 #2 #3
  {
    \@@_if_exist:nTF { #1 }
      {
        \@@_handler_put:nnn { #1 }{ #2 }{ #3 }
      }
      {
        \msg_error:nnnn{pdfdict}{wrong-or-unknown-dict}{#1}{local}
      }
  }

\cs_generate_variant:Nn \pdfdict_put:nnn {nnx,nno}
%    \end{macrocode}
% \subsection{Internal dictionary Code}
%  Many code parts are quite similar: property lists for
%  dictionaries are filled and output.
%  So we define some generic commands to ensure systematic
%  internal names. The names are based on paths separated by slashed.
%  The first slash is not used in the names.

% \begin{macro}{\@@_item:nn,\@@_objref_item:nn}
% Commands to output dict entries: The arguments are \meta{name}\meta{value} and
% \meta{name}\meta{object name}, \meta{name} should be a valid pdf name without
% the slash.
% The commands don't check if the arguments are empty or valid. This should be done
% in the pdf layer at the input.
% \begin{NOTE}{UF}
%TODO: check expansion behaviour of \cs{@@_dict_objref_item:nn} in the various uses
%TODO: this should perhaps be move to the module for "content output"
% \end{NOTE}
%    \begin{macrocode}
\cs_new:Npn \@@_item:nn #1 #2 { /#1~#2~ } %name, value
\cs_generate_variant:Nn \@@_item:nn {ne}

\cs_new:Npn \@@_objref_item:nn #1 #2      %name, object name
  {
    /#1~\pdf_object_ref:n { #2 }
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%    \@@_dict_name:n,
%    \@@_dict_new:n,
%    \g_@@_names_seq
%   }
%    \begin{macrocode}
\seq_new:N \g_@@_names_seq

%local
\cs_new:Npn \@@_dict_name:n #1 % path name without the leading /
  {
    l_@@_/#1_prop
  }


%local
\cs_new_protected:Npn \@@_new:n #1
  {
    \@@_if_exist:nTF { #1 }
      {
        \msg_error:nnx
          { pdfdict }
          { dict-already-defined }
          { #1}
       }
      {
        \prop_new:c  { \@@_name:n { #1 } }
        \seq_gput_right:Nn \g_@@_names_seq { #1 }
      }
  }

% test existence
\prg_new_conditional:Npnn \@@_if_exist:n #1 { p , T , F , TF }
  {
    \prop_if_exist:cTF
      { \@@_name:n { #1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }

\prg_new_conditional:Npnn \@@_if_empty:n #1 { p , T , F , TF }
  {
    \prop_if_empty:cTF
      { \@@_name:n { #1 }}
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{
%                \@@_clear:n,
%                \@@_reset:n,
%                \@@_put:nnn,
%                \@@_get:nnN,
%                \@@_remove:nn,
%                \@@_show:n
%                }
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_clear:n #1
  {
    \@@_if_exist:nT { #1 }
      {
        \prop_clear:c  { \@@_name:n { #1 } }
      }
  }

\cs_new_protected:Npn \@@_reset:n #1
  {
    \@@_if_exist:nT { #1 }
      {
        \prop_clear:c  { \@@_name:n { #1 } }
        \use:c {  @@_#1_reset: }
      }
  }

\cs_new_protected:Npn \@@_put:nnn #1 #2 #3  %#1 path, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfdict }{ empty-value }{ /#1/#2 }
      }
      {
       \@@_if_exist:nTF { #1 }
         {
           \prop_put:cnn
             { \@@_name:n { #1 } }{ #2 } { #3 }
         }
         {
           \msg_error:nnn { pdfdict } { unknown-dict } { /#1 }
         }
      }
  }

\cs_new_protected:Npn \@@_get:nnN  #1 #2 #3 %path,key,macro
  {
    \prop_get:cnN
      { \@@_name:n } { #1 } }
      { #2 } #3
  }


\cs_new_protected:Npn \@@_remove:nn #1 #2 %path,key
  {
    \@@_if_exist:nTF { #1 }
          {
            \prop_remove:cn
              { \@@_name:n { #1 } }{ #2 }
          }
          {
            \msg_error:nnn { pdfdict } { unknown-dict } { /#1 }
          }
  }


\cs_new_protected:Npn \@@_show:Nn #1#2
  {
    \prop_if_exist:cTF { \@@_name:n { #2 } }
       {
         #1
            { pdfdict } { show-dict }
            { \tl_to_str:n {#2} }
            { \prop_map_function:cN {\@@_name:n { #2 }} \msg_show_item:nn }
            { } { }
       }
       {
         #1 { pdfdict } { unknown-dict } {#2}{}{}{}
       }
  }
\cs_new_protected:Npn \@@_show:n #1  %path
  {
    \prop_show:c { \@@_name:n } { #1 } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_map:n }
% \cs{@@_map:n} outputs a prop as needed in a dictionary:
%  as a list of /\meta{key} \meta{value} pairs.
%    \begin{macrocode}
% !! is e-expansion the right thing?
\cs_new:Npn \@@_map:n #1 %path
  {
    \prop_map_function:cN { \@@_name:n { #1 } } \@@_item:ne
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new:Npn \pdfdict_map:n #1
  {
    \@@_map:n { #1 }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \pdfdict_reset:n #1
  {
    \@@_reset:n { #1 }
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfdict_show:n
  {
    \@@_show:Nn \msg_show:nnxxxx {#1}
  }
%    \end{macrocode}
%    \begin{macrocode}
\prg_new_eq_conditional:NNn \pdfdict_if_exist:n \@@_if_exist:n
  { TF , T , F , p }

%    \end{macrocode}
%    \begin{macrocode}
\prg_new_eq_conditional:NNn \pdfdict_if_empty:n \@@_if_empty:n
  { TF , T , F , p }
%    \end{macrocode}
%    \begin{macrocode}

\cs_new_protected:Npn \pdfdict_get:nnN #1 #2 #3
  {
    \@@_get:nnN { #1 }{ #2 } #3
  }

%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \pdfdict_remove:nn #1 #2
  {
    \@@_if_exist:nTF { #1 }
      {
        \prop_remove:cn { \@@_name:n { #1 } }{ #2 }
      }
      {
        \msg_error:nnnn{pdfdict}{wrong-or-unknown-dict}{#1}{local}
      }
  }
%    \end{macrocode}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
