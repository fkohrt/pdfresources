% \iffalse meta-comment
%
%% File: l3pdfdict.dtx
%
% Copyright (C) 2018-2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "(experimental) pdfresources bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/pdfresources
%
% for those people who are interested.
%
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
% \title{^^A
%   The \pkg{l3pdfdict} package  -- tools for PDF dictionaries ^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released XXXX-XX-XX}
%
% \maketitle
% \begin{documentation}
%
% \section{\pkg{l3pdfdict} documentation}
% Many PDF objects are or contain dictionaries -- structures
% containing a number of \mbox{(pdf-)}Name/value pairs.
% Examples are attributes of links,
% filespec dictionaries, xform dictionaries, the catalog, the info dictionary.
% The commands in this module offer an number of
% tools to handle such dictionaries. The module setups a namespace for the
% dictionary names and offers some commands to output dictionaries.
%
% The dictionaries are implemented with property lists. The keys are always
% converted with \cs{str_convert_pdfname} to get a correct PDF name, and empty
% values will be ignored.
%
% Local and global dictionaries can be created and for a number of commands both
% a local and a global version exists.

% \subsection{User Commands}
% \begin{function}[added = 2020-04-21]
%   {\pdfdict_new:n,\pdfdict_gnew:n}
%   \begin{syntax}
%     \cs{pdfdict_new:n}  \Arg{local dictionary name}\\
%     \cs{pdfdict_gnew:n} \Arg{global dictionary name}\\
%   \end{syntax}
% This function create a new local or global dictionary. The commands are only
% small wrappers around \cs{prop_new:c}, but use a special name space.
% It is possible to create a local and a global with the same name, but it is
% recommended to use lowercase for global and uppercase for global dictionaries.
% \end{function}
% \begin{function}[added = 2020-06-16]
%   {\pdfdict_set_eq:nm,\pdfdict_gset_eq:nn}
%   \begin{syntax}
%     \cs{pdfdict_set_eq:nn}  \Arg{local dictionary name_1} \Arg{local dictionary name_2}\\
%     \cs{pdfdict_gset_eq:nn} \Arg{global dictionary name_1}\Arg{global dictionary name_2}
%   \end{syntax}
% This functions copy \Arg{local/global dictionary name_2} into
% \Arg{local/global dictionary name_1} locally or globally. If the
% dictionary \Arg{local/global dictionary name_1} doesn't exist yet, it will be created.
% If \Arg{local/global dictionary name_2} doesn't exist yet, an error will be raised.
%
% \end{function}
% \begin{function}[EXP,added = 2020-06-14]
%   {\pdfdict_name:n,\pdfdict_gname:n}
%   \begin{syntax}
%     \cs{pdfdict_name:n}  \Arg{local dictionary name}\\
%     \cs{pdfdict_gname:n} \Arg{global dictionary name}
%   \end{syntax}
% These command expand to the internal name. With these commands
% it is possible to use standard commands of the \texttt{prop} module
% to deal with the dictionaries. For example\\
% |\prop_clear:c { \pdfdict_name:n { name }}|
% \end{function}
% \begin{function}[added = 2020-04-06]
%   {\pdfdict_put:nnn, \pdfdict_gput:nnn}
%   \begin{syntax}
%     \cs{pdfdict_put:nnn}  \Arg{local dictionary}  \Arg{name} \Arg{value} \\
%     \cs{pdfdict_gput:nnn} \Arg{global dictionary} \Arg{name} \Arg{value}
%   \end{syntax}
% This function puts \Arg{name} \Arg{value} locally or globally in the
% \Arg{dictionary} created with \cs{pdfdict_new:n} or \cs{pdfdict_gnew:n}.
% \Arg{name} should be a PDF Name without the starting slash. It will be stored
% with \cs{str_convert_pdfname}, so will be automatically correctly escaped in case
% it contains slashes, spaces or other chars not allowed in a PDF name.
% \Arg{value} should be a valid PDF value for this name in the
% target dictionary. The value is \emph{not} converted nor escaped automatically.
% If the value is blank nothing is added to the dictionary.
%
% When adding a value keep in mind that the expansion behaviour
% of the backends can differ. Some backends expand a
% value always fully when writing to the PDF, with other backends commands
% could end as strings in the PDF. So one should neither rely on
% \Arg{value} to be expanded nor not expanded by the backend commands.
% \end{function}
% \begin{function}[EXP,added = 2020-04-21]
%   {\pdfdict_map:n , \pdfdict_gmap:n }
%   \begin{syntax}
%     \cs{pdfdict_map:n}   \Arg{local dictionary}\\
%     \cs{pdfdict_gmap:n}  \Arg{global dictionary}
%   \end{syntax}
%   This outputs the property list of the dictionary as a list of
%   \texttt{/key value} pairs.
%   This can be used e.g. when writing a dictionary object with
%   \cs{pdf_object_write:nx}
% \end{function}
% \begin{function}[added = 2020-04-08]
%   {\pdfdict_show:n }
%   \begin{syntax}
%     \cs{pdfdict_show:n}  \Arg{dictionary}
%   \end{syntax}
%   This shows the content of \Arg{dictionary} in the log and on the terminal.
%   If both a local and a global dictionary with the name \Arg{dictionary}
%   exists it will show both.
%\end{function}
%\begin{function}[EXP, pTF,added = 2020-04-08]
%   { \pdfdict_if_exist:n, \pdfdict_if_gexist:n  }
%   \begin{syntax}
%     \cs{pdfdict_if_exist:n}   \Arg{local dictionary}\\
%     \cs{pdfdict_if_gexist:n}  \Arg{global dictionary}
%   \end{syntax}
%   This tests if the dictionary exists.
% \end{function}
% \begin{function}[EXP, pTF,added = 2020-04-08]
%   { \pdfdict_if_empty:n, \pdfdict_if_gempty:n }
%   \begin{syntax}
%     \cs{pdfdict_if_empty:n}  \Arg{local dictionary}\\
%     \cs{pdfdict_if_gempty:n}  \Arg{global dictionary}
%   \end{syntax}
%   This tests if the dictionary is empty. The result is false if the
%   dictionary doesn't exist.
% \end{function}
% \begin{function}[added = 2020-04-07]
%   {\pdfdict_get:nn, \pdfdict_gget:nn  }
%   \begin{syntax}
%     \cs{pdfdict_get:nnN}  \Arg{local dictionary}  \Arg{name} \meta{tl var}\\
%     \cs{pdfdict_gget:nnN} \Arg{global dictionary} \Arg{name} \meta{tl var}
%   \end{syntax}
%   Recovers the \meta{value} stored by \cs{pdfdict_put:nnn} and
%   \cs{pdfdict_gput:nnn}
%   for \meta{name} and places this in the \meta{token list
%   variable}. If \meta{name} is not found
%   then the \meta{token list variable} is set
%   to the special marker \cs{q_no_value}. \meta{name} is first converted
%   with \cs{str_convert_pdfname}.  The \meta{token list
%   variable} is set within the current \TeX{} group.
% \end{function}
% \begin{function}[added = 2020-04-07]
%   {
%     \pdfdict_remove:nn, \pdfdict_gremove:nn
%   }
%   \begin{syntax}
%     \cs{pdfdict_remove:nn}  \Arg{local dictionary}  \Arg{name}\\
%     \cs{pdfdict_gremove:nn} \Arg{global dictionary} \Arg{name}
%   \end{syntax}
%   Removes  |/|\meta{name} and its associated \meta{value} from
%   the \Arg{dictionary}
%   The removal is local from local dictionaries
%   and global from global dictionaries.
%   If \meta{name} is not found no change occurs,
%   \emph{i.e}~there is no need to test for the existence of a name before
%   trying to remove it. \Arg{name} is first converted
%   with \cs{str_convert_pdfname}.
% \end{function}
% \begin{function}[EXP,added = 2020-06-14]
%   {
%     \pdfdict_item:nn, \pdfdict_item:ne, \pdfdict_item:nx,
%   }
%   \begin{syntax}
%     \cs{pdfdict_item:nn} \Arg{name} \Arg{value}
%   \end{syntax}
%   This outputs the arguments as needed in a PDF dictionary by adding a slash
%   before the name and adding a space before the value:
%   |/|\Arg{name}| |\Arg{value}. It doesn't do any conversion or
%   escaping. It does nothing if \Arg{value} is empty.
% \end{function}
% \subsection{Predeclared dictionaries}
% The module predeclares a number of local dictionaries and fills them with
% some standard values. These dictionaries are meant as templates. They can
% be changed and used directly but this should be done only inside
% groups when no other code is involved which tries to change them too.
% The following tabular summarize the predeclared dictionaries.
% \begin{NOTE}{UF}
% Check which (local) dictionaries should be predefined.
% Check also if the reset idea makes sense. (Removed for now)
% \end{NOTE}
%
% \medskip
% \noindent
% \begin{tabular}{p{\dimexpr0.25\textwidth-6\tabcolsep}p{0.25\textwidth}>{\raggedright}p{0.5\textwidth}}
%  name      & default keys & notes \tabularnewline\hline
%  page/Trans& /Type /Trans & for transitions dictionaries. Other keys:
%                   /S (name), /D integer, /Dm (name),
%                   /M (name), /SS number /B boolean.
%  \end{tabular}

% \end{documentation}
%
% \begin{implementation}
% \section{\pkg{l3pdfdict} implementation}
%    \begin{macrocode}
%<@@=pdfdict>
%<*package>
\ProvidesExplPackage {l3pdfdict} {2020-04-08} {0.5}
  {Tools for PDF dictionaries}
%</package>
%    \end{macrocode}
% \subsection{messages}
%    \begin{macrocode}
%<*package>
\msg_new:nnn  { pdfdict } { show-dict }
  { %#1: name of the dictionary
    %#2: expanded content
    %#3: "local" or "global"
    The~#3~dictionary~'#1'~
    \tl_if_empty:nTF {#2}
      { is~empty \\>~ . }
      { contains~the~pairs~(without~outer~braces): #2 . }
  }
\msg_new:nnn  { pdfdict } { unknown-dict }
  {
    The~dictionary~'#1'~is~not~a~declared~#2~dictionary.
  }
\msg_new:nnn  { pdfdict } { dict-already-defined  }
  {
    The~#2~dictionary~'#1'~is~already~defined.
  }
\msg_new:nnn  { pdfdict } { empty-value }
              { The~value~#1~for~#2~is~blank~and~will~be~ignored }


%    \end{macrocode}


% \subsection{Creating dictionaries}
% \begin{variable}
%    {\g_@@_names_seq,\g_@@_gnames_seq}
% Two seq to store the used names for diagnostics.
%    \begin{macrocode}
%<*package>
\seq_new:N \g_@@_names_seq
\seq_new:N \g_@@_gnames_seq
%</package>
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}
%   {
%    \@@_name:n, \pdfdict_name:n,
%    \@@_gname:n,\pdfdict_gname:n,
%    \@@_new:n,  \pdfdict_new:n,
%    \@@_gnew:n, \pdfdict_gnew:n
%   }
%
%   This are the commands to create new dictionaries and to access their internal
%   name.
%    \begin{macrocode}
%<*package>
%local
\cs_new:Npn \@@_name:n #1  % #1 dictionary name
  {
    l_@@_/#1_prop
  }
\cs_set_eq:NN \pdfdict_name:n \@@_name:n

%global
\cs_new:Npn \@@_gname:n #1 % #1 dictionary name
  {
    g_@@_/#1_prop
  }
\cs_set_eq:NN \pdfdict_gname:n \@@_gname:n

%local
\cs_new_protected:Npn \@@_new:n #1
  {
    \@@_if_exist:nTF { #1 }
      {
        \msg_error:nnxx
          { pdfdict }
          { dict-already-defined }
          { \tl_to_str:n {#1}}
          { local }
       }
       {
         \prop_new:c  { \@@_name:n { #1 } }
         \seq_gput_right:Nn \g_@@_names_seq { #1 }
       }
  }

\cs_set_eq:NN \pdfdict_new:n \@@_new:n

%global
\cs_new_protected:Npn \@@_gnew:n #1
  {
    \@@_if_gexist:nTF { #1 }
      {
        \msg_error:nnxx
          { pdfdict }
          { dict-already-defined }
          { \tl_to_str:n {#1}}
          { global }
       }
      {
        \prop_new:c  { \@@_gname:n { #1 } }
        \seq_gput_right:Nn \g_@@_gnames_seq { #1 }
      }
  }
\cs_set_eq:NN \pdfdict_gnew:n \@@_gnew:n
%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \@@_set_eq:nm,\pdfdict_set_eq:nn,
%     \@@_gset_eq:nm,\pdfdict_gset_eq:nn
%   }
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \@@_set_eq:nn #1 #2
  {
    \@@_if_exist:nTF { #2 }
      {
        \@@_if_exist:nF { #1 }
          {
            \@@_new:n { #1 }
          }
        \prop_set_eq:cc { \@@_name:n {#1} }{ \@@_name:n {#2} }
      }
      {
         \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } { local }
      }
  }

\cs_set_eq:NN \pdfdict_set_eq:nn \@@_set_eq:nn

\cs_new_protected:Npn \@@_gset_eq:nn #1 #2
  {
    \@@_if_gexist:nTF { #2 }
      {
        \@@_if_gexist:nF { #1 }
          {
            \@@_gnew:n { #1 }
          }
        \prop_set_eq:cc { \@@_gname:n {#1} }{ \@@_gname:n {#2} }
      }
      {
         \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } { global }
      }
  }

\cs_set_eq:NN \pdfdict_gset_eq:nn \@@_gset_eq:nn
%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \@@_if_exist:n,  \pdfdict_if_exist:n,
%     \@@_if_gexist:n, \pdfdict_if_gexist:n,
%   }
%
% Existence tests.
%    \begin{macrocode}
%<*package>
%local
\prg_new_conditional:Npnn \@@_if_exist:n #1 { p , T , F , TF }
  {
    \prop_if_exist:cTF
      { \@@_name:n { #1 }  }
      { \prg_return_true:  }
      { \prg_return_false: }
  }
\prg_set_eq_conditional:NNn
  \pdfdict_if_exist:n \@@_if_exist:n { p , T , F , TF }

%global
\prg_new_conditional:Npnn \@@_if_gexist:n #1 { p , T , F , TF }
  {
    \prop_if_exist:cTF
      { \@@_gname:n { #1 } }
      { \prg_return_true:  }
      { \prg_return_false: }
  }

\prg_set_eq_conditional:NNn
  \pdfdict_if_gexist:n \@@_if_gexist:n { p , T , F , TF }
%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \@@_if_empty:n,  \pdfdict_if_empty:n,
%     \@@_if_gempty:n, \pdfdict_if_gempty:n,
%   }
%
% Tests for emptiness.
%    \begin{macrocode}
%<*package>
\prg_new_conditional:Npnn \@@_if_empty:n #1 { p , T , F , TF }
  {
    \prop_if_empty:cTF
      { \@@_name:n { #1 }  }
      { \prg_return_true:  }
      { \prg_return_false: }
  }

\prg_set_eq_conditional:NNn
  \pdfdict_if_empty:n \@@_if_empty:n { p , T , F , TF }

\prg_new_conditional:Npnn \@@_if_gempty:n #1 { p , T , F , TF }
  {
    \prop_if_empty:cTF
      { \@@_gname:n { #1 } }
      { \prg_return_true:  }
      { \prg_return_false: }
  }

\prg_set_eq_conditional:NNn
  \pdfdict_if_gempty:n \@@_if_gempty:n { p , T , F , TF }

%</package>
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}
%    {
%      \@@_item:nn,\@@_item:ne,\@@_item:nx,
%      \pdfdict_item:nn, \pdfdict_item:nx, \pdfdict_item:ne
%    }
% Commands to output dict entries: The arguments are \meta{name}\meta{value}.
% \meta{name} should be a valid pdf name without the slash. The commands don't
% do any escaping. (It expects that the name has been escaped then the value
% has been stored into the dictionary).
% The commands don't check if the arguments are valid but if the value
% is blank nothing is output. The commands are expandable if the content is.

%    \begin{macrocode}
%<*package>
\cs_new:Npn \@@_item:nn #1 #2 %#1 name, #2 value
  {
    \tl_if_blank:nF {#2} { /#1~#2~ }
  }
\cs_generate_variant:Nn \@@_item:nn {ne,nx}

\cs_set_eq:NN \pdfdict_item:nn \@@_item:nn
\cs_generate_variant:Nn \pdfdict_item:nn {ne,nx}

%</package>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_put:nnn, \pdfdict_put:nnn,
%     \@@_gput:nnn,\pdfdict_gput:nnn
%   }
% These are the commands to store values into the dictionaries.
% The main difference to adding values to a normal property list is,
% that the keys are converted with \cs{str_convert_pdfname:n}
% and that empty values are ignored.
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \@@_put:nnn #1 #2 #3  %#1 dict, #2 name, #3 value
  {
    \tl_if_blank:nTF { #3 }
      {
        \msg_none:nnnn { pdfdict }{ empty-value }{ #2 } { #1 }
      }
      {
        \@@_if_exist:nTF { #1 }
          {
            \exp_args:Nnx \prop_put:cnn
              { \@@_name:n { #1 } }{ \str_convert_pdfname:n { #2 } } { #3 }
          }
          {
            \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } { local }
          }
      }
  }


\cs_set_eq:NN \pdfdict_put:nnn \@@_put:nnn
\cs_generate_variant:Nn \pdfdict_put:nnn {nnx,nno}

\cs_new_protected:Npn \@@_gput:nnn #1 #2 #3  %#1 dict, #2 name, #3 value
  {
    \tl_if_empty:nTF { #3 }
      {
        \msg_none:nnn { pdfdict }{ empty-value }{ #2 } { #1 }
      }
      {
        \@@_if_gexist:nTF { #1 }
          {
            \exp_args:Nnx \prop_gput:cnn
              { \@@_gname:n { #1 } }{ \str_convert_pdfname:n { #2 } } { #3 }
          }
          {
            \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } { global }
          }
      }
  }

\cs_set_eq:NN \pdfdict_gput:nnn \@@_gput:nnn
\cs_generate_variant:Nn \pdfdict_gput:nnn {nnx,nno}
%</package>
%    \end{macrocode}
% \end{macro}

% \begin{macro}
%   {
%     \@@_get:nnN, \pdfdict_get:nnN,
%     \@@_gget:nnN,\pdfdict_gget:nnN
%   }
% Recover the values. The name must be first escaped to match the stored name.
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \@@_get:nnN  #1 #2 #3 %dict,key,macro
  {
    \@@_if_exist:nTF { #1 }
      {
        \exp_args:Nnx \prop_get:cnN
          { \@@_name:n { #1 } }
          { \str_convert_pdfname:n { #2 } } #3
      }
      {
        \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } { local }
      }
  }

\cs_set_eq:NN \pdfdict_get:nnN \@@_get:nnN

\cs_new_protected:Npn \@@_gget:nnN  #1 #2 #3 %dict,key,macro
  {
    \@@_if_gexist:nTF { #1 }
      {
        \exp_args:Nnx \prop_get:cnN
          { \@@_gname:n { #1 } }
          { \str_convert_pdfname:n { #2 } } #3
      }
      {
        \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } { global }
      }
  }

\cs_set_eq:NN \pdfdict_gget:nnN \@@_gget:nnN

%</package>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_remove:nnN, \pdfdict_remove:nnN,
%     \@@_gremove:nnN,\pdfdict_gremove:nnN
%   }
% This removes a name/value pair from a dictionary.
% The name has to be passed through the escaping.
%    \begin{macrocode}
%<*package>

\cs_new_protected:Npn \@@_remove:nn #1 #2 %dict,name
  {
    \@@_if_exist:nTF { #1 }
      {
        \exp_args:Nnx \prop_remove:cn
          { \@@_name:n { #1 } }{ \str_convert_pdfname:n { #2 } }
      }
      {
        \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } {local}
      }
  }
\cs_set_eq:NN \pdfdict_remove:nn \@@_remove:nn

\cs_new_protected:Npn \@@_gremove:nn #1 #2 %dict,name
  {
    \@@_if_gexist:nTF { #1 }
       {
         \exp_args:Nnx \prop_gremove:cn
           { \@@_gname:n { #1 } }{ \str_convert_pdfname:n { #2 } }
       }
       {
         \msg_error:nnnn { pdfdict } { unknown-dict } { #1 } {global}
       }
  }

\cs_set_eq:NN \pdfdict_gremove:nn \@@_gremove:nn
%</package>
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   { \@@_show:Nn, \pdfdict_show:n }
% This allows to show the content of dictionaries. It also displays if a
% dictionary is local or global. If both exists both are shown.
%    \begin{macrocode}
%<*package>
\cs_new_protected:Npn \@@_show:Nn #1#2 %#1 message command, #2 dict
  {
    \prop_if_exist:cT { \@@_name:n { #2 } }
       {
         #1
            { pdfdict }
            { show-dict }
            { \tl_to_str:n {#2} }
            { \prop_map_function:cN {\@@_name:n { #2 }} \msg_show_item:nn }
            { local }
            { }
       }
    \prop_if_exist:cT { \@@_gname:n { #2 } }
       {
         #1
            { pdfdict }
            { show-dict }
            { \tl_to_str:n {#2} }
            { \prop_map_function:cN {\@@_gname:n { #2 }} \msg_show_item:nn }
            { global }
            { }
       }
    \bool_if:nF {\prop_if_exist_p:c {\@@_gname:n { #2 }} || \prop_if_exist_p:c {\@@_name:n { #2 }} }
       {
         #1 { pdfdict } { unknown-dict } { #2 } { global~or~local }{}{}
       }
  }
\cs_new_protected:Npn \pdfdict_show:n #1
  {
    \@@_show:Nn \msg_show:nnxxxx {#1}
  }
%</package>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \@@_map:n, \@@_gmap:n
%   }
% \cs{@@_map:n} and \cs{@@_gmap:n} output a prop as needed in a dictionary:
%  as a list of /\meta{key} \meta{value} pairs.
% \begin{NOTE}{UF}
%  !! is e-expansion the right thing?
% \end{NOTE}
%    \begin{macrocode}
%<*package>
\cs_new:Npn \@@_map:n #1 %dict
  {
    \prop_map_function:cN { \@@_name:n { #1 } } \@@_item:ne
  }

\cs_set_eq:NN \pdfdict_map:n \@@_map:n

\cs_new:Npn \@@_gmap:n #1 %dict
  {
    \prop_map_function:cN { \@@_gname:n { #1 } } \@@_item:ne
  }

\cs_set_eq:NN \pdfdict_gmap:n \@@_gmap:n
%</package>
%    \end{macrocode}
% \end{macro}
%
% \subsection{Predeclared dictionaries}
% \begin{variable}{page/Trans}
%     \begin{macrocode}
%<*package>
\pdfdict_new:n {page/Trans}
\pdfdict_put:nnn {page/Trans}{Type}{/Trans}
% keys: /S (name), /D integer, /Dm (name), /M (name), /SS number /B boolean.
% decribes transition *to* the page.
%</package>
%    \end{macrocode}
% \end{variable}

% \end{implementation}
%
% \PrintIndex
